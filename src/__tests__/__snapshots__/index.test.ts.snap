// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`download as stream 1`] = `
Array [
  Object {
    "body": "Dean Edwards wrote:
> http://blogs.msdn.com/cwilso/archive/2007/10/31/what-i-think-about-es4.aspx

Rather than respond directly, I'd just like to concur with what Brendan 
wrote (in case someone here missed it):

http://weblogs.mozillazine.org/roadmap/archives/2007/10/open_letter_to_chris_wilson.html

Chris Pine
Opera Software",
    "header": Object {
      "date": 2007-11-01T10:33:53.000Z,
      "from": Object {
        "email": "chrispi@opera.com",
        "name": "Chris Pine",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Chris%20Wilson%3A%20What%20I%20think%20about%20ES4&In-Reply-To=4728CB86.5030908%40edwards.name",
      "subject": "Chris Wilson: What I think about ES4",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004884.html",
  },
  Object {
    "body": "On Oct 31, 2007, at 10:21 AM, Brendan Eich wrote:

>> One thing could make this a little smoother would be a constructor
>> for a global object, with it's own set of global values, Object,
>> Array, etc. for the sandboxed code to mutilate. Nice, but I don't
>> think necessary.
>
> This is exactly the path we went down.

See http://wiki.ecmascript.org/doku.php? 
id=discussion:resurrected_eval#resolved_issues.

/be",
    "header": Object {
      "date": 2007-11-01T10:37:25.000Z,
      "from": Object {
        "email": "brendan@mozilla.org",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=%5BTLUG%5D%3A%20ECMAScript%20%28%22Javascript%22%29%20Version%204%20-%20FALSE%20ALARM&In-Reply-To=C6B0064E-1AE7-4F9A-A6E2-1240414D1493%40mozilla.org",
      "subject": "[TLUG]: ECMAScript (\\"Javascript\\") Version 4 - FALSE ALARM",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004885.html",
  },
  Object {
    "body": "Great to hear this important issue is being thoroughly discussed and 
examined.
Thanks,
Kris
----- Original Message ----- 
From: \\"Brendan Eich\\" <brendan at mozilla.org>
To: \\"Kris Zyp\\" <kriszyp at xucia.com>
Cc: <es4-discuss at mozilla.org>
Sent: Thursday, November 01, 2007 3:37 AM
Subject: Re: [TLUG]: ECMAScript (\\"Javascript\\") Version 4 - FALSE ALARM


> On Oct 31, 2007, at 10:21 AM, Brendan Eich wrote:
>
>>> One thing could make this a little smoother would be a constructor
>>> for a global object, with it's own set of global values, Object,
>>> Array, etc. for the sandboxed code to mutilate. Nice, but I don't
>>> think necessary.
>>
>> This is exactly the path we went down.
>
> See http://wiki.ecmascript.org/doku.php? 
> id=discussion:resurrected_eval#resolved_issues.
>
> /be
>",
    "header": Object {
      "date": 2007-11-01T14:39:31.000Z,
      "from": Object {
        "email": "kriszyp@xucia.com",
        "name": "Kris Zyp",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=%5BTLUG%5D%3A%20ECMAScript%20%28%22Javascript%22%29%20Version%204%20-%20FALSE%20ALARM&In-Reply-To=",
      "subject": "[TLUG]: ECMAScript (\\"Javascript\\") Version 4 - FALSE ALARM",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004886.html",
  },
  Object {
    "body": ">> It's a sandbox, right? Should be safe. Not so fast:

> last they gave up.  rexec was removed from the language.  I know of no

Utilizing a sandbox is not a new concept to JavaScript. Browsers create a
sandbox everytime there is a frame from a different domain. With hacks,
these sandboxes can even pass information between each other. Fragment
identifier takes the safer road with string only message passing. Subspace
is another hack that allows real objects to be passed.
Of course the challenge is providing a safer, easier mechanism for
sandboxing with meaningful communication, and providing it at the language
level. I think I am seeing how some of the different aspects of the language
are different parts of putting the puzzle together. But sandboxing itself is
not unexplored territory with JS implementors.
BTW, If only string information was allowed to flow between, this would not
be nearly as difficult, right?
Kris
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://mail.mozilla.org/pipermail/es-discuss/attachments/20071101/30157a37/attachment-0002.html",
    "header": Object {
      "date": 2007-11-01T20:46:20.000Z,
      "from": Object {
        "email": "kriszyp@xucia.com",
        "name": "Kris Zyp",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Restricted%20Eval&In-Reply-To=",
      "subject": "Restricted Eval",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004887.html",
  },
  Object {
    "body": "On Nov 1, 2007 3:46 PM, Kris Zyp <kriszyp at xucia.com> wrote:
> >> It's a sandbox, right? Should be safe. Not so fast:
>
> > last they gave up.  rexec was removed from the language.  I know of no
>
> Utilizing a sandbox is not a new concept to JavaScript. Browsers create a
> sandbox everytime there is a frame from a different domain.

Kris,

That sandbox has been very carefully designed and implemented--and
reimplemented--over a period of decades by people who specialize in
the field.  I don't want to get too far into it, but it's seriously
not the best analogy.  The browser sandbox is complex and nuanced.
It's nontrivial to see why it's secure.  It exposes rather a lot of
objects.  There are many potential holes that are specially plugged.
I don't know about other browsers, but at Mozilla we still haven't
reduced the pace of vulnerabilities to zero, and these guys been at it
for some time now.  (This year--2007, mind you--saw significant new
work on Mozilla's sandboxing model.  Not a joke.)

What you're talking about is a simple sandbox-construction scheme.
You would want it to be the opposite of the browser sandbox in a lot
of respects.  You would want it to be simple, trivially secure,
exposing a small surface of attack, devoid of special cases, and with
zero vulnerabilities by construction.  All of which may be possible--I
hear .NET has some easy, high-level sandboxing APIs--but browser
vendors' JavaScript experience doesn't necessarily translate.

But the only point I was trying to make was that providing a fun
eval(s, obj) and encouraging users to \\"roll their own\\" sandboxes would
be irresponsible.

> BTW, If only string information was allowed to flow between, this would not be nearly as difficult, right?

Urrrr, I'm not sure, but anyway that isn't the feature people are
asking for.  Sandboxes are useful because they expose limited
*functionality*--meaning objects and methods--to untrusted code.

I'd better stop here, because I'm not an expert on this.

-j",
    "header": Object {
      "date": 2007-11-01T23:13:03.000Z,
      "from": Object {
        "email": "jason.orendorff@gmail.com",
        "name": "Jason Orendorff",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Restricted%20Eval&In-Reply-To=a641e4910711011346q2e0f3504ke89bfcdef7a1fd76%40mail.gmail.com",
      "subject": "Restricted Eval",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004888.html",
  },
  Object {
    "body": ">
>
> But the only point I was trying to make was that providing a fun
> eval(s, obj) and encouraging users to \\"roll their own\\" sandboxes would
> be irresponsible.


Point taken, you are right. I still hope that some type of sandboxing can be
developed though.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://mail.mozilla.org/pipermail/es-discuss/attachments/20071101/63c9b695/attachment-0002.html",
    "header": Object {
      "date": 2007-11-01T23:27:17.000Z,
      "from": Object {
        "email": "kriszyp@xucia.com",
        "name": "Kris Zyp",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Restricted%20Eval&In-Reply-To=bb8868b90711011613h23edcc59rfc952978ad2b3b06%40mail.gmail.com",
      "subject": "Restricted Eval",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004889.html",
  },
  Object {
    "body": "ATTENTION: SIR,

MY NAME IS MR.Kojo Abe .I AM THE MANAGER OF THE INTERNATIONAL
 COMMERCIAL
BRANCH BANK GHANA, I AM A GHANAIAN MARRIED WITH TWO KIDS, I NEED A
 TRUST
WORTHY PARTNER TO ASSIST ME IN THE TRANSFER OF (5.5M US DOLLARS) US
 $STATES
DOLLARS. FOR FURTHER INVESTMENT IN YOUR COUNTRY.

YOU WILL BE REQUIRED TO.
(1) ASSIST ME IN THE TRANSFER OF THIS SUM TO YOUR BANK ACCOUNT.
(2) ADVISE ON AREAS FOR POTENTIAL FUTURE INVESTMENT IN YOUR COUNTRY.
(3) ASSIST ME IN CARRYING A FEASIBILITY STUDY BEFORE ACTUAL
INVESTMENT. IF YOU DECIDE TO RENDER YOUR SERVICE TO ME IN THIS
 REGARD,YOU
WILL BE PAID 35%OF THE TOTAL FUNDS FOR ASSISTANCE .REPLY BACK THIS
 EMAIL IF
YOU ARE
WILLING TO WORK WITH ME.  RESPECTFULLY,

REGARDS,

MR.Kojo Abe.",
    "header": Object {
      "date": 2007-11-02T02:52:53.000Z,
      "from": Object {
        "email": "kojo_abe1@hotmail.com",
        "name": "Kojo Abe",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=%2A%2A%2ASPAM%2A%2A%2A%20from%20ghana&In-Reply-To=",
      "subject": "***SPAM*** from ghana",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004890.html",
  },
  Object {
    "body": "Attacks of a similar nature commented Chief Executive of mi2g DK Matai.
Now broadband is never far from the lips from the senior executives of BT.",
    "header": Object {
      "date": 2007-11-02T12:49:30.000Z,
      "from": Object {
        "email": "mipponicom@nipponico.com",
        "name": "Jermaine Metz",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Puts%20it%20off%20to%20a%20compelld.&In-Reply-To=",
      "subject": "Puts it off to a compelld.",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004891.html",
  },
  Object {
    "body": "As far as I can see it, there are a couple of non-technical issues here
that have to be resolved, but they all boil down to who is willing to
implement what. Is there truly no way to compromise?

MS says that they think ES4 deserves to a be a new language. Suppose
that is true and ES4 is renamed, say ES++. Then would MS be willing to
implementing ES++ in their new browser? Or is the name truly a scapegoat
to blame their misgivings of ES4 the language itself?

Or if you consider the feature set of ES4 to be too bloated, that ES4 is
trying to tackle problems it was never meant to handle, what exactly do
you dislike about ES4? What features would do you want to cut out of the
language? What features would the pro-ES4 people be willing to cut out?
I know this will be hard, but let's ignore feature dependencies for the
moment. Say, for example, that you dislike the class system but are fine
with the type system (as nonsensical as that sounds). Perhaps you're
fine with grafting a type system on top of the prototype system without
classes. Or if you also dislike the type system, what do you propose
instead? For encapsulation, you might propose sticking with closures.
Now, how are you going to address the pitfalls of closures, namely
memory usage and inefficiency? ES4 advocates may also be concerned that
encapsulation via closures is plain ugly, while ES4 critics say that
classes make the language inelegant. Perhaps there is another solution?
Anyway, do you see where I'm getting with this? There should be some
room for compromise. I'd like to see some active discussion concerning
these feature disagreements.

Lastly, all this accusations concerning intentions need to stop.
Mozilla, this concerns you too - I find that saying you won't let big
bully MS block ES4 is somewhat hypocritical, considering that the SVG
1.2 committee did something similar to you guys (make no mistake, I'm
not accusing anyone and I hope this is the last time SVG is mentioned on
this mailing list). In any case, hypocritical or not, all these
accusations are not constructive at all. Responding to accusations with
more accusations is plain sophomoric in my book. Please, I have enough
of my political bullshit from the news - I don't expect that here.

Thanks, Yuh-Ruey Chen",
    "header": Object {
      "date": 2007-11-02T21:40:41.000Z,
      "from": Object {
        "email": "maian330@gmail.com",
        "name": "Yuh-Ruey Chen",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Es4-discuss%20Digest%2C%20Vol%208%2C%20Issue%2044&In-Reply-To=D29BF9DB-746C-4252-8E91-5593B79A8B9A%40mozilla.org",
      "subject": "Es4-discuss Digest, Vol 8, Issue 44",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004892.html",
  },
  Object {
    "body": "All,

There's a new release of the ES4 reference implementation available at

     http://www.ecmascript.org/download.php

There are now binaries for Windows and Linux (glibc 2.3) as well as 
MacOS X PPC and Intel. There is also an updated source release. Download 
it today and try it out!

We're working on the build process. We should be releasing more 
frequently as we work out the kinks.

Enjoy,
Dave",
    "header": Object {
      "date": 2007-11-02T22:46:10.000Z,
      "from": Object {
        "email": "dherman@ccs.neu.edu",
        "name": "Dave Herman",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=new%20release&In-Reply-To=",
      "subject": "new release",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004893.html",
  },
  Object {
    "body": "On Nov 2, 2007, at 2:40 PM, Yuh-Ruey Chen wrote:

> Lastly, all this accusations concerning intentions need to stop.

In the absence of technical arguments, these are inevitable.

> Mozilla, this concerns you too - I find that saying you won't let big
> bully MS block ES4 is somewhat hypocritical, considering that the SVG
> 1.2 committee did something similar to you guys (make no mistake, I'm
> not accusing anyone and I hope this is the last time SVG is  
> mentioned on
> this mailing list).

If you mean SVG Tiny 1.2 violating W3C process rules by skipping from  
Working Draft to Candidate Recommendation without addressing all  
received technical objections, there's no comparison. We working on  
ES4 could use some specific technical objections from the Ecma  
members who oppose ES4. I promise we wouldn't ignore any before  
moving ES4 to the final stage of Ecma standardization (there is no CR  
analogue in Ecma).

Hey, you brought this up -- no fair doing a drive-by about SVG while  
I'm in earshot! :-)

> In any case, hypocritical or not, all these
> accusations are not constructive at all. Responding to accusations  
> with
> more accusations is plain sophomoric in my book. Please, I have enough
> of my political bullshit from the news - I don't expect that here.

If these are inevitable because technical objections haven't been  
made, that tells you something important. The politics are overriding  
technical considerations. Act accordingly, but please, don't assume  
there is a technical fix to a political problem. Forcing one by a  
bartering process will only make a Franken-standard.

/be

-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://mail.mozilla.org/pipermail/es-discuss/attachments/20071102/2ea37a16/attachment-0002.html",
    "header": Object {
      "date": 2007-11-02T22:53:58.000Z,
      "from": Object {
        "email": "brendan@mozilla.org",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Es4-discuss%20Digest%2C%20Vol%208%2C%20Issue%2044&In-Reply-To=472B9959.4030204%40gmail.com",
      "subject": "Es4-discuss Digest, Vol 8, Issue 44",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004894.html",
  },
  Object {
    "body": "Hello :)

Thanks for your works and this new version :)

EKA+ :)

2007/11/2, Dave Herman <dherman at ccs.neu.edu>:
>
> All,
>
> There's a new release of the ES4 reference implementation available at
>
>      http://www.ecmascript.org/download.php
>
> There are now binaries for Windows and Linux (glibc 2.3) as well as
> MacOS X PPC and Intel. There is also an updated source release. Download
> it today and try it out!
>
> We're working on the build process. We should be releasing more
> frequently as we work out the kinks.
>
> Enjoy,
> Dave
> _______________________________________________
> Es4-discuss mailing list
> Es4-discuss at mozilla.org
> https://mail.mozilla.org/listinfo/es4-discuss
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://mail.mozilla.org/pipermail/es-discuss/attachments/20071103/2986fa3c/attachment-0002.html",
    "header": Object {
      "date": 2007-11-02T23:10:24.000Z,
      "from": Object {
        "email": "ekameleon@gmail.com",
        "name": "ekameleon",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=new%20release&In-Reply-To=472BA8B2.5030607%40ccs.neu.edu",
      "subject": "new release",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004895.html",
  },
  Object {
    "body": "Dave Herman wrote:
> All,
> 
> There's a new release of the ES4 reference implementation available at
> 
>      http://www.ecmascript.org/download.php
> 
> There are now binaries for Windows and Linux (glibc 2.3) as well as 
> MacOS X PPC and Intel. There is also an updated source release. Download 
> it today and try it out!

Sooo much easier to get running than the previous cygwin thingy. Thanks a lot!

Jonathan",
    "header": Object {
      "date": 2007-11-03T03:01:33.000Z,
      "from": Object {
        "email": "jwatt@jwatt.org",
        "name": "Jonathan Watt",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=new%20release&In-Reply-To=472BA8B2.5030607%40ccs.neu.edu",
      "subject": "new release",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004898.html",
  },
  Object {
    "body": "thank you :)",
    "header": Object {
      "date": 2007-11-03T11:51:01.000Z,
      "from": Object {
        "email": "zwetan@gmail.com",
        "name": "zwetan",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=new%20release&In-Reply-To=472BA8B2.5030607%40ccs.neu.edu",
      "subject": "new release",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004896.html",
  },
  Object {
    "body": "After the heated debate, I took time to write my opinion on the subject, 
for what it's worth :

http://blog.haxe.org/entry/25

Nicolas",
    "header": Object {
      "date": 2007-11-03T16:03:21.000Z,
      "from": Object {
        "email": "ncannasse@motion-twin.com",
        "name": "Nicolas Cannasse",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Chris%20Wilson%3A%20What%20I%20think%20about%20ES4&In-Reply-To=4728CB86.5030908%40edwards.name",
      "subject": "Chris Wilson: What I think about ES4",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004897.html",
  },
  Object {
    "body": "On 11/3/07, Nicolas Cannasse <ncannasse at motion-twin.com> wrote:
> After the heated debate, I took time to write my opinion on the subject,
> for what it's worth :
>

Debate? Where? I didn't see any debate on Chris' blog. It looked more
like something we could expect to see from American politicians; or a
good episode of Jerry Springer. Some vague claims, some suggestions,
some accusations, but no debate. I want to see facts, cold, reasoned
analysis, pros/cons. Real debate. And I want to see it here; debate on
ES4 belongs here, on this list, not scattered through various blogs.

Chris, where are you?

Garrett

>
> Nicolas
> _______________________________________________
> Es4-discuss mailing list
> Es4-discuss at mozilla.org
> https://mail.mozilla.org/listinfo/es4-discuss
>


-- 
Programming is a collaborative art.",
    "header": Object {
      "date": 2007-11-03T21:34:07.000Z,
      "from": Object {
        "email": "dhtmlkitchen@gmail.com",
        "name": "Garrett Smith",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Chris%20Wilson%3A%20What%20I%20think%20about%20ES4&In-Reply-To=472C9BC9.5070507%40motion-twin.com",
      "subject": "Chris Wilson: What I think about ES4",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004899.html",
  },
  Object {
    "body": "Nicolas Cannasse wrote:
> I personaly don't care about Microsoft opinion EXCEPT that they are 
> the ones doing Internet Explorer (IE), you know, that (still) 80% 
> market share internet browser, the one your users are visiting your 
> website with...
>
> So, as developers, we're out of luck.
>
> Mozilla and Adobe thought the same and came up with the 
> ScreamingMonkey project, which is an ES4 runtime that can be installed 
> for Internet Explorer. Nice, but how long will that work ? Given that 
> Microsoft has no intention of helping, I can foresee that each 
> IE/Windows update will break something.

I thought that ScreamingMonkey planned on using a published & fairly 
stable API to do this.  Does anyone know of non-Microsoft users of this 
API?  How hard would it be for them to break it?

Assuming that vbscript and silverlight use this same API, I have to 
think they'd be pretty conservative with it.  Even if it were to change, 
it couldn't be that hard for ScreamingMonkey to keep up.

Mitch",
    "header": Object {
      "date": 2007-11-04T16:41:57.000Z,
      "from": Object {
        "email": "lists@arctur.us",
        "name": "Mitch Skinner",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Chris%20Wilson%3A%20What%20I%20think%20about%20ES4&In-Reply-To=472C9BC9.5070507%40motion-twin.com",
      "subject": "Chris Wilson: What I think about ES4",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004900.html",
  },
  Object {
    "body": "On 04/11/2007, Mitch Skinner <lists at arctur.us> wrote:
> Nicolas Cannasse wrote:
> > Mozilla and Adobe thought the same and came up with the
> > ScreamingMonkey project, which is an ES4 runtime that can be installed
> > for Internet Explorer. Nice, but how long will that work ? Given that
> > Microsoft has no intention of helping, I can foresee that each
> > IE/Windows update will break something.
>
> I thought that ScreamingMonkey planned on using a published & fairly
> stable API to do this.  Does anyone know of non-Microsoft users of this
> API?  How hard would it be for them to break it?

Very, very hard. The API might not be considered the most well
designed any longer, but there's hooks for it absolutely everywhere.
Most notably, it's used by WSH (the windows scripting host), by IIS
(in ASP), by IE, by outlook, by visual studio etc.

Microsoft has a compatibility nightmare if they decide to change it by
any other means than adding new features.

> Assuming that vbscript and silverlight use this same API, I have to
> think they'd be pretty conservative with it.  Even if it were to change,
> it couldn't be that hard for ScreamingMonkey to keep up.

First of all, Silverlight uses a brand new scripting engine, called
Managed JScript, that runs on the DLR on top of the .NET CLR. Managed
JScript doesn't use the Active Scripting APIs at all, from what I've
read about it.


Second, Microsoft can do absolutely nothing to it except for
additions. There are outside users of these APIs from both sides, e.g.
the ActiveScripting languages such as ActivePerl, ActivePython,
ActiveRuby, HaskellScript use the API from the scripting engine side,
while programs such as the JScript/VBScript external IDEs/debuggers as
well as several in-house applications in major companies use the API
from the host side.
-- 
David \\"liorean\\" Andersson",
    "header": Object {
      "date": 2007-11-04T18:56:15.000Z,
      "from": Object {
        "email": "liorean@gmail.com",
        "name": "liorean",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Chris%20Wilson%3A%20What%20I%20think%20about%20ES4&In-Reply-To=472DF655.60509%40arctur.us",
      "subject": "Chris Wilson: What I think about ES4",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004901.html",
  },
  Object {
    "body": "On 11/4/07, liorean <liorean at gmail.com> wrote:
> On 04/11/2007, Mitch Skinner <lists at arctur.us> wrote:
> > Nicolas Cannasse wrote:

Just curious, but am I the only one having trouble posting replies to
Chris' blog?

I posted a response to his response and answered his question that he
asked me; absolutely nothing inflammatory or even rude in my post.
Just trying to figure out if it's just me.",
    "header": Object {
      "date": 2007-11-04T23:33:03.000Z,
      "from": Object {
        "email": "dhtmlkitchen@gmail.com",
        "name": "Garrett Smith",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Chris%20Wilson%3A%20What%20I%20think%20about%20ES4&In-Reply-To=cee13aa30711041056h5238b48dib225bfeb9158f350%40mail.gmail.com",
      "subject": "Chris Wilson: What I think about ES4",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004902.html",
  },
  Object {
    "body": "On 11/4/07, liorean <liorean at gmail.com> wrote:
> On 04/11/2007, Mitch Skinner <lists at arctur.us> wrote:
> > Nicolas Cannasse wrote:

Just curious, but am I the only one having trouble posting replies to
Chris' blog?

I posted a response to his response and answered his question that he
asked me; absolutely nothing inflammatory or even rude in my post.
Just trying to figure out if it's just me.",
    "header": Object {
      "date": 2007-11-04T23:37:19.000Z,
      "from": Object {
        "email": "dhtmlkitchen@gmail.com",
        "name": "Garrett Smith",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Chris%20Wilson%3A%20What%20I%20think%20about%20ES4&In-Reply-To=cee13aa30711041056h5238b48dib225bfeb9158f350%40mail.gmail.com",
      "subject": "Chris Wilson: What I think about ES4",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004903.html",
  },
  Object {
    "body": "There's this hookey idea percolating that somehow we can use whatever
language we want and compile it to JavaScript and that will be great.
Hold that thought, now check this out:
 
http://community.netikatech.com/demos/
 
I don't care how tricked out your JavaScript VM is, or how awesome your
source language and compiler are, JavaScript today will never reach this
richness of UI.   Look how big and snappy the Flash data grid example
is.  (I love how slow the silverlight one is so slow to load, can anyone
say applets? sorry couldn't help it...)
 
My point is that to reach JVM/CLR speeds ES4 with its strong typing and
early binding are necessities.   Sure a VM can be smart and take simple
untyped code and get you most of the way there with type inference and
runtime profile based JIT'ing but with ES4 dumb (and smaller) VM's can
get great speed just by looking at the typing (ie Tamarin).   But that
really only applies to microbenchmarks doing math in a loop, Tamarin
does good here but that's not what most real applications do.   Most
real applications spend all their time looking up variables, pounding on
symbol tables and visiting memory like crazy.   I'm unaware of any
workable and implemented techniques to get early binding accomplished in
ES3 w/o breaking the language.  Tamarin resorts to no trickery and gets
variable lookups down to a couple instructions and one cache line load,
that's why Tamarin/Java/C# do well in big real world applications that
JavaScript will never be able to handle in its current incarnation.   I
guarantee all JavaScript implementations out there take hundreds of
instructions and at least half dozen cache line loads to look up a
variable today (not counting AS3/Tamarin), if your JavaScript VM can
beat that my hat's off to you (but I won't believe you unless you can
show me the code or explain it in full detail ;-)
 
My point is that while in theory you don't need ES4 for performance
reasons (as accurately espoused by Brendan) in practice ES4 will greatly
help performance and enable more powerful applications like people might
want to built with netikatech's library.   Their stuff is also cool b/c
under the covers I think they are employing a C# to abc (Tamarin's byte
code format) compiler.   Notice they didn't implement a C# to JavaScript
compiler and target DHTML?    Not realistic.  Sure there's other good
reasons for wanting static typing and classes but lets face it, they
help a lot in the speed department and speed is king and ES4 will blow
the doors off of ES3 in practice I bet (although I wouldn't be surprised
if certain unmotivated browser vendors may run ES4 more slowly).  
 
Salient point:  we should pimp the performance potential of ES4 more and
label the anti-ES4 crowd as performance-haters which I don't think is
far from the truth.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://mail.mozilla.org/pipermail/es-discuss/attachments/20071105/3d08e5b1/attachment-0002.html",
    "header": Object {
      "date": 2007-11-05T21:18:52.000Z,
      "from": Object {
        "email": "treilly@adobe.com",
        "name": "Thomas Reilly",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=compiled%20to%20JavaScript%20idea&In-Reply-To=",
      "subject": "compiled to JavaScript idea",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004904.html",
  },
  Object {
    "body": "We've put up a document on ecmascript.org that details all known
incompatibilities between ES3 and Proposed ES4:
http://www.ecmascript.org/es4/spec/incompatibilities.pdf.

Dave summed it up nicely, I think:

\\"It's also interesting to think of conservative extension not as an
all-or-nothing property, but to judge incompatibilities in terms of
their impact. This document attempts to enumerate and classify the
different ways the proposed ES4 spec conflicts with the specification of
ES3.\\"  http://lambda-the-ultimate.org/node/2524

--lars",
    "header": Object {
      "date": 2007-11-06T12:09:51.000Z,
      "from": Object {
        "email": "lhansen@adobe.com",
        "name": "Lars Hansen",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Incompatibilities%20between%20ES3%20and%20Proposed%20ES4&In-Reply-To=",
      "subject": "Incompatibilities between ES3 and Proposed ES4",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004905.html",
  },
  Object {
    "body": "Language overview states: \\"The return type of a function can be written  
void, which means that no return value is allowed.\\".

But the reference implementation doesn't complain about this:

>> type F = function(int,int):void;
>> var f:F=function(a,b){return a+b;};
>> f(2,2);
4

Is the constraint described in the overview prose meant to be applied  
here? If so, when?

-- 
Hallvord R. M. Steen
Core QA JavaScript tester, Opera Software
http://www.opera.com/
Opera - simply the best Internet experience",
    "header": Object {
      "date": 2007-11-07T12:09:43.000Z,
      "from": Object {
        "email": "hallvord@opera.com",
        "name": "Hallvord R. M. Steen",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=function%20types%20with%20void%20return%20type&In-Reply-To=",
      "subject": "function types with void return type",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004906.html",
  },
  Object {
    "body": "A bug, no doubt.  I'll file it (http://bugs.ecmascript.org -- open to
all comers).

My expectation would be a compile-time error if a void function tries
to return a value since it's syntactically detectable, but I don't
remember it being discussed in the group.  (Obtaining the return value
from a void function would be compile-time or run-time, depending on
what the compiler knows.)

--lars

On 11/7/07, Hallvord R. M. Steen <hallvord at opera.com> wrote:
> Language overview states: \\"The return type of a function can be written
> void, which means that no return value is allowed.\\".
>
> But the reference implementation doesn't complain about this:
>
> >> type F = function(int,int):void;
> >> var f:F=function(a,b){return a+b;};
> >> f(2,2);
> 4
>
> Is the constraint described in the overview prose meant to be applied
> here? If so, when?
>
> --
> Hallvord R. M. Steen
> Core QA JavaScript tester, Opera Software
> http://www.opera.com/
> Opera - simply the best Internet experience
> _______________________________________________
> Es4-discuss mailing list
> Es4-discuss at mozilla.org
> https://mail.mozilla.org/listinfo/es4-discuss
>",
    "header": Object {
      "date": 2007-11-07T13:13:58.000Z,
      "from": Object {
        "email": "lth@acm.org",
        "name": "Lars T Hansen",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=function%20types%20with%20void%20return%20type&In-Reply-To=op.t1e72htha3v5gv%40hr-opera.oslo.opera.com",
      "subject": "function types with void return type",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004907.html",
  },
  Object {
    "body": "Howdy,

On Monday 05 November 2007 1:18 pm, Thomas Reilly wrote:
> There's this hookey idea percolating that somehow we can use whatever
> language we want and compile it to JavaScript and that will be great.
> Hold that thought, now check this out:
>
> http://community.netikatech.com/demos/
>
> I don't care how tricked out your JavaScript VM is, or how awesome
> your source language and compiler are, JavaScript today will never
> reach this richness of UI.   Look how big and snappy the Flash data
> grid example is.  (I love how slow the silverlight one is so slow to
> load, can anyone say applets? sorry couldn't help it...)

The flash version is indeed snappy by comparison, but it's kind of a 
rigged game. The silverlight version it needs is an alpha, and they'll 
have plenty of chances to iterate. I don't think this demo is a dig 
against ES3 in any way. Indeed, we can do better than the Silverlight 
example without resorting to plugins of any variety:

see:
http://download.dojotoolkit.org/release-1.0.0/dojo-release-1.0.0/dojox/grid/tests/

for locked columns and virtual scrolling:
http://download.dojotoolkit.org/release-1.0.0/dojo-release-1.0.0/dojox/grid/tests/test_change_structure.html

For full effect, try it on Safari 3 or a recent Minefield/GranParadiso 
build. 

If we can get similar performance for tasks like this in raw-browser 
environments (on today's ES3 implementations), then biting off the 
entire rendering phase is absolutely the wrong problem to solve. Your 
example points out to me not that having a better VM matters...it's 
that the level of effort to get to a UI which is completely 
inappropriate on my Mac is tremendously high ;-)

[ snip ]

> Salient point:  we should pimp the performance potential of ES4 more
> and label the anti-ES4 crowd as performance-haters which I don't
> think is far from the truth.

This strikes me as both dangerous and wrong. That many of the folks 
railing against ES4 are using weak arguments doesn't seem to me to be a 
green light to do the same in favor of the new language.

Regards

-- 
Alex Russell
alex at sitepen.com     A99F 8785 F491 D5FD 04D7 ACD9 4158 FFDF 2894 6876
alex at dojotoolkit.org BE03 E88D EABB 2116 CC49 8259 CF78 E242 59C3 9723
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 186 bytes
Desc: not available
Url : http://mail.mozilla.org/pipermail/es-discuss/attachments/20071108/1603a03b/attachment-0002.bin",
    "header": Object {
      "date": 2007-11-08T12:33:28.000Z,
      "from": Object {
        "email": "alex@dojotoolkit.org",
        "name": "Alex Russell",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=compiled%20to%20JavaScript%20idea&In-Reply-To=AD0C8E6047016B48A53660CD4888CE3902BE7813%40namail4.corp.adobe.com",
      "subject": "compiled to JavaScript idea",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004908.html",
  },
  Object {
    "body": "On Nov 8, 2007 12:33 PM, Alex Russell <alex at dojotoolkit.org> wrote:
[...]
>
> The flash version is indeed snappy by comparison, but it's kind of a
> rigged game. The silverlight version it needs is an alpha, and they'll
> have plenty of chances to iterate. I don't think this demo is a dig
> against ES3 in any way. Indeed, we can do better than the Silverlight
> example without resorting to plugins of any variety:
>
> see:
> http://download.dojotoolkit.org/release-1.0.0/dojo-release-1.0.0/dojox/grid/tests/
>
> for locked columns and virtual scrolling:
> http://download.dojotoolkit.org/release-1.0.0/dojo-release-1.0.0/dojox/grid/tests/test_change_structure.html
>
> For full effect, try it on Safari 3 or a recent Minefield/GranParadiso
> build.
>
> If we can get similar performance for tasks like this in raw-browser
> environments (on today's ES3 implementations), then biting off the
> entire rendering phase is absolutely the wrong problem to solve. Your
> example points out to me not that having a better VM matters...it's
> that the level of effort to get to a UI which is completely
> inappropriate on my Mac is tremendously high ;-)
>
> [ snip ]

if you stay on ES3 the only place where you can improve the performance
is the engine interpreting the JS,
but even with the best of breed interpreter you ll hit a dead end at
one moment or another
(I mean you can not infinitely squeeze performance out of the engine,
it has limits)

types and other things added in ES4 can help an engine to have better
performance
wether if you got an engine that interpret the raw script or a VM that
run the bytecode
of the compiled script,
but even with that I think a VM will be able to squeeze out even more
performance.

I don't say Tamarin and ES4 are fully related, but the combination of the two
is exactly what gonna bring huge performance improvement imho.

so, you must have guessed, I don't agree

zwetan",
    "header": Object {
      "date": 2007-11-08T13:03:34.000Z,
      "from": Object {
        "email": "zwetan@gmail.com",
        "name": "zwetan",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=compiled%20to%20JavaScript%20idea&In-Reply-To=200711080433.30550.alex%40dojotoolkit.org",
      "subject": "compiled to JavaScript idea",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004909.html",
  },
  Object {
    "body": "An HTML attachment was scrubbed...
URL: http://mail.mozilla.org/pipermail/es-discuss/attachments/20071108/42b17632/attachment-0002.html",
    "header": Object {
      "date": 2007-11-08T16:43:36.000Z,
      "from": Object {
        "email": "marketing@fazendaesperanca.net",
        "name": "luciano",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=%2A%2A%2ASPAM%2A%2A%2A%20leilao%20boer%20baby%20canal%20do%20bou%20dia%2015-11-2007&In-Reply-To=",
      "subject": "***SPAM*** leilao boer baby canal do bou dia 15-11-2007",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004910.html",
  },
  Object {
    "body": "I've been reading the blogs and fuss over the the ES4 proposal. It
seems to me that if ES3 was so horribly inadequate then big changes to
the language would be welcomed unanimously. It must be that ES3 is
sufficient to get by well enough that we have the luxury to argue
about the worth of the proposed changes.

Was incremental change to the ES3 language ever considered at the
beginning of the process for ES4? It seems there are many places where
the ES3 language could be improved without changing it's character (ie
adding classes). If ES was developed in a hurry then perhaps there was
plenty of room to strengthen the paradigms it already contains. If
work had continued on ES immediately after ES3 was released, isn't
that what would have happened?

There are things that cannot be done with ES3 that could be added...

Could the Self aspect of ES be strengthened? For example, more control
over prototypes and the prototype chain would make programming with
that model of inheritance a stronger competitor to class-based
inheritance. The read/write __proto__ property could be standardized.
Objects could have multiple prototypes like in Self. A obj.clone()
function.

Could the Scheme aspect of ES be strengthened? Tail recursion and let
statements seem like good additions. What about macros? Please!

Binary download for hiding code seems to be something people have been
trying to achieve through obfuscation but cannot truly do with ES3.

Complete support for secure mash-ups seems essential and not just
because Douglas Crockford says so. Developers want to mash-up and are
doing it now even with the security risks to their unknowing users.

Adding types, classes and interfaces is drawing inspiration from
languages with other models of programming. The new look of ES4 is
very Java-like. Are the screams from the Java programmers enough to
control the future of ES? Adding these constructs seems like an
attempt to try to please everyone. This is the classic anti-pattern in
marketing.

There is an argument that the changes in ES4 are needed for the open
web to keep up with rich platforms like Flash and Silverlight. As far
as snazzy, sparkley user interfaces go, the ES3 language isn't the
problem here but rather it is HTML, the DOM and CSS. Even if Internet
Explorer and all browsers suddenly implemented these other standards
correctly an HTML/JavaScript/CSS page wouldn't be very impressive
compared with a Flash animation. I gulped last weekend when I saw a
friend's flash portfolio with sound, video and vector graphics and
then thought about my rectangular tabbed panes and drop down menus. I
won't be able to do any of the Flash-like stuff with ES4. This
paragraph isn't intended as an argument against changing ES but I
don't think change to ES should be justified by the \\"keeping up\\"
argument.

Has ES3 proven itself to be such a disaster that trying to improve it
incrementally while retaining its character is obviously the wrong
choice? Was ES founded on such poor choices (Self and Scheme) that we
should be moving to completely different style of programming (Java)?

I wouldn't be writing this email had others not spoken up. It seems
somewhat inappropriate and rude to speak against what Brendan Eich is
proposing since it is his language.

Peter",
    "header": Object {
      "date": 2007-11-08T19:28:35.000Z,
      "from": Object {
        "email": "petermichaux@gmail.com",
        "name": "Peter Michaux",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Is%20ES3%20good%20enough%3F%20Was%20incrementally%20strengthening%20ES3%20paradigms%0A%09considered%3F&In-Reply-To=",
      "subject": "Is ES3 good enough? Was incrementally strengthening ES3 paradigms	considered?",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004911.html",
  },
  Object {
    "body": "Thanks for the rebutal, I was wondering if my wild claims would go
unchallenged ;-)

> The flash version is indeed snappy by comparison, but it's kind of a
rigged game. 

Despite my allegences to the mother ship I wasn't recommending Flash or
Silverlight.  I was pointing out that folks are feeling compelled to
resort to them for performance reasons.   Why does Gmail use flash under
the covers for instance?  I'll leave it as a dtrace exercise for the
curious but I bet performance might have something to do with it.

> If we can get similar performance for tasks like this in 
> raw-browser environments (on today's ES3 implementations), 
> then biting off the entire rendering phase is absolutely the 
> wrong problem to solve. 

Again, not my point, its not like these engines are using ES3 to do the
rendering (although I could go off on a tangent about how if you had ES4
and certain key optimizations in the JIT than you could write a fine
renderer in ES4).

> Your example points out to me not that having a better VM
matters...it's that the level of 
> effort to get to a UI which is completely inappropriate on my Mac is
tremendously high ;-)

I know right?  Where's the mac love?  If you don't need more performance
out of your JS engine then good for you!  Lots of people I think want
more performance out of there browsers scripting language and ES4 will
be a catalyst for getting there.  My point is that certain ES4 features
(ie classes and strong typing) will enble (in theory) ES4
implementations to provide the same level of performance Java and C#
have.

This is the second time I've heard Safari 3's performance being raved
about.  Anyone have any benchmark pointers?

> > Salient point:  we should pimp the performance potential of 
> ES4 more 
> > and label the anti-ES4 crowd as performance-haters which I 
> don't think 
> > is far from the truth.
> 
> This strikes me as both dangerous and wrong. That many of the 
> folks railing against ES4 are using weak arguments doesn't 
> seem to me to be a green light to do the same in favor of the 
> new language.

Why is my argument weak?  Please tell me how ES3 can reach the same
level of performance as Java/C#, I'd love to hear it!  

Maybe its an indulgence on my part to jump to the conclusion that
certain ES4 detractors are doing so b/c they don't want ES4
implementation to match their own preferred language/platform in
performance but I stand by my claim that ES4 is an enabler for such
performance gains.",
    "header": Object {
      "date": 2007-11-08T19:31:46.000Z,
      "from": Object {
        "email": "treilly@adobe.com",
        "name": "Thomas Reilly",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=compiled%20to%20JavaScript%20idea&In-Reply-To=200711080433.30550.alex%40dojotoolkit.org",
      "subject": "compiled to JavaScript idea",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004912.html",
  },
  Object {
    "body": "An HTML attachment was scrubbed...
URL: http://mail.mozilla.org/pipermail/es-discuss/attachments/20071109/3eb8aa9a/attachment-0002.html",
    "header": Object {
      "date": 2007-11-09T02:06:20.000Z,
      "from": Object {
        "email": "marketing@fazendaesperanca.net",
        "name": "luciano",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=%2A%2A%2ASPAM%2A%2A%2A%20leilao%20boer%20baby%20canal%20do%20bou%20dia%2015-11-2007&In-Reply-To=",
      "subject": "***SPAM*** leilao boer baby canal do bou dia 15-11-2007",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004913.html",
  },
  Object {
    "body": "Is there any reason why this proposal isn't being considered?

Not only is (int | string) more intuitive than (int, string), the (int,
string) syntax can be reserved for another yet-unknown purpose.

Along the same lines, I find the syntax for constraining list types to
be unintuitive. [int] is very different from [int, string], and [int,
string] is very different from (int, string). Perhaps that (int, string)
can describe the tuple type. And [int | string] could be syntactic sugar
for [(int | string)]. The usage of \\"|\\" improves readability in that
there's no way to confuse a union type with a tuple type.

-Yuh-Ruey Chen

Jason Orendorff wrote:
> On Oct 26, 2007 6:35 PM, James Clark <jjc at jclark.com> wrote:
> > (int, string) doesn't seem to me to be a syntax that the average JS
> > programmer will guess means union. I would have thought a better choice
> > would be (int | string) (especially given that regexps use |) or a keyword.
>
> Yep.  I read (int, string) as a tuple type every time.  ML, Haskell,
> Python 3.0... I'm not sure what we gain by going against the grain
> here.
>
> So it's not a big deal, but switching to (t1 | t2) seems all upside to
> me.  It's a shallow change.  +1.
>
> -j
> _______________________________________________
> Es4-discuss mailing list
> Es4-discuss at mozilla.org
> https://mail.mozilla.org/listinfo/es4-discuss
>
>",
    "header": Object {
      "date": 2007-11-09T09:06:02.000Z,
      "from": Object {
        "email": "maian330@gmail.com",
        "name": "Yuh-Ruey Chen",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Syntax%20for%20union%20types&In-Reply-To=bb8868b90710290856y7db09f0aw1975db980c784b53%40mail.gmail.com",
      "subject": "Syntax for union types",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004914.html",
  },
  Object {
    "body": "> -----Original Message-----
> From: es4-discuss-bounces at mozilla.org 
> [mailto:es4-discuss-bounces at mozilla.org] On Behalf Of Yuh-Ruey Chen
> Sent: 9. november 2007 01:06
> To: Jason Orendorff
> Cc: es4-discuss at mozilla.org
> Subject: Re: Syntax for union types
> 
> Is there any reason why this proposal isn't being considered?

Yes.  The current syntax has been accepted by the working group.  We
have made use of it in various contexts, (builtins, ESC).  Speaking for
myself I don't see the problem with what we have.

> Not only is (int | string) more intuitive than (int, string), 
> the (int, string) syntax can be reserved for another yet-unknown
purpose.

Intuition tends to be personal, and the other argument can be turned on
its head (why wouldn't I want to use \\"int | string\\" for something else
in the future?).  Since \\"|\\" is bitwise or, \\"||\\" would have been better,
but that has yet other connotations.

> Along the same lines, I find the syntax for constraining list 
> types to be unintuitive. [int] is very different from [int, 
> string], and [int, string] is very different from (int, 
> string). Perhaps that (int, string) can describe the tuple 
> type. And [int | string] could be syntactic sugar for [(int | 
> string)]. The usage of \\"|\\" improves readability in that 
> there's no way to confuse a union type with a tuple type.

This has been discussed at considerable length, and we've concluded that
the current solution represents a workable compromise.

Syntax discussions are not fruitless, but the decisions for the things
you mention above were not arbitrary, and there is, to my knowledge, no
inclination inside the group to revisit the choices.

(More interesting open questions about the language are whether generic
functions ought to be available on instances or discriminating on
structural types, or whether packages ought to be sealable for security,
or whether ES4 precludes the use of current ES3 AOP patterns and how
that might be solved.  Among other things.)

--lars

> 
> -Yuh-Ruey Chen
> 
> Jason Orendorff wrote:
> > On Oct 26, 2007 6:35 PM, James Clark <jjc at jclark.com> wrote:
> > > (int, string) doesn't seem to me to be a syntax that the 
> average JS 
> > > programmer will guess means union. I would have thought a better 
> > > choice would be (int | string) (especially given that 
> regexps use |) or a keyword.
> >
> > Yep.  I read (int, string) as a tuple type every time.  ML, 
> Haskell, 
> > Python 3.0... I'm not sure what we gain by going against the grain 
> > here.
> >
> > So it's not a big deal, but switching to (t1 | t2) seems 
> all upside to 
> > me.  It's a shallow change.  +1.
> >
> > -j
> > _______________________________________________
> > Es4-discuss mailing list
> > Es4-discuss at mozilla.org
> > https://mail.mozilla.org/listinfo/es4-discuss
> >
> >   
> _______________________________________________
> Es4-discuss mailing list
> Es4-discuss at mozilla.org
> https://mail.mozilla.org/listinfo/es4-discuss
>",
    "header": Object {
      "date": 2007-11-09T15:31:07.000Z,
      "from": Object {
        "email": "lhansen@adobe.com",
        "name": "Lars Hansen",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Syntax%20for%20union%20types&In-Reply-To=473422FA.8090706%40gmail.com",
      "subject": "Syntax for union types",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004915.html",
  },
  Object {
    "body": "On Nov 9, 2007 4:31 PM, Lars Hansen <lhansen at adobe.com> wrote:
[snip]
>
> (More interesting open questions about the language are whether generic
> functions ought to be available on instances or discriminating on
> structural types, or whether packages ought to be sealable for security,
> or whether ES4 precludes the use of current ES3 AOP patterns and how
> that might be solved.  Among other things.)
>

the option to have sealed package would be indeed an interesting feature in ES4,
is this is discussed somewhere in the wiki ?

cheers,
zwetan",
    "header": Object {
      "date": 2007-11-09T15:48:57.000Z,
      "from": Object {
        "email": "zwetan@gmail.com",
        "name": "zwetan",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Syntax%20for%20union%20types&In-Reply-To=1421FCFA117AA044B447467FDE380715D471B3%40eurmail.eur.adobe.com",
      "subject": "Syntax for union types",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004916.html",
  },
  Object {
    "body": "> -----Original Message-----
> From: zwetan [mailto:zwetan at gmail.com] 
> Sent: 9. november 2007 07:49
> To: Lars Hansen; es4-discuss
> Subject: Re: Syntax for union types
> 
> On Nov 9, 2007 4:31 PM, Lars Hansen <lhansen at adobe.com> wrote:
> [snip]
> >
> > (More interesting open questions about the language are whether 
> > generic functions ought to be available on instances or 
> discriminating 
> > on structural types, or whether packages ought to be sealable for 
> > security, or whether ES4 precludes the use of current ES3 
> AOP patterns 
> > and how that might be solved.  Among other things.)
> >
> 
> the option to have sealed package would be indeed an 
> interesting feature in ES4, is this is discussed somewhere in 
> the wiki ?

Not to my knowledge, and we've in any case not incorporated anything
like this.

A couple of obvious solutions would be to have package fragments
designated \\"final\\" be the only package fragment for the package, or to
have a \\"final\\"-designated package fragment provide the last fragment of
the package, preventing the loading of subsequent fragments.

Whether this is a good idea or not depends in part on whether you think
packages and namespaces are for secrecy/integrity, as implied by the use
of eg \\"private\\" in a class (\\"private\\" is just a namespace), or if
namespaces are just for collision avoidance.

--lars",
    "header": Object {
      "date": 2007-11-09T16:13:01.000Z,
      "from": Object {
        "email": "lhansen@adobe.com",
        "name": "Lars Hansen",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Syntax%20for%20union%20types&In-Reply-To=122cc48a0711090748k78645454xc5e8f5195a689cfc%40mail.gmail.com",
      "subject": "Syntax for union types",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004917.html",
  },
  Object {
    "body": "On Nov 9, 2007 5:13 PM, Lars Hansen <lhansen at adobe.com> wrote:
> > the option to have sealed package would be indeed an
> > interesting feature in ES4, is this is discussed somewhere in
> > the wiki ?
>
> Not to my knowledge, and we've in any case not incorporated anything
> like this.

ok I thougth that what you mentioned was already discussed by TG1.


>
> A couple of obvious solutions would be to have package fragments
> designated \\"final\\" be the only package fragment for the package, or to
> have a \\"final\\"-designated package fragment provide the last fragment of
> the package, preventing the loading of subsequent fragments.
>
> Whether this is a good idea or not depends in part on whether you think
> packages and namespaces are for secrecy/integrity, as implied by the use
> of eg \\"private\\" in a class (\\"private\\" is just a namespace), or if
> namespaces are just for collision avoidance.
>

well it depends on the context, for security it could be good to have
final package, if I remember well inside the spec there were a namespace exemple
showing how to \\"secure\\" the access to a class using namespaces,
but apparently we don't have access to the spec pages anymore (?).

zwetan",
    "header": Object {
      "date": 2007-11-09T16:53:45.000Z,
      "from": Object {
        "email": "zwetan@gmail.com",
        "name": "zwetan",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Syntax%20for%20union%20types&In-Reply-To=1421FCFA117AA044B447467FDE380715D47229%40eurmail.eur.adobe.com",
      "subject": "Syntax for union types",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004918.html",
  },
  Object {
    "body": "> or whether ES4 precludes the use of current ES3 AOP patterns and how
> that might be solved.  Among other things.)
ES3 AOP is in a class of patterns that is not strictly incompatible as ES3
code alone won't break, but ES3 code would no longer behave as expected when
interacting with ES4 code. AOP and other patterns in ES3 rely on the ability
to add or modify properties on any object. Another example that should be
noted is the O(n) algorithm for duplicate item and cyclic reference
detection. For example:
function findDuplicate(array){
 var map={};
 for (var i = 0; i < array.length; i++) {
  if (typeof array[i] == 'object') {
   if (array[i].__marker)
    alert('found duplicate');
   array[i].__marker = true;
  }
  else {
   if (map[array[i]])
     alert('found duplicate');
   map[array[i]] = true;
  }
 }
}
This algorithm will fail if an array of objects is passed in that includes
instances of non-dynamic (default for user created) classes. Temporarily
marking objects with dynamic properties is the only way I am aware of to
create O(n) algorithms in ES3 to detect duplicates and cyclic references.
I don't think there is anything that can be done about this, it is just a
result of static classes. Code written for ES4 can use maps (I think anyway)
to solve this problem. This has probably already been discussed, but I just
wanted to make sure it was noted.
Kris
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://mail.mozilla.org/pipermail/es-discuss/attachments/20071109/4ae2b264/attachment-0002.html",
    "header": Object {
      "date": 2007-11-09T17:20:04.000Z,
      "from": Object {
        "email": "kriszyp@xucia.com",
        "name": "Kris Zyp",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=ES3%20quasi%20incompatibilities&In-Reply-To=",
      "subject": "ES3 quasi incompatibilities",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004919.html",
  },
  Object {
    "body": "Map and intrinsic::hashcode are your friends, indeed.  Cleaner solution,
too.
 
<rambling>
For non-dynamic classes you can still use meta::set and meta::get to
allow for
limited applications like this.  I keep thinking that there are use
cases for 
global meta::get and meta::set functions, so just like operator
overloading
can be done by extending global, generic functions a la intrinsic::+, it
ought to
be possible to hook into catchalls on the global level, using generic
functions.
 
class C { ... } // not dynamic
 
meta generic function get(c: C, name) {
    if (name == \\"__marker\\")
       ...
    else
       return nextMethod()
}
 
meta generic function set(c: C, name, val) {
    if (name == \\"__marker\\")
        ...
    else
        nextMethod()
}
</rambling>
 
--lars


	
________________________________

	From: es4-discuss-bounces at mozilla.org
[mailto:es4-discuss-bounces at mozilla.org] On Behalf Of Kris Zyp
	Sent: 9. november 2007 09:20
	To: es4-discuss at mozilla.org
	Subject: ES3 quasi incompatibilities
	
	
	
	> or whether ES4 precludes the use of current ES3 AOP patterns
and how
	> that might be solved.  Among other things.)
	ES3 AOP is in a class of patterns that is not strictly
incompatible as ES3 code alone won't break, but ES3 code would no longer
behave as expected when interacting with ES4 code. AOP and other
patterns in ES3 rely on the ability to add or modify properties on any
object. Another example that should be noted is the O(n) algorithm for
duplicate item and cyclic reference detection. For example: 
	function findDuplicate(array){ 
	 var map={};
	 for (var i = 0; i < array.length; i++) {
	  if (typeof array[i] == 'object') {
	   if (array[i].__marker)
	    alert('found duplicate');
	   array[i].__marker = true;   
	  }
	  else {
	   if (map[array[i]])
	    alert('found duplicate');
	   map[array[i]] = true;
	  }
	 }
	}
	This algorithm will fail if an array of objects is passed in
that includes instances of non-dynamic (default for user created)
classes. Temporarily marking objects with dynamic properties is the only
way I am aware of to create O(n) algorithms in ES3 to detect duplicates
and cyclic references. 
	I don't think there is anything that can be done about this, it
is just a result of static classes. Code written for ES4 can use maps (I
think anyway) to solve this problem. This has probably already been
discussed, but I just wanted to make sure it was noted. 
	Kris

-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://mail.mozilla.org/pipermail/es-discuss/attachments/20071109/3ea8b208/attachment-0002.html",
    "header": Object {
      "date": 2007-11-09T18:00:31.000Z,
      "from": Object {
        "email": "lhansen@adobe.com",
        "name": "Lars Hansen",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=ES3%20quasi%20incompatibilities&In-Reply-To=a641e4910711090920r9e750c1l6df9738d2460933a%40mail.gmail.com",
      "subject": "ES3 quasi incompatibilities",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004920.html",
  },
  Object {
    "body": "On Nov 9, 2007, at 8:53 AM, zwetan wrote:

> but apparently we don't have access to the spec pages anymore (?).

The spec: section was badly out of date, hidden from view, then  
inadvertently exposed again (making for new confusion),  now hidden  
again. It's based too much on AS3 and not being updated, so better to  
let it alone.

/be",
    "header": Object {
      "date": 2007-11-09T18:15:05.000Z,
      "from": Object {
        "email": "brendan@mozilla.org",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Syntax%20for%20union%20types&In-Reply-To=122cc48a0711090853r1ae6def1xd57ef6ff88838a12%40mail.gmail.com",
      "subject": "Syntax for union types",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004921.html",
  },
  Object {
    "body": "As Lars suggested, we have bigger fish to fry, but we settled on  
union syntax quickly and were content to stay there. I'm not against  
| instead of , and if enough people think it's the right user  
interface, we could consider it again. I'm not saying it's a good use  
of time to fuss over this, but it's \\"fixable\\" if (T, U, ...) is not  
as good as (T | U | ...).

Recall that ES4 and indeed JavaScript do not have tuples, so we want  
to use [T, U] for the array structural type describing a tuple of at  
least index 0 of type T and index 1 of type U. If we ever did add  
tuples, then Yuh-Ruey has a point I think: we might rather use (T |  
U) for union of T and U, and (T, U) -- or possibly (T, U,) to match  
expression syntax (which would have to be (e1, e2,) to avoid  
ambiguity with comma expression) for tuple type.

/be",
    "header": Object {
      "date": 2007-11-09T18:21:50.000Z,
      "from": Object {
        "email": "brendan@mozilla.org",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Syntax%20for%20union%20types&In-Reply-To=473422FA.8090706%40gmail.com",
      "subject": "Syntax for union types",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004922.html",
  },
  Object {
    "body": "An HTML attachment was scrubbed...
URL: http://mail.mozilla.org/pipermail/es-discuss/attachments/20071109/d6b28d6e/attachment-0002.html",
    "header": Object {
      "date": 2007-11-09T19:53:16.000Z,
      "from": Object {
        "email": "marketing@fazendaesperanca.net",
        "name": "luciano",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=%2A%2A%2ASPAM%2A%2A%2A%20leilao%20boer%20baby%20canal%20do%20boi%20dia%2015-11-2007&In-Reply-To=",
      "subject": "***SPAM*** leilao boer baby canal do boi dia 15-11-2007",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004923.html",
  },
  Object {
    "body": "Lars Hansen wrote:
> > Not only is (int | string) more intuitive than (int, string), 
> > the (int, string) syntax can be reserved for another yet-unknown
> purpose.
>
> Intuition tends to be personal, and the other argument can be turned on
> its head (why wouldn't I want to use \\"int | string\\" for something else
> in the future?).  Since \\"|\\" is bitwise or, \\"||\\" would have been better,
> but that has yet other connotations.
>   

Well, I didn't draw that intuitiveness primarily from ES3 operators. It
comes from regexes (which are already in the langauge) and common
grammar notation (which are well-known to CS majors), which all tend to
use \\"|\\" as the \\"or\\" operator.

> > Along the same lines, I find the syntax for constraining list 
> > types to be unintuitive. [int] is very different from [int, 
> > string], and [int, string] is very different from (int, 
> > string). Perhaps that (int, string) can describe the tuple 
> > type. And [int | string] could be syntactic sugar for [(int | 
> > string)]. The usage of \\"|\\" improves readability in that 
> > there's no way to confuse a union type with a tuple type.
>
> This has been discussed at considerable length, and we've concluded that
> the current solution represents a workable compromise.
>   

A compromise between what? I'm not aware of any existing implementation
(besides the RI) that uses union types. I'm also unaware of any
published discussion concerning the syntax of union types (didn't find
any in the wiki).

> (More interesting open questions about the language are whether generic
> functions ought to be available on instances or discriminating on
> structural types, or whether packages ought to be sealable for security,
> or whether ES4 precludes the use of current ES3 AOP patterns and how
> that might be solved.  Among other things.)
>
> --lars
>   

By \\"generic functions ought to be available on instances\\", do you mean
non-global generic methods? TBH, I consider generic functions a bit of
an odd fuck in ES4, because of its many restrictions compared to normal
functions (see the \\"non-features, future directions, etc.\\" section on
the generic functions proposal).

-Yuh-Ruey Chen",
    "header": Object {
      "date": 2007-11-09T21:00:45.000Z,
      "from": Object {
        "email": "maian330@gmail.com",
        "name": "Yuh-Ruey Chen",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Syntax%20for%20union%20types&In-Reply-To=1421FCFA117AA044B447467FDE380715D471B3%40eurmail.eur.adobe.com",
      "subject": "Syntax for union types",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004924.html",
  },
  Object {
    "body": "Yuh-Ruey Chen wrote:
> By \\"generic functions ought to be available on instances\\", do you mean
> non-global generic methods? TBH, I consider generic functions a bit of
> an odd fuck in ES4, because of its many restrictions compared to normal
> functions (see the \\"non-features, future directions, etc.\\" section on
> the generic functions proposal).
>
> -Yuh-Ruey Chen
>   

odd duck *sigh*",
    "header": Object {
      "date": 2007-11-09T21:06:15.000Z,
      "from": Object {
        "email": "maian330@gmail.com",
        "name": "Yuh-Ruey Chen",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Syntax%20for%20union%20types&In-Reply-To=4734CA7D.40505%40gmail.com",
      "subject": "Syntax for union types",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004925.html",
  },
  Object {
    "body": "I've been experimenting with the ES4 RI lately. I've discovered that the
following doesn't work:

x = int;
10 is x;    // error
10 to x;   // error
10 cast x;   // error
var y: x;   // error

Of course, if I had used |type x = int|, it would work. Is this because
x is not a compile-time type? I find it a bit odd that |10 is x| didn't
work while |10 instanceof x| does work, considering that |is| is touted
as the successor to the |instanceof| operator. Or is |instanceof| the
run-time counterpart to |is|? Then should |instanceof| work on
everything that |is| can work on?

These distinctions between compile-time types and these run-time types
(e.g. x in the above example) are subtle and confusing. I figure that
all these distinctions will trip many ES4 newcomers coming from an ES3
background.

BTW, it doesn't seem like the \\"like\\" and \\"wrap\\" operators are
implemented in the RI yet, so I couldn't really test out structural types.

-Yuh-Ruey Chen",
    "header": Object {
      "date": 2007-11-09T21:58:48.000Z,
      "from": Object {
        "email": "maian330@gmail.com",
        "name": "Yuh-Ruey Chen",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=need%20some%20clarification%20on%20compile-time%20type%20vs.%20run-time%20type&In-Reply-To=",
      "subject": "need some clarification on compile-time type vs. run-time type",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004926.html",
  },
  Object {
    "body": "Yuh-Ruey Chen wrote:
> I've been experimenting with the ES4 RI lately. I've discovered that the
> following doesn't work:
> 
> x = int;
> 10 is x;    // error
> 10 to x;   // error
> 10 cast x;   // error
> var y: x;   // error
> 
> Of course, if I had used |type x = int|, it would work. Is this because
> x is not a compile-time type? 

Roughly. Some refinements to terminology: there are no \\"compile-time 
types\\" or \\"run-time types\\". There are types (and interfaces, and 
classes). They get bound to property names. Some of those properties are 
fixed, some are not. Some fixed properties are additionally constrained 
to hold types, classes or interfaces. Some are not.

Your example fails because x is not a fixed type-property. Properties 
introduced by 'type', 'class' or 'interface' are.

Type names in type expressions only consult fixed type-properties, 
because we want evaluation of type expressions to be as predictable as 
possible. There are only ever 2 results to evaluating any type expression:

   #1 full evaluation to a specific \\"ground\\" type term
   #2 suspended partial evaluation due to incomplete information

The flow of program control may affect which of these two results we 
get, and it can provide new information to restart a suspended 
evaluation -- by loading new code containing type definitions using 
'eval', for example -- but it *cannot* invalidate a result of an 
evaluation. Types never need to be \\"re-evaluated\\" to reflect \\"mutation\\" 
in their environment. The evaluation of type expressions can (and 
should) memoize types.

I find it a bit odd that |10 is x| didn't
> work while |10 instanceof x| does work, considering that |is| is touted
> as the successor to the |instanceof| operator. Or is |instanceof| the
> run-time counterpart to |is|? Then should |instanceof| work on
> everything that |is| can work on?

instanceof consults the prototype chain. It happens to be the case that 
for classes, the prototype chains are arranged to follow the class 
inheritance hierarchy. But there are a variety of differences; for 
example, \\"x instanceof z\\" may return false in cases where \\"x is z\\" 
returns true (if z is an interface, say).

> These distinctions between compile-time types and these run-time types
> (e.g. x in the above example) are subtle and confusing. I figure that
> all these distinctions will trip many ES4 newcomers coming from an ES3
> background.

Perhaps. It's not clear what else we ought to do; the alternatives we've 
explored sound worse. Any suggestions?

> BTW, it doesn't seem like the \\"like\\" and \\"wrap\\" operators are
> implemented in the RI yet, so I couldn't really test out structural types.

No, they are not implemented yet. The implementation of the type system 
is still somewhat shaky, unfortunately. I am working on it presently.

-Graydon",
    "header": Object {
      "date": 2007-11-09T23:20:41.000Z,
      "from": Object {
        "email": "graydon@mozilla.com",
        "name": "Graydon Hoare",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=need%20some%20clarification%20on%20compile-time%20type%20vs.%20run-time%20type&In-Reply-To=4734D818.2060106%40gmail.com",
      "subject": "need some clarification on compile-time type vs. run-time type",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004927.html",
  },
  Object {
    "body": "On Nov 9, 2007, at 3:20 PM, Graydon Hoare wrote:

> Types never need to be \\"re-evaluated\\" to reflect \\"mutation\\"
> in their environment. The evaluation of type expressions can (and
> should) memoize types.

And furthermore, merging type expressions and value expressions, as  
Yuh-Ruey seems to want, at the limit means an undecidable type  
system. We are not planning to approach anything like that. We want  
fixed type terms once open program units that reference them close.

/be",
    "header": Object {
      "date": 2007-11-09T23:43:34.000Z,
      "from": Object {
        "email": "brendan@mozilla.org",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=need%20some%20clarification%20on%20compile-time%20type%20vs.%20run-time%20type&In-Reply-To=4734EB49.7080808%40mozilla.com",
      "subject": "need some clarification on compile-time type vs. run-time type",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004928.html",
  },
  Object {
    "body": "Graydon Hoare wrote:
> Yuh-Ruey Chen wrote:
> > I've been experimenting with the ES4 RI lately. I've discovered that the
> > following doesn't work:
> > 
> > x = int;
> > 10 is x;    // error
> > 10 to x;   // error
> > 10 cast x;   // error
> > var y: x;   // error
> > 
> > Of course, if I had used |type x = int|, it would work. Is this because
> > x is not a compile-time type? 
>
> Roughly. Some refinements to terminology: there are no \\"compile-time 
> types\\" or \\"run-time types\\". There are types (and interfaces, and 
> classes). They get bound to property names. Some of those properties are 
> fixed, some are not. Some fixed properties are additionally constrained 
> to hold types, classes or interfaces. Some are not.
>
> Your example fails because x is not a fixed type-property. Properties 
> introduced by 'type', 'class' or 'interface' are.
>
> Type names in type expressions only consult fixed type-properties, 
> because we want evaluation of type expressions to be as predictable as 
> possible. There are only ever 2 results to evaluating any type expression:
>
>    #1 full evaluation to a specific \\"ground\\" type term
>    #2 suspended partial evaluation due to incomplete information
>
> The flow of program control may affect which of these two results we 
> get, and it can provide new information to restart a suspended 
> evaluation -- by loading new code containing type definitions using 
> 'eval', for example -- but it *cannot* invalidate a result of an 
> evaluation. Types never need to be \\"re-evaluated\\" to reflect \\"mutation\\" 
> in their environment. The evaluation of type expressions can (and 
> should) memoize types.
>   

Ah, so that's why I couldn't delete types. I ended up having to restart
the RI once the environment got cluttered with all these test types that
I defined. I need to get used to declaring them in scopes...

Speaking of which, there's a little bug in the RI: if you try to
constrain a property to specific type e.g. |var x: t| (is that the
proper terminology?) where t is undefined, then the interpreter
correctly reports an error, albeit one that didn't make sense until you
explained the \\"ground\\" type terminology. However, x remains constrained
to this undefined t, so attempts to redeclare x always result in an
error (even when trying to reconstrain it to the undefined t again),
e.g. |var x: int| results in an \\"incompatible redefinition of fixture
name\\" error. This bug probably doesn't matter in production, where such
errors are supposed to be fatal (I think), but in a REPL interpreter it
gets annoying.

> I find it a bit odd that |10 is x| didn't
> > work while |10 instanceof x| does work, considering that |is| is touted
> > as the successor to the |instanceof| operator. Or is |instanceof| the
> > run-time counterpart to |is|? Then should |instanceof| work on
> > everything that |is| can work on?
>
> instanceof consults the prototype chain. It happens to be the case that 
> for classes, the prototype chains are arranged to follow the class 
> inheritance hierarchy. But there are a variety of differences; for 
> example, \\"x instanceof z\\" may return false in cases where \\"x is z\\" 
> returns true (if z is an interface, say).
>   

Then how would we do a check against an interface bound in a non-fixed
property? Is there an expression that does the same thing as |is| except
for non-fixed type properties?

The confusion I'm getting is that there seems to be many ways to check
or differentiate between types. For example, consider the following ES3
function:

function foo(x, t) {
    if (!(x instanceof t))
        throw some_type_error;
    print(x);
}

If t were a fixed type property, then foo could be redefined as:

function foo.<t>(x) {
    if (!(x is t))
       throw some_type_error;
    print(x);
}

Or maybe the following is possible (it's currently disallowed in the RI):

function foo.<t>(x: t) {
    print(x);
}

Which one is preferred in ES4? The ES3 version is more flexible in a
way, since it treats types as first-class values, but the last version
is the most efficient. Users will have to deal with this choice, but it
requires a decent understanding of the type system to make a good choice.

And it doesn't end there. I haven't even addressed the |is like|
compound operator, of which there is no counterpart in |instanceof|
since structural types apparently can't be stored as non-fixed type
properties (|type x={a:int};y=x;| doesn't work in the RI).

> > These distinctions between compile-time types and these run-time types
> > (e.g. x in the above example) are subtle and confusing. I figure that
> > all these distinctions will trip many ES4 newcomers coming from an ES3
> > background.
>
> Perhaps. It's not clear what else we ought to do; the alternatives we've 
> explored sound worse. Any suggestions?
>   

I'm not sure how to phrase this, but it seems to me that ES4 is trying
to make fixed properties and non-fixed properties (and by extension,
type expressions and value expressions, and compile-time features and
run-time features) as similar and compatible as possible (e.g. |10 is
int| and |10 instanceof int|), yet there are evidently many cases where
they can't be interchanged (e.g. my first example). I know from
experience that the more similar concepts get, the higher the potential
for confusion, until they become the one and the same. And the two
concepts in question here cannot be one and the same if we want ES4 to
support efficient compilation. Perhaps, to reduce the confusion, the
differences between the two can be more pronounced, either through
syntax and/or behavior. I don't have any specific suggestions though.

At the very least, the differences and similarities need to be fully and
carefully documented. ES3 already has plenty of gotchas, and ES4 seems
to be introducing plenty more.

-Yuh-Ruey Chen",
    "header": Object {
      "date": 2007-11-10T01:29:47.000Z,
      "from": Object {
        "email": "maian330@gmail.com",
        "name": "Yuh-Ruey Chen",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=need%20some%20clarification%20on%20compile-time%20type%20vs.%20run-time%20type&In-Reply-To=4734EB49.7080808%40mozilla.com",
      "subject": "need some clarification on compile-time type vs. run-time type",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004929.html",
  },
  Object {
    "body": "On Nov 9, 2007, at 5:29 PM, Yuh-Ruey Chen wrote:

> The confusion I'm getting is that there seems to be many ways to check
> or differentiate between types. For example, consider the following  
> ES3
> function:
>
> function foo(x, t) {
>     if (!(x instanceof t))
>         throw some_type_error;
>     print(x);
> }
>
> If t were a fixed type property, then foo could be redefined as:
>
> function foo.<t>(x) {
>     if (!(x is t))
>        throw some_type_error;
>     print(x);
> }

Here t is the name of a type parameter to foo, so it is by definition  
fixed -- it doesn't matter how you instantiate foo.<T> for some T --  
but there again, in the foo.<T> expression, you need a fixed type  
term T.

> Or maybe the following is possible (it's currently disallowed in  
> the RI):
>
> function foo.<t>(x: t) {
>     print(x);
> }

I'll let Graydon reply in full, and give an update -- I heard he  
nearly has type params working.

> Which one is preferred in ES4? The ES3 version is more flexible in a
> way, since it treats types as first-class values,

A constructor function is not a type in ES1-3, it's a function  
object, which if user-defined has a completely writable prototype  
property that instanceof checks. So it is not bad (or good), but I'm  
here to say: it's not about types in the ES4 sense.

Indeed user-defined constructor functions all make Object instances,  
by definition, although you could strengthen them to make structural  
subtypes of Object in ES4:

function MyConstructor(a, b) {
     return {a: a, b: b} : {a: int, b: string};
}

> but the last version
> is the most efficient. Users will have to deal with this choice,  
> but it
> requires a decent understanding of the type system to make a good  
> choice.

Users can buy by the yard. The old ways work for the dynamic  
constructor/prototype world everyone knows.

Above you have made three different things. The instanceof check is  
not the same as the |is| check. The type paramter example is yet  
again different -- it's just printing x assuming x is compatible with  
t -- that is, that there's no type error on attempt to call foo.<T>,  
e.g. foo.<Date>(new RegExp).

> And it doesn't end there. I haven't even addressed the |is like|
> compound operator,

It's not a compound operator: 'like' is a type constructor or type  
unary operator if you prefer: like T is a type, you can use it  
freely. Thus because (x is T) can be tested, and T can be defined as  
like U, you can write (x is like U). Make sense?

> of which there is no counterpart in |instanceof|
> since structural types apparently can't be stored as non-fixed type
> properties (|type x={a:int};y=x;| doesn't work in the RI).

Type are types, not functions; the instanceof right operand is a  
*function* per ES1-3 and backward compatibility.

> I'm not sure how to phrase this, but it seems to me that ES4 is trying
> to make fixed properties and non-fixed properties (and by extension,
> type expressions and value expressions, and compile-time features and
> run-time features) as similar and compatible as possible (e.g. |10 is
> int| and |10 instanceof int|), yet there are evidently many cases  
> where
> they can't be interchanged (e.g. my first example).

I think you are mixing up fixed and non-fixed properties with types  
and functions.

> I know from
> experience that the more similar concepts get, the higher the  
> potential
> for confusion, until they become the one and the same. And the two
> concepts in question here cannot be one and the same if we want ES4 to
> support efficient compilation. Perhaps, to reduce the confusion, the
> differences between the two can be more pronounced, either through
> syntax and/or behavior. I don't have any specific suggestions though.

Here's what should work:

10 is int => true
10 instanceof int => true
type T = int
10 is T => true
10 instanceof T => true

No confusion, so far (IIRC the RI has a bug on the last line, but  
let's assume it is fixed). Now:

let U = int
10 instanceof U => true
10 is U => error

Using a const (or let const) does not help here, only type will do.

> At the very least, the differences and similarities need to be  
> fully and
> carefully documented. ES3 already has plenty of gotchas, and ES4 seems
> to be introducing plenty more.

It's true that ES4 is introducing optional types. But remember,  
they're optiona. You don't have to use them, but if you choose to,  
you need to follow the rules about using type definitions or  
equivalent (class, interface) to make bindings that are fixed typenames.

One escape hatch is to use reflection, which looks something like

{
     use namespace reflect
     print(typeOf(10).isSubtypeOf(U))
}

That's not working for me in the RI, and I may have misremembered a  
method name. Graydon knows best.

/be",
    "header": Object {
      "date": 2007-11-10T01:53:52.000Z,
      "from": Object {
        "email": "brendan@mozilla.org",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=need%20some%20clarification%20on%20compile-time%20type%20vs.%20run-time%20type&In-Reply-To=4735098B.7020803%40gmail.com",
      "subject": "need some clarification on compile-time type vs. run-time type",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004930.html",
  },
  Object {
    "body": "Brendan Eich wrote:
> On Nov 9, 2007, at 5:29 PM, Yuh-Ruey Chen wrote:
>
> > The confusion I'm getting is that there seems to be many ways to check
> > or differentiate between types. For example, consider the following  
> > ES3
> > function:
> >
> > function foo(x, t) {
> >     if (!(x instanceof t))
> >         throw some_type_error;
> >     print(x);
> > }
> >
> > If t were a fixed type property, then foo could be redefined as:
> >
> > function foo.<t>(x) {
> >     if (!(x is t))
> >        throw some_type_error;
> >     print(x);
> > }
>
> Here t is the name of a type parameter to foo, so it is by definition  
> fixed -- it doesn't matter how you instantiate foo.<T> for some T --  
> but there again, in the foo.<T> expression, you need a fixed type  
> term T.
>   

That's what I meant. If t could never be non-fixed, i.e. it's a type
alias, class name, or other type expr, then type parameters could be
used. But if, for example, t is a constructor or is otherwise computed
at runtime, it couldn't be used as a type argument.

> > Or maybe the following is possible (it's currently disallowed in  
> > the RI):
> >
> > function foo.<t>(x: t) {
> >     print(x);
> > }
>
> I'll let Graydon reply in full, and give an update -- I heard he  
> nearly has type params working.
>
> > Which one is preferred in ES4? The ES3 version is more flexible in a
> > way, since it treats types as first-class values,
>
> A constructor function is not a type in ES1-3, it's a function  
> object, which if user-defined has a completely writable prototype  
> property that instanceof checks. So it is not bad (or good), but I'm  
> here to say: it's not about types in the ES4 sense.
>
> Indeed user-defined constructor functions all make Object instances,  
> by definition, although you could strengthen them to make structural  
> subtypes of Object in ES4:
>
> function MyConstructor(a, b) {
>      return {a: a, b: b} : {a: int, b: string};
> }
>   

Ah, so expressions can be annotated with types? Didn't see that on the
wiki and it's not implemented in the RI yet.

> > but the last version
> > is the most efficient. Users will have to deal with this choice,  
> > but it
> > requires a decent understanding of the type system to make a good  
> > choice.
>
> Users can buy by the yard. The old ways work for the dynamic  
> constructor/prototype world everyone knows.
>
> Above you have made three different things. The instanceof check is  
> not the same as the |is| check. The type paramter example is yet  
> again different -- it's just printing x assuming x is compatible with  
> t -- that is, that there's no type error on attempt to call foo.<T>,  
> e.g. foo.<Date>(new RegExp).
>   

I acknowledged that |is| is different from |instanceof| but I was using
|instanceof| because it is similar to |is| yet works on value exprs. A
more proper example would be a combination of |instanceof| and all the
other checks that |is| allows via reflection.

What's the rationale behind not throwing a type error when calling
foo.<Date>(new RegExp)? I'm looking at the type_parameters page in the
wiki and I'm not seeing anything... It's odd that this would not throw
an exception while the following would:

function bar(x: int) { print(x); }
bar(\\"hi\\");

> > And it doesn't end there. I haven't even addressed the |is like|
> > compound operator,
>
> It's not a compound operator: 'like' is a type constructor or type  
> unary operator if you prefer: like T is a type, you can use it  
> freely. Thus because (x is T) can be tested, and T can be defined as  
> like U, you can write (x is like U). Make sense?
>   

Yes indeed, thanks.

> > of which there is no counterpart in |instanceof|
> > since structural types apparently can't be stored as non-fixed type
> > properties (|type x={a:int};y=x;| doesn't work in the RI).
>
> Type are types, not functions; the instanceof right operand is a  
> *function* per ES1-3 and backward compatibility.
>   

Again, I did not mean to use the strict definition of |instanceof|; I
meant some abstract operator (which |instanceof| could be \\"upgraded\\" to)
that does the same thing as |is| except that it works on value exprs.

The line between types and constructors is somewhat blurred by allowing
|instanceof| to work on class objects, which I would hardly consider
constructors, if not for the fact that they have an intrinsic::construct
method. Allowing |instanceof| to work on classes can trick people into
thinking that |instanceof| can work on type exprs. Yet at the same time,
since the ES3 builtin constructors are now classes, this feature is
required for backwards compatibility.

If |instanceof| works for classes, then I propose that |instanceof| also
work for interfaces for the sake of completeness. Getting this to work
is a bit trickier than for classes, since a class can implement multiple
interfaces or a parent class and multiple interfaces, but it can still
work. This change is perfectly backwards compatible, considering that
interfaces aren't even in ES3.

That just leaves the question of structural types, which, although I
would like |instanceof| to also work on for the sake of completeness,
doesn't seem worth the effort. As long as structural types are all
defined at compile-time, |is like| is all that's needed. Nevertheless,
it would be nice to have a runtime object representing a structural
type, that can then be passed to functions as a normal non-type
argument, and which can then be used somehow to check the type of an
object in a similar matter to |is like|. If structural types could be
created or mutated at runtime like constructors, then this would
obviously become a necessity.

> > I'm not sure how to phrase this, but it seems to me that ES4 is trying
> > to make fixed properties and non-fixed properties (and by extension,
> > type expressions and value expressions, and compile-time features and
> > run-time features) as similar and compatible as possible (e.g. |10 is
> > int| and |10 instanceof int|), yet there are evidently many cases  
> > where
> > they can't be interchanged (e.g. my first example).
>
> I think you are mixing up fixed and non-fixed properties with types  
> and functions.
>   

Probably :) This is all relatively new terminology to me. This is how I
currently understand it:

There are type expressions and value expressions. Type expressions are
adequately defined on the wiki. The identifiers in type expressions
refer to fixed properties. |class|, |interface|, and |type| statements
all define types and bind those types to fixed properties. |class| and
|interface| bind runtime class and interface objects, respectively, to
fixed properties. A value expression is the typical ES3 expression with
all the new ES4 syntax extensions, but it can include certain type
expressions in certain circumstances. Type expressions that refer to a
class (or parameterized class) resolve to the runtime class object (this
is why |let myint = int| isn't a syntax error). Ditto for interfaces.
Type exprs are used in |like|, |is|, |to|, |wrap|, and |cast|
expressions as the second operand (or the only operand in the case of
unary operators). Type expressions are also used as type annotations in
value expressions. All other cases of type expressions appearing in
value expressions are syntax errors.

Is that all correct?

> > I know from
> > experience that the more similar concepts get, the higher the  
> > potential
> > for confusion, until they become the one and the same. And the two
> > concepts in question here cannot be one and the same if we want ES4 to
> > support efficient compilation. Perhaps, to reduce the confusion, the
> > differences between the two can be more pronounced, either through
> > syntax and/or behavior. I don't have any specific suggestions though.
>
> Here's what should work:
>
> 10 is int => true
> 10 instanceof int => true
> type T = int
> 10 is T => true
> 10 instanceof T => true
>
> No confusion, so far (IIRC the RI has a bug on the last line, but  
> let's assume it is fixed). Now:
>
> let U = int
> 10 instanceof U => true
> 10 is U => error
>
> Using a const (or let const) does not help here, only type will do.
>
> > At the very least, the differences and similarities need to be  
> > fully and
> > carefully documented. ES3 already has plenty of gotchas, and ES4 seems
> > to be introducing plenty more.
>
> It's true that ES4 is introducing optional types. But remember,  
> they're optiona. You don't have to use them, but if you choose to,  
> you need to follow the rules about using type definitions or  
> equivalent (class, interface) to make bindings that are fixed typenames.
>   

Offtopic rant: TBH, all this talk of the new features being optional
detracts from other issues. Sure, saying a feature is optional is nice
for compatibility and all, but I think more effort should be spent
elaborating on how the new features mesh with the existing features in a
coherent matter. Any backwards-compatible feature is optional. It can be
useless or ugly, but hey it's optional. It reinforces the \\"everything
but kitchen sink\\" feel of ES4, which is not what you should want to
emphasis. With that said, I'm not saying the type system is inelegant -
in fact, I consider many aspects of it elegant or nifty - but you
shouldn't dismiss the number of extra gotchas with \\"hey it's optional\\".

> One escape hatch is to use reflection, which looks something like
>
> {
>      use namespace reflect
>      print(typeOf(10).isSubtypeOf(U))
> }
>
> That's not working for me in the RI, and I may have misremembered a  
> method name. Graydon knows best.
>
> /be
>   

I know that typeOf is defined in the intrinsic namespace.
intrinsic::isSubtypeOf doesn't seem to be implemented yet.

- Yuh-Ruey Chen",
    "header": Object {
      "date": 2007-11-10T07:24:40.000Z,
      "from": Object {
        "email": "maian330@gmail.com",
        "name": "Yuh-Ruey Chen",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=need%20some%20clarification%20on%20compile-time%20type%20vs.%20run-time%20type&In-Reply-To=1C65E707-206E-4C0D-9144-6DC3B93E3992%40mozilla.org",
      "subject": "need some clarification on compile-time type vs. run-time type",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004931.html",
  },
  Object {
    "body": "Hi All -

I just posted a quick screencast demonstrating how to get started with ECMAScript 4 (although, if you're already subscribed to this list, it's probably a good bet that this is well below your skill level). Feedback is appreciated.

http://ejohn.org/blog/playing-with-ecmascript-4/

--John",
    "header": Object {
      "date": 2007-11-10T07:33:13.000Z,
      "from": Object {
        "email": "jresig@mozilla.com",
        "name": "John Resig",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Playing%20with%20ECMAScript%204%20%28Screencast%29&In-Reply-To=",
      "subject": "Playing with ECMAScript 4 (Screencast)",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004932.html",
  },
  Object {
    "body": "Yuh-Ruey Chen wrote:

>>> I'm not sure how to phrase this, but it seems to me that ES4 is trying
>>> to make fixed properties and non-fixed properties (and by extension,
>>> type expressions and value expressions, and compile-time features and
>>> run-time features) as similar and compatible as possible (e.g. |10 is
>>> int| and |10 instanceof int|), yet there are evidently many cases  
>>> where
>>> they can't be interchanged (e.g. my first example).

I think you just said it very well. This is an excellent articulation of 
the problem you're perceiving.

> Probably :) This is all relatively new terminology to me. This is how I
> currently understand it:
> 
> There are type expressions and value expressions. Type expressions are
> adequately defined on the wiki. The identifiers in type expressions
> refer to fixed properties. |class|, |interface|, and |type| statements
> all define types and bind those types to fixed properties. |class| and
> |interface| bind runtime class and interface objects, respectively, to
> fixed properties. A value expression is the typical ES3 expression with
> all the new ES4 syntax extensions, but it can include certain type
> expressions in certain circumstances. Type expressions that refer to a
> class (or parameterized class) resolve to the runtime class object (this
> is why |let myint = int| isn't a syntax error). Ditto for interfaces.
> Type exprs are used in |like|, |is|, |to|, |wrap|, and |cast|
> expressions as the second operand (or the only operand in the case of
> unary operators). Type expressions are also used as type annotations in
> value expressions. All other cases of type expressions appearing in
> value expressions are syntax errors.
> 
> Is that all correct?

Yes.

It is worth keeping in mind that -- unfortunately! -- we must decide 
ahead of time whether we wish to make an operand a type expression or a 
value expression. Neither is a proper syntactic subset of the other, 
though an identifier can occur in each, as can the parameter-apply 
operator \\".<>\\".

So for example we have \\"<vexpr> is <texpr>\\", not \\"<vexpr> is <vexpr>\\". 
This might be the source of some misery, I'll grant. More curiously, in 
the value-expression context .<> takes value-expression arguments; 
whereas in the type-expression context .<> takes type-expression 
arguments. This too might tickle your sense of \\"too similar to be 
different\\".

One alternative is to mark type expression operands for these operators 
explicitly: define the \\"is\\" operator as taking two value expressions -- 
\\"<vexpr> is <vexpr>\\" -- and let users escape into type expressions using 
the \\"type\\" syntactic operator. In other words, let \\"x is T\\" be valid for 
non-type, non-fixed bindings of T -- though obviously, if T is not fixed 
in that context it will cause the type evaluator to suspend evaluation 
until the absolute last moment, always -- and require writing \\"x is type 
{p:int,q:int}\\" for more complicated structural type expressions. 
Currently we have it the other way, but we could change it.

> Offtopic rant: TBH, all this talk of the new features being optional
> detracts from other issues. Sure, saying a feature is optional is nice
> for compatibility and all, but I think more effort should be spent
> elaborating on how the new features mesh with the existing features in a
> coherent matter. 

Agreed. This is a very worthwhile discussion, I'm glad you've raised it. 
Let's keep wearing down any rough spots until it looks clean.

-Graydon",
    "header": Object {
      "date": 2007-11-10T07:43:36.000Z,
      "from": Object {
        "email": "graydon@mozilla.com",
        "name": "Graydon Hoare",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=need%20some%20clarification%20on%20compile-time%20type%20vs.%20run-time%20type&In-Reply-To=47355CB8.6040104%40gmail.com",
      "subject": "need some clarification on compile-time type vs. run-time type",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004933.html",
  },
  Object {
    "body": "Hi,

> I just posted a quick screencast demonstrating how to get started with ECMAScript 4 (although, if you're already subscribed to this list, it's probably a good bet that this is well below your skill level). Feedback is appreciated.
>
> http://ejohn.org/blog/playing-with-ecmascript-4/
>

I must say it's always good to have this kind of very low barrier to
entry demo and tutorial
so the greater public interested in JS could have a basic
understanding of what's going on

now I can say \\"go watch this video/slide/etc. and then you will
understand why I'm excited about ES4\\" :)

so thank you

cheers,
zwetan",
    "header": Object {
      "date": 2007-11-10T11:24:16.000Z,
      "from": Object {
        "email": "zwetan@gmail.com",
        "name": "zwetan",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Playing%20with%20ECMAScript%204%20%28Screencast%29&In-Reply-To=5735849.43571194679993707.JavaMail.root%40cm-mail02.mozilla.org",
      "subject": "Playing with ECMAScript 4 (Screencast)",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004934.html",
  },
  Object {
    "body": "{PharmaCanadaAll-1}
 {PharmaCanadaAll-1}

 {PharmaCanadaAll-2}

http://gladheart.cn

 Don't hesitate, you won't find better place to purchase meds.

Iain Galliart",
    "header": Object {
      "date": 2007-11-10T12:24:09.000Z,
      "from": Object {
        "email": "xgigai@borninteractive.com",
        "name": "Iain Galliart",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=%2A%2A%2ASPAM%2A%2A%2A%20Save%20on%20medications%20ordering%20them%20in%20Canada%21&In-Reply-To=",
      "subject": "***SPAM*** Save on medications ordering them in Canada!",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004935.html",
  },
  Object {
    "body": "On Nov 9, 2007, at 11:24 PM, Yuh-Ruey Chen wrote:

>> function MyConstructor(a, b) {
>>      return {a: a, b: b} : {a: int, b: string};
>> }
>>
>
> Ah, so expressions can be annotated with types?

Array and object initialisers can be annotated with array and object  
(\\"record\\") structural types to make the expressed object have fixed  
properties named by the type, instead of just being a plain old Array  
or Object instance that has ad-hoc (\\"expando\\") properties given by  
the initialiser, where the properties could be deleted in the very  
next statement.

> Didn't see that on the wiki

http://wiki.ecmascript.org/doku.php? 
id=proposals:structural_types_and_typing_of_initializers

> and it's not implemented in the RI yet.

It looks like it almost works, but for an easy-to-fix bug:

 >> let q = {p:42} : {p:int}
[stack] [init q()]
**ERROR** EvalError: typecheck failed, val=obj type={p: [ns public  
'__ES4__']::int } wanted={p: [ns public '__ES4__']::int } (near <no  
filename>:1:1-1.3)

The val and wanted parts of the diagnostic look the same to me.  
Should be fixed soon.

>> Above you have made three different things. The instanceof check is
>> not the same as the |is| check. The type paramter example is yet
>> again different -- it's just printing x assuming x is compatible with
>> t -- that is, that there's no type error on attempt to call foo.<T>,
>> e.g. foo.<Date>(new RegExp).
>>
>
> I acknowledged that |is| is different from |instanceof| but I was  
> using
> |instanceof| because it is similar to |is| yet works on value exprs. A
> more proper example would be a combination of |instanceof| and all the
> other checks that |is| allows via reflection.

Right. You can see from:

http://wiki.ecmascript.org/doku.php? 
id=proposals:syntax_for_type_expressions

and Graydon's reply that we originally had 'is' take a value  
expression right operand, and you had to use 'type E' (the unary type  
operator mentioned at the bottom of the above-linked page) to force E  
to be treated as a type expression. We've moved away from that to get  
experience with the alternative design, where 'is' takes a type  
expression on the right, in order to get earlier and more certain  
type checking. But this is all subject to change based on feedback --  
such as yours ;-).

> What's the rationale behind not throwing a type error when calling
> foo.<Date>(new RegExp)?

Sorry, I didn't say that, but what I wrote was confusing on second  
look. I was simply pointing out that there *will* be a type error,  
uncaught, which is not the same as an instanceof or 'is' boolean  
test: (new Date instanceof RegExp) => false, no exception thrown.

> Again, I did not mean to use the strict definition of |instanceof|; I
> meant some abstract operator (which |instanceof| could be  
> \\"upgraded\\" to)
> that does the same thing as |is| except that it works on value exprs.

It's not clear (to me at any rate) that you can upgrade instanceof in  
a backward-compatible fashion, given mutable prototype properties of  
functions.

For the built-ins (which become classes, not constructor functions),  
you could, and that's what we've done.

For user-defined functions that instanceof takes as right operands,  
there's no need to upgrade beyond how things work as in ES3. But the  
guarantees with classes are gone: if one changes F.prototype after x  
= new F, (x instanceof F) could change from true to false.

For structural types, we have not tried to upgrade instanceof, mostly  
because we didn't want to change instanceof much, but also because  
structural types look like value expressions syntactically. More below.

> Allowing |instanceof| to work on classes can trick people into
> thinking that |instanceof| can work on type exprs.

It might, you're right. On the other hand, we can't keep treating  
Object or Array as a constructor function, whose name in the global  
object can be re-bound. That is not even consistent in ES3. See

http://wiki.ecmascript.org/doku.php?id=clarification:which_prototype

> Yet at the same time,
> since the ES3 builtin constructors are now classes, this feature is
> required for backwards compatibility.

Indeed, and that still seems like the best way forward. But you could  
be right that we have not upgraded instanceof enough.

> If |instanceof| works for classes, then I propose that |instanceof|  
> also
> work for interfaces for the sake of completeness. Getting this to work
> is a bit trickier than for classes, since a class can implement  
> multiple
> interfaces or a parent class and multiple interfaces, but it can still
> work. This change is perfectly backwards compatible, considering that
> interfaces aren't even in ES3.

It would involve some algorithm other than the prototype chain walk  
from x, looking for an object === to y.prototype, for (x instanceof  
y), since interfaces do not have prototypes.

But since (x is I) and (x is J) work fine for x = new C where class C  
implements I, J {...}, perhaps for interface types we could just make  
instanceof do what 'is' does. Comments?

> That just leaves the question of structural types, which, although I
> would like |instanceof| to also work on for the sake of completeness,
> doesn't seem worth the effort. As long as structural types are all
> defined at compile-time, |is like| is all that's needed.

Or even just 'is' -- you don't need 'is like' if you want a type  
check that demands fixtures matching the structural type's fields.  
The benefit of 'is' composed with 'like' is when you want a one-time  
check or assertion, and your code does not need to worry about  
mutation violating the type a split-second later. From the overview:

function fringe(tree) {
     if (tree is like {left:*, right:*}) {
         for (let leaf in fringe(tree.left))
             yield leaf
         for (let leaf in fringe(tree.right))
             yield leaf
     }
     else
         yield tree
}

let tree = { left: { left: 37, right: 42 }, right: \\"foo\\" }
for ( let x in fringe(tree) )
     print(x)


> Nevertheless,
> it would be nice to have a runtime object representing a structural
> type, that can then be passed to functions as a normal non-type
> argument, and which can then be used somehow to check the type of an
> object in a similar matter to |is like|. If structural types could be
> created or mutated at runtime like constructors, then this would
> obviously become a necessity.

Agreed. We have not reflected structural types as values because  
there's a syntactic ambiguity for array and record types:

   x instanceof {p:int}
   x instanceof [int]

per ES3 11.8.6, which depends on the [[HasInstance]] internal method  
(8.6.2), requires throwing a TypeError here (assume int is bound in  
the scope chain). This is because, for the first example, {p: int} is  
an object initialiser, not a reflection of a record type, and objects  
other than functions do not have a [[HasInstance]] internal method.

But let's say, per ES3 chapter 16, we extend ES4 so that it allows  
what would in ES3 be an error if control flow reached either of the  
above lines for any x (given a binding for int). We've done an  
analoguos extension for the new operator (see the overview, the  
section labeled \\"Record and array types\\"). ES4 could say \\"Aha, that  
looks like an object or array initialiser, but I know it is a  
structural type expression!\\" and \\"upgrade\\" (x instanceof {p:int}) to  
(x is {p:int}).

Is this worth it? It seemed not to anyone working on this in TG1. We  
left instanceof alone, but by giving classes prototype objects and  
making the standard \\"class constructors\\" (Object, Date, etc.) be true  
classes, we kept backward compatibility.

Note that making the standard ES3 constructors be classes, we can  
explain the otherwise ad-hoc difference in ES1-3 between f.prototype  
for a function f (this property is DontDelete) and C.prototype for a  
built-in constructor function C (where the property is DontDelete,  
ReadOnly, and DontEnum).

You're right that evolving a language while keeping compatibility  
makes for more combinations that might want to work together, in some  
upgraded sense, than if one \\"minimizes\\" and leaves the old form  
(instanceof) alone, but handles the new combinations as well as the  
old ones in the new form (is). This is a tricky issue, which we've  
been keenly aware of, but we don't always attend to perfectly --  
thanks for keeping after us on it.

> There are type expressions and value expressions. Type expressions are
> adequately defined on the wiki. The identifiers in type expressions
> refer to fixed properties. |class|, |interface|, and |type| statements
> all define types and bind those types to fixed properties.

Right.

> |class| and
> |interface| bind runtime class and interface objects, respectively, to
> fixed properties.

Without getting into runtime vs. compile-time, the above seems better  
to me if you strike \\"runtime\\" from before \\"class and interface objects\\".

Another way of looking at types, if you do distinguish compile-time  
and runtime, is that types exist as compile-time values *and* runtime  
values. Usually the latter are just called \\"values\\", but I agree with  
Lars, who has argued that values exist at compile time too, and  
\\"value\\" is the right word for both, appropriately qualified. Unlike  
some values which can't be known at compile-time, a type is always a  
compile-time value and a runtime value.

If you buy this, then the sentence cited above could say \\"bind  
compile-time class and interface types, which appear at runtime as  
objects, to fixed properties.\\" Or something like that ;-).

Since ES4 does not require an implementation to support strict mode,  
and since we are trying to avoid requiring analyses that would need a  
full abstract syntax tree or anything more complicated (control flow  
graph, SSA) to be built for whole functions, we intentionally want to  
support the first point of view, that there is no compile- vs.  
runtime distinction.

ES1-3 support this point of view, in the practical sense that its  
chapter 16 talks about SyntaxError being throwable early (but does  
not mandate this, i.e., does not mandate compile-time error  
checking). ES1-3 intentionally allow that implementations may  
interpret something close to source code, modulo transformations of  
for and for-in loops, and a few other places that reorder code. There  
are two passes required to fulfill the obligations of ES3 chapter 10,  
e.g., defining function-valued properties first based on the parsed  
function definitions in a program or function body -- but this is not  
compile-time in the type-checking sense that is optional in ES4.

Obviously we are not done proving that ES4 requires no compile-time  
analyses beyond ES3, but that's our intention. If you see problems in  
the RI or anywhere else, please do feel free to point them out.

> A value expression is the typical ES3 expression with
> all the new ES4 syntax extensions, but it can include certain type
> expressions in certain circumstances. Type expressions that refer to a
> class (or parameterized class) resolve to the runtime class object  
> (this
> is why |let myint = int| isn't a syntax error). Ditto for interfaces.
> Type exprs are used in |like|, |is|, |to|, |wrap|, and |cast|
> expressions as the second operand (or the only operand in the case of
> unary operators). Type expressions are also used as type  
> annotations in
> value expressions. All other cases of type expressions appearing in
> value expressions are syntax errors.
>
> Is that all correct?

The unary 'type' operator is there too (I think -- the wiki page  
cited above is old and the RI is not handling this operator correctly  
at the moment), but otherwise I think that's correct.

>>> At the very least, the differences and similarities need to be
>>> fully and
>>> carefully documented. ES3 already has plenty of gotchas, and ES4  
>>> seems
>>> to be introducing plenty more.
>>
>> It's true that ES4 is introducing optional types. But remember,
>> they're optional. You don't have to use them, but if you choose to,
>> you need to follow the rules about using type definitions or
>> equivalent (class, interface) to make bindings that are fixed  
>> typenames.
>>
>
> Offtopic rant: TBH, all this talk of the new features being optional
> detracts from other issues.

Fair enough, but it wasn't \\"all this talk\\", it was just one paragraph  
in my big fat reply :-). My point was that optionality allows for non- 
orthogonality, and backward compatibility may in fact tie our hands  
and prevent, e.g., instanceof \\"upgrades\\".

> Sure, saying a feature is optional is nice
> for compatibility and all, but I think more effort should be spent
> elaborating on how the new features mesh with the existing features  
> in a
> coherent matter. Any backwards-compatible feature is optional. It  
> can be
> useless or ugly, but hey it's optional. It reinforces the \\"everything
> but kitchen sink\\" feel of ES4, which is not what you should want to
> emphasis. With that said, I'm not saying the type system is  
> inelegant -
> in fact, I consider many aspects of it elegant or nifty - but you
> shouldn't dismiss the number of extra gotchas with \\"hey it's  
> optional\\".

You're right, and I don't mean to dismiss anything -- more the  
opposite. The \\"gotchas\\" in ES3 may become less grabby, or even go  
away, if we make the right additions to ES4.

Exposing underlying \\"magic\\" in the built-ins, I think, and letting  
programmers use those powers, is one example. In ES3 there's no way  
to make a constructor function whose prototype property is ReadOnly  
and DontEnum, e.g. Or even simpler: there is no way to turn on the  
DontEnum attribute for a property. ES4 adds optional ways to do these  
things (classes, the new second arg to propertyIsEnumerable). These  
make ES4, by some counts, have fewer gotchas.

But back to type vs. value expressions, which I agree is a new  
gotcha. But we're not done, and es4-discuss is a huge help in  
finishing well. So let's keep corresponding.

My belief is that merging type and value expressions is right out --  
we've accepted solid proposals for structural types, and they mimic  
the syntax for the related value expressions (functions,  
initialisers). This leaves us with a grammatical divide between types  
and values, but special forms such as annotations only take type  
expressions. So as you point out, the operators such as 'is' and  
'instanceof' seem to be where worlds collide visibly.

So questions I see include:

* Should we \\"upgrade\\" instanceof to work like 'is' when given an  
interface or structural type as its right operand?

* Should we allow value expressions on the right of 'is'? We've  
decided not to already, most recently in September. But it seems to  
me you are asking for this too.

Let me know if I'm missing anything. Thanks,

/be",
    "header": Object {
      "date": 2007-11-10T18:41:28.000Z,
      "from": Object {
        "email": "brendan@mozilla.org",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=need%20some%20clarification%20on%20compile-time%20type%20vs.%20run-time%20type&In-Reply-To=47355CB8.6040104%40gmail.com",
      "subject": "need some clarification on compile-time type vs. run-time type",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004936.html",
  },
  Object {
    "body": "Brendan Eich wrote:

>  >> let q = {p:42} : {p:int}
> [stack] [init q()]
> **ERROR** EvalError: typecheck failed, val=obj type={p: [ns public 
> '__ES4__']::int } wanted={p: [ns public '__ES4__']::int } (near <no 
> filename>:1:1-1.3)
> 
> The val and wanted parts of the diagnostic look the same to me. Should 
> be fixed soon.

Fixed earlier this week on the trunk. Sorry it's not in the public build 
at the moment. My hope is that we can get rolling snapshot builds off 
the trunk happening at some point soon.

-Graydon",
    "header": Object {
      "date": 2007-11-10T20:04:53.000Z,
      "from": Object {
        "email": "graydon@mozilla.com",
        "name": "Graydon Hoare",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=need%20some%20clarification%20on%20compile-time%20type%20vs.%20run-time%20type&In-Reply-To=2DEC70B4-9BD7-4B90-BDBF-94ADFB3A06BB%40mozilla.org",
      "subject": "need some clarification on compile-time type vs. run-time type",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004937.html",
  },
  Object {
    "body": "+1 for |

On 2007-11-09, at 13:21 EST, Brendan Eich wrote:

> As Lars suggested, we have bigger fish to fry, but we settled on
> union syntax quickly and were content to stay there. I'm not against
> | instead of , and if enough people think it's the right user
> interface, we could consider it again. I'm not saying it's a good use
> of time to fuss over this, but it's \\"fixable\\" if (T, U, ...) is not
> as good as (T | U | ...).
>
> Recall that ES4 and indeed JavaScript do not have tuples, so we want
> to use [T, U] for the array structural type describing a tuple of at
> least index 0 of type T and index 1 of type U. If we ever did add
> tuples, then Yuh-Ruey has a point I think: we might rather use (T |
> U) for union of T and U, and (T, U) -- or possibly (T, U,) to match
> expression syntax (which would have to be (e1, e2,) to avoid
> ambiguity with comma expression) for tuple type.
>
> /be",
    "header": Object {
      "date": 2007-11-10T21:02:33.000Z,
      "from": Object {
        "email": "ptw@pobox.com",
        "name": "P T Withington",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Syntax%20for%20union%20types&In-Reply-To=340FD05F-256A-4C7B-B1C5-5C0B62A656C7%40mozilla.org",
      "subject": "Syntax for union types",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004938.html",
  },
  Object {
    "body": "Thanks. I filed:

http://bugs.ecmascript.org/ticket/300

asking for this change. As I wrote there, this kind of fine-tuning of  
syntax (the UI to the language) should not be cut off by the new  
proposals cutoff, any more than fiddling over JSON APIs should be cut  
off or frozen prematurely. So I'll advocate for this change in the  
group.

/be

On Nov 10, 2007, at 1:02 PM, P T Withington wrote:

> +1 for |
>
> On 2007-11-09, at 13:21 EST, Brendan Eich wrote:
>
>> As Lars suggested, we have bigger fish to fry, but we settled on
>> union syntax quickly and were content to stay there. I'm not against
>> | instead of , and if enough people think it's the right user
>> interface, we could consider it again. I'm not saying it's a good use
>> of time to fuss over this, but it's \\"fixable\\" if (T, U, ...) is not
>> as good as (T | U | ...).
>>
>> Recall that ES4 and indeed JavaScript do not have tuples, so we want
>> to use [T, U] for the array structural type describing a tuple of at
>> least index 0 of type T and index 1 of type U. If we ever did add
>> tuples, then Yuh-Ruey has a point I think: we might rather use (T |
>> U) for union of T and U, and (T, U) -- or possibly (T, U,) to match
>> expression syntax (which would have to be (e1, e2,) to avoid
>> ambiguity with comma expression) for tuple type.
>>
>> /be
> _______________________________________________
> Es4-discuss mailing list
> Es4-discuss at mozilla.org
> https://mail.mozilla.org/listinfo/es4-discuss",
    "header": Object {
      "date": 2007-11-10T23:04:30.000Z,
      "from": Object {
        "email": "brendan@mozilla.org",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Syntax%20for%20union%20types&In-Reply-To=2B24369E-4931-4CAA-B812-62BE5DDB8C2C%40pobox.com",
      "subject": "Syntax for union types",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004939.html",
  },
  Object {
    "body": "I know it's too late for a proposal, but I keep wanting a couple of
things for AOP stuff.

One is a newApply

Creational = {
getByNode : function(el){
	if(!this.hasOwnProperty(\\"instances\\")) this.instances = {};
	return this.instances.hasOwnProperty(el.id) && this.instances[el.id] ||
	(this.instances[el.id] = this.new.apply(arguments)); // <-- Fictitious syntax.
}
}

function Widget(el, dir){

}

Wiget.getByNode = Creational.getByNode; // Borrow the getByNode method

So that way, I can have a Widget based on a node, yet still pass
varargs to the constructor.

Garrett

-- 
Programming is a collaborative art.",
    "header": Object {
      "date": 2007-11-11T01:17:58.000Z,
      "from": Object {
        "email": "dhtmlkitchen@gmail.com",
        "name": "Garrett Smith",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=.newApply%28%29%20%3F&In-Reply-To=",
      "subject": ".newApply() ?",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004940.html",
  },
  Object {
    "body": "On Nov 10, 2007, at 5:17 PM, Garrett Smith wrote:

> I know it's too late for a proposal, but I keep wanting a couple of
> things for AOP stuff.
>
> One is a newApply
>
> Creational = {
> getByNode : function(el){
> 	if(!this.hasOwnProperty(\\"instances\\")) this.instances = {};
> 	return this.instances.hasOwnProperty(el.id) && this.instances 
> [el.id] ||
> 	(this.instances[el.id] = this.new.apply(arguments)); // <--  
> Fictitious syntax.
> }
> }
>
> function Widget(el, dir){
>
> }
>
> Wiget.getByNode = Creational.getByNode; // Borrow the getByNode method
>
> So that way, I can have a Widget based on a node, yet still pass
> varargs to the constructor.

Got your back here ;-). Narcissus (http://lxr.mozilla.org/mozilla/ 
source/js/narcissus/) wants this too, and it's going to end up  
falling out of the reflection APIs:

     reflect::typeOf(this).reflect::construct(arguments)

or of course:

   { use namespace reflect;
      . . . typeOf(this).constructo(arguments) }

in your example. The http://wiki.ecmascript.org/doku.php? 
id=proposals:meta_objects proposal is out of date, it uses iterators  
for the type and value parameters, but IIRC we have agreement to  
satisfy your use-case. See http://bugs.ecmascript.org/ticket/232.

/be",
    "header": Object {
      "date": 2007-11-11T01:34:04.000Z,
      "from": Object {
        "email": "brendan@mozilla.org",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=.newApply%28%29%20%3F&In-Reply-To=c9e12660711101717j6d79eb91kc4b05ab0ec9e7dd%40mail.gmail.com",
      "subject": ".newApply() ?",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004941.html",
  },
  Object {
    "body": "An HTML attachment was scrubbed...
URL: http://mail.mozilla.org/pipermail/es-discuss/attachments/20071110/27df7a1d/attachment-0002.html",
    "header": Object {
      "date": 2007-11-11T03:19:24.000Z,
      "from": Object {
        "email": "mob@mbedthis.com",
        "name": "Michael O'Brien",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=need%20some%20clarification%20on%20compile-time%20type%20vs.%20run-time%20type&In-Reply-To=1C65E707-206E-4C0D-9144-6DC3B93E3992%40mozilla.org",
      "subject": "need some clarification on compile-time type vs. run-time type",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004942.html",
  },
  Object {
    "body": "See http://bugs.ecmascript.org/ticket/248 -- the meta objects proposal:

http://wiki.ecmascript.org/doku.php?id=proposals:meta_objects

used intrinsic, but as #248 notes, there are good reasons for putting  
the meta-objects functions and types in their own namespace:

     * intrinsic should mean \\"early bindable, generally useful\\"
     * meta is reserved for hooks (and that seems like a good thing)
     * iterator is used for all the iteration stuff
     * uint32ops is used for uint operators
     * reflect is a good name for reflection
     * partitioning the methods means that we can have reflection  
methods on various kinds of objects without worrying about name  
clashes (e.g., reflect::construct could in principle be a method on a  
class object, so class objects could implement ClassType directly --  
this is possible at present, but if so precludes adding an  
instrinsic::construct method to the class object for other purposes  
in the future)

The last point is significant.

/be

On Nov 10, 2007, at 7:19 PM, Michael O'Brien wrote:

> Brendan,
>
> I didn't see the reflect namespace documented in the overview.
>
> Can you please provide some pointers to its doc?
>
> Michael
>
> Brendan Eich wrote:
>> On Nov 9, 2007, at 5:29 PM, Yuh-Ruey Chen wrote:
>>
>>
>>> The confusion I'm getting is that there seems to be many ways to  
>>> check
>>> or differentiate between types. For example, consider the following
>>> ES3
>>> function:
>>>
>>> function foo(x, t) {
>>>     if (!(x instanceof t))
>>>         throw some_type_error;
>>>     print(x);
>>> }
>>>
>>> If t were a fixed type property, then foo could be redefined as:
>>>
>>> function foo.(x) {
>>>     if (!(x is t))
>>>        throw some_type_error;
>>>     print(x);
>>> }
>>>
>> Here t is the name of a type parameter to foo, so it is by definition
>> fixed -- it doesn't matter how you instantiate foo. for some T --
>> but there again, in the foo. expression, you need a fixed type
>> term T.
>>
>>
>>> Or maybe the following is possible (it's currently disallowed in
>>> the RI):
>>>
>>> function foo.(x: t) {
>>>     print(x);
>>> }
>>>
>> I'll let Graydon reply in full, and give an update -- I heard he
>> nearly has type params working.
>>
>>
>>> Which one is preferred in ES4? The ES3 version is more flexible in a
>>> way, since it treats types as first-class values,
>>>
>> A constructor function is not a type in ES1-3, it's a function
>> object, which if user-defined has a completely writable prototype
>> property that instanceof checks. So it is not bad (or good), but I'm
>> here to say: it's not about types in the ES4 sense.
>>
>> Indeed user-defined constructor functions all make Object instances,
>> by definition, although you could strengthen them to make structural
>> subtypes of Object in ES4:
>>
>> function MyConstructor(a, b) {
>>      return {a: a, b: b} : {a: int, b: string};
>> }
>>
>>
>>> but the last version
>>> is the most efficient. Users will have to deal with this choice,
>>> but it
>>> requires a decent understanding of the type system to make a good
>>> choice.
>>>
>> Users can buy by the yard. The old ways work for the dynamic
>> constructor/prototype world everyone knows.
>>
>> Above you have made three different things. The instanceof check is
>> not the same as the |is| check. The type paramter example is yet
>> again different -- it's just printing x assuming x is compatible with
>> t -- that is, that there's no type error on attempt to call foo.,
>> e.g. foo.(new RegExp).
>>
>>
>>> And it doesn't end there. I haven't even addressed the |is like|
>>> compound operator,
>>>
>> It's not a compound operator: 'like' is a type constructor or type
>> unary operator if you prefer: like T is a type, you can use it
>> freely. Thus because (x is T) can be tested, and T can be defined as
>> like U, you can write (x is like U). Make sense?
>>
>>
>>> of which there is no counterpart in |instanceof|
>>> since structural types apparently can't be stored as non-fixed type
>>> properties (|type x={a:int};y=x;| doesn't work in the RI).
>>>
>> Type are types, not functions; the instanceof right operand is a
>> *function* per ES1-3 and backward compatibility.
>>
>>
>>> I'm not sure how to phrase this, but it seems to me that ES4 is  
>>> trying
>>> to make fixed properties and non-fixed properties (and by extension,
>>> type expressions and value expressions, and compile-time features  
>>> and
>>> run-time features) as similar and compatible as possible (e.g. | 
>>> 10 is
>>> int| and |10 instanceof int|), yet there are evidently many cases
>>> where
>>> they can't be interchanged (e.g. my first example).
>>>
>> I think you are mixing up fixed and non-fixed properties with types
>> and functions.
>>
>>
>>> I know from
>>> experience that the more similar concepts get, the higher the
>>> potential
>>> for confusion, until they become the one and the same. And the two
>>> concepts in question here cannot be one and the same if we want  
>>> ES4 to
>>> support efficient compilation. Perhaps, to reduce the confusion, the
>>> differences between the two can be more pronounced, either through
>>> syntax and/or behavior. I don't have any specific suggestions  
>>> though.
>>>
>> Here's what should work:
>>
>> 10 is int => true
>> 10 instanceof int => true
>> type T = int
>> 10 is T => true
>> 10 instanceof T => true
>>
>> No confusion, so far (IIRC the RI has a bug on the last line, but
>> let's assume it is fixed). Now:
>>
>> let U = int
>> 10 instanceof U => true
>> 10 is U => error
>>
>> Using a const (or let const) does not help here, only type will do.
>>
>>
>>> At the very least, the differences and similarities need to be
>>> fully and
>>> carefully documented. ES3 already has plenty of gotchas, and ES4  
>>> seems
>>> to be introducing plenty more.
>>>
>> It's true that ES4 is introducing optional types. But remember,
>> they're optiona. You don't have to use them, but if you choose to,
>> you need to follow the rules about using type definitions or
>> equivalent (class, interface) to make bindings that are fixed  
>> typenames.
>>
>> One escape hatch is to use reflection, which looks something like
>>
>> {
>>      use namespace reflect
>>      print(typeOf(10).isSubtypeOf(U))
>> }
>>
>> That's not working for me in the RI, and I may have misremembered a
>> method name. Graydon knows best.
>>
>> /be
>>
>> _______________________________________________
>> Es4-discuss mailing list
>> Es4-discuss at mozilla.org
>> https://mail.mozilla.org/listinfo/es4-discuss
>>
>>
> _______________________________________________
> Es4-discuss mailing list
> Es4-discuss at mozilla.org
> https://mail.mozilla.org/listinfo/es4-discuss

-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://mail.mozilla.org/pipermail/es-discuss/attachments/20071110/310a33da/attachment-0002.html",
    "header": Object {
      "date": 2007-11-11T03:27:56.000Z,
      "from": Object {
        "email": "brendan@mozilla.org",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=need%20some%20clarification%20on%20compile-time%20type%20vs.%20run-time%20type&In-Reply-To=473674BC.4090509%40mbedthis.com",
      "subject": "need some clarification on compile-time type vs. run-time type",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004943.html",
  },
  Object {
    "body": "Hi all,

I've been reading the overview doc on the ES4 proposal. From it,
and from the threads that I've been reading, I'm confused about
the design constraints on the ES4 process. Are the following
statements all accurate:

* We want ES4 to work well on small devices, so size of implementation
  is a concern.
* Therefore, we'd rather require only one language *implementation*
  rather than two.
* The ES4 proposal includes new keywords.
* To prevent these new keywords breaking ES3 compatibility, these
  keywords are only recognized when a version attribute on the script
  tag says the script is in ES4.
* This attribute does create two languages in effect, but not two
  language implementations, and therefore does not violate the size
  constraint.
* The intersection of ES3 and ES4 must be approximately as pleasant a
  programming language as ES3 currently is.

If all this makes sense, does the following follow:

* The ES4 language (as recognized with the version attribute) and the
  ES3 language must be able to smoothly share an implementation.
* Whenever the goals of ES4 can be achieved by removing unneeded
  features from ES3 (e.g. \\"with\\"), rather than adding features, the shared
  implementation can smaller, and therefore even better for small
  devices.

Does this make sense so far? Am I missing something?

-- 
Text by me above is hereby placed in the public domain

    Cheers,
    --MarkM",
    "header": Object {
      "date": 2007-11-11T04:00:11.000Z,
      "from": Object {
        "email": "erights@gmail.com",
        "name": "Mark Miller",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=I%27m%20confused%20about%20the%20design%20constraints%20on%20ES4&In-Reply-To=",
      "subject": "I'm confused about the design constraints on ES4",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004944.html",
  },
  Object {
    "body": "Brendan Eich wrote:
> On Nov 9, 2007, at 11:24 PM, Yuh-Ruey Chen wrote:
> > Ah, so expressions can be annotated with types?
>
> Array and object initialisers can be annotated with array and object  
> (\\"record\\") structural types to make the expressed object have fixed  
> properties named by the type, instead of just being a plain old Array  
> or Object instance that has ad-hoc (\\"expando\\") properties given by  
> the initialiser, where the properties could be deleted in the very  
> next statement.
>   

I see. I wonder if this can somehow be extended so that it works on
non-structural types as well. For example, to initialize a Map, you
could use {a: 0, b: 1, c: 2} : Map, instead of Map({a:0, b:1, c:2}).
Perhaps it would map onto the |meta static function invoke| method. The
downside of this syntax sugar though, is that it hides the cost of the
creation of the object literal, fooling the user into thinking that the
Map is directly initialized from the literal.

> > I acknowledged that |is| is different from |instanceof| but I was  
> > using
> > |instanceof| because it is similar to |is| yet works on value exprs. A
> > more proper example would be a combination of |instanceof| and all the
> > other checks that |is| allows via reflection.
>
> Right. You can see from:
>
> http://wiki.ecmascript.org/doku.php? 
> id=proposals:syntax_for_type_expressions
>
> and Graydon's reply that we originally had 'is' take a value  
> expression right operand, and you had to use 'type E' (the unary type  
> operator mentioned at the bottom of the above-linked page) to force E  
> to be treated as a type expression. We've moved away from that to get  
> experience with the alternative design, where 'is' takes a type  
> expression on the right, in order to get earlier and more certain  
> type checking. But this is all subject to change based on feedback --  
> such as yours ;-).
>   

I like this revised syntax: |a is type b| is much clearer than |a is b|,
which a newbie can mistake for object equality, especially if he comes
from a Python background. On purely aesthetic grounds though (ignoring
the type vs. value expr distinction), I think |isa| would be even
better, but on the other hand, |isa like| sounds like something Mario
would say.

Can you elaborate on the \\"earlier and more certain type checking\\"? I
thought you said for |is| checks (along with |instanceof| checks) there
can be no early type errors, so that leaves |is| to be a purely runtime
check.

Anyway, we still have a similar confusion to what we had with
|instanceof|, except this time it's all in |is|:

// assume |b| is a class and |a| is an instance of it
a is type b
a is b

Since both work, this can fool the user into thinking that the |type|
operator is optional. Furthermore, the latter can still lead to newbie
confusion (thinking that the expr is equivalent to |a == b|). So I'm not
sure there is a net win.

> > Again, I did not mean to use the strict definition of |instanceof|; I
> > meant some abstract operator (which |instanceof| could be  
> > \\"upgraded\\" to)
> > that does the same thing as |is| except that it works on value exprs.
>
> It's not clear (to me at any rate) that you can upgrade instanceof in  
> a backward-compatible fashion, given mutable prototype properties of  
> functions.
>
> For the built-ins (which become classes, not constructor functions),  
> you could, and that's what we've done.
>
> For user-defined functions that instanceof takes as right operands,  
> there's no need to upgrade beyond how things work as in ES3. But the  
> guarantees with classes are gone: if one changes F.prototype after x  
> = new F, (x instanceof F) could change from true to false.
>   

Well, I was just suggesting adding additional functionality to
|instanceof|, not changing the original behavior of it, so I'm not sure
where the compatibility issue is coming into play.

> > If |instanceof| works for classes, then I propose that |instanceof|  
> > also
> > work for interfaces for the sake of completeness. Getting this to work
> > is a bit trickier than for classes, since a class can implement  
> > multiple
> > interfaces or a parent class and multiple interfaces, but it can still
> > work. This change is perfectly backwards compatible, considering that
> > interfaces aren't even in ES3.
>
> It would involve some algorithm other than the prototype chain walk  
> from x, looking for an object === to y.prototype, for (x instanceof  
> y), since interfaces do not have prototypes.
>
> But since (x is I) and (x is J) work fine for x = new C where class C  
> implements I, J {...}, perhaps for interface types we could just make  
> instanceof do what 'is' does. Comments?
>   

That works for me.

> > Nevertheless,
> > it would be nice to have a runtime object representing a structural
> > type, that can then be passed to functions as a normal non-type
> > argument, and which can then be used somehow to check the type of an
> > object in a similar matter to |is like|. If structural types could be
> > created or mutated at runtime like constructors, then this would
> > obviously become a necessity.
>
> Agreed. We have not reflected structural types as values because  
> there's a syntactic ambiguity for array and record types:
>
>    x instanceof {p:int}
>    x instanceof [int]
>
> per ES3 11.8.6, which depends on the [[HasInstance]] internal method  
> (8.6.2), requires throwing a TypeError here (assume int is bound in  
> the scope chain). This is because, for the first example, {p: int} is  
> an object initialiser, not a reflection of a record type, and objects  
> other than functions do not have a [[HasInstance]] internal method.
>
> But let's say, per ES3 chapter 16, we extend ES4 so that it allows  
> what would in ES3 be an error if control flow reached either of the  
> above lines for any x (given a binding for int). We've done an  
> analoguos extension for the new operator (see the overview, the  
> section labeled \\"Record and array types\\"). ES4 could say \\"Aha, that  
> looks like an object or array initialiser, but I know it is a  
> structural type expression!\\" and \\"upgrade\\" (x instanceof {p:int}) to  
> (x is {p:int}).
>
> Is this worth it? It seemed not to anyone working on this in TG1. We  
> left instanceof alone, but by giving classes prototype objects and  
> making the standard \\"class constructors\\" (Object, Date, etc.) be true  
> classes, we kept backward compatibility.
>   

How about |obj instanceof type {a: int}|?

This makes me wonder: what exactly does |type x| in a value expr resolve
to? If it \\"resolves to a type\\", that what does that exactly mean? For
type expr nested within a value expr, that implies to me that it
resolves to a runtime representation of that type. And that implies that
every type must have a runtime representation, including structural
types, e.g. |type {a: int}| would resolve to some runtime representation
of the structural type defined by |{a: int}|.

But from what I've heard and read up to now, |type x| isn't as generic
as I'm implying above, so I'm confused.

In any case, one advantage of having a runtime representation for every
type is that structural types can now be more easily used in a ES3-style
without the usage of type parameters and also allow type bindings to be
computed at runtime, e.g.

function foo(x, t) {
    if (!(x instanceof t))
       throw some_type_error;
    print(x);
}
...
let t;
if (cond)   // note how t can only be determined at runtime here
    t = type {a: int};
else
    t = type like {a: double};
...
foo(obj, t);

> You're right that evolving a language while keeping compatibility  
> makes for more combinations that might want to work together, in some  
> upgraded sense, than if one \\"minimizes\\" and leaves the old form  
> (instanceof) alone, but handles the new combinations as well as the  
> old ones in the new form (is). This is a tricky issue, which we've  
> been keenly aware of, but we don't always attend to perfectly --  
> thanks for keeping after us on it.
>   

No problem :)

> > |class| and
> > |interface| bind runtime class and interface objects, respectively, to
> > fixed properties.
>
> Without getting into runtime vs. compile-time, the above seems better  
> to me if you strike \\"runtime\\" from before \\"class and interface objects\\".
>
> Another way of looking at types, if you do distinguish compile-time  
> and runtime, is that types exist as compile-time values *and* runtime  
> values. Usually the latter are just called \\"values\\", but I agree with  
> Lars, who has argued that values exist at compile time too, and  
> \\"value\\" is the right word for both, appropriately qualified. Unlike  
> some values which can't be known at compile-time, a type is always a  
> compile-time value and a runtime value.
>
> If you buy this, then the sentence cited above could say \\"bind  
> compile-time class and interface types, which appear at runtime as  
> objects, to fixed properties.\\" Or something like that ;-).
>
> Since ES4 does not require an implementation to support strict mode,  
> and since we are trying to avoid requiring analyses that would need a  
> full abstract syntax tree or anything more complicated (control flow  
> graph, SSA) to be built for whole functions, we intentionally want to  
> support the first point of view, that there is no compile- vs.  
> runtime distinction.
>
> ES1-3 support this point of view, in the practical sense that its  
> chapter 16 talks about SyntaxError being throwable early (but does  
> not mandate this, i.e., does not mandate compile-time error  
> checking). ES1-3 intentionally allow that implementations may  
> interpret something close to source code, modulo transformations of  
> for and for-in loops, and a few other places that reorder code. There  
> are two passes required to fulfill the obligations of ES3 chapter 10,  
> e.g., defining function-valued properties first based on the parsed  
> function definitions in a program or function body -- but this is not  
> compile-time in the type-checking sense that is optional in ES4.
>
> Obviously we are not done proving that ES4 requires no compile-time  
> analyses beyond ES3, but that's our intention. If you see problems in  
> the RI or anywhere else, please do feel free to point them out.
>   

Alright, that makes sense. I'll stick with the terminology \\"early type
checking\\" in the future to avoid all this semantic confusion.

> You're right, and I don't mean to dismiss anything -- more the  
> opposite. The \\"gotchas\\" in ES3 may become less grabby, or even go  
> away, if we make the right additions to ES4.
>
> Exposing underlying \\"magic\\" in the built-ins, I think, and letting  
> programmers use those powers, is one example. In ES3 there's no way  
> to make a constructor function whose prototype property is ReadOnly  
> and DontEnum, e.g. Or even simpler: there is no way to turn on the  
> DontEnum attribute for a property. ES4 adds optional ways to do these  
> things (classes, the new second arg to propertyIsEnumerable). These  
> make ES4, by some counts, have fewer gotchas.
>   

You're right, ES4 does fix some gotchas in ES3.

> But back to type vs. value expressions, which I agree is a new  
> gotcha. But we're not done, and es4-discuss is a huge help in  
> finishing well. So let's keep corresponding.
>
> My belief is that merging type and value expressions is right out --  
> we've accepted solid proposals for structural types, and they mimic  
> the syntax for the related value expressions (functions,  
> initialisers). This leaves us with a grammatical divide between types  
> and values, but special forms such as annotations only take type  
> expressions. So as you point out, the operators such as 'is' and  
> 'instanceof' seem to be where worlds collide visibly.
>
> So questions I see include:
>
> * Should we \\"upgrade\\" instanceof to work like 'is' when given an  
> interface or structural type as its right operand?
>
> * Should we allow value expressions on the right of 'is'? We've  
> decided not to already, most recently in September. But it seems to  
> me you are asking for this too.
>
> Let me know if I'm missing anything. Thanks,
>
> /be
>   

I'm going to try to order my thoughts by listing the possible type
testing functionalities and how they map to operators.

(a) object ISA class or interface (O(1), early test)
(b) object's class is a superset of a structural type (O(1), early test)
(c) object is compatible with a structural type (O(n) where n=# props in
structural type, late test)
(d) object's prototype chain includes the prototype of another object
(O(n) where n=length of chain, late test)
(e) object ISA x, where x is determined at runtime to be a class or
interface (O(1), late test)
(f) object's class is a superset of x, where x is determined at runtime
to be a structural type (O(1), late test)
(g) object is compatible with x, where x is determined at runtime to be
a structural type (same as (c))

|is| does (a), (b)
|is like| does (c)
|instanceof| does (d)
|instanceof| does (e) for classes
nothing does (e) for interfaces
nothing does (f) and (g) since there's no \\"runtime structural type\\"

The asymptotic times don't really matter - only whether the test can be
performed early does. If something can be tested early, that implies
that it has to be a type expr. Late testing implies value exprs.
However, although |is| seems to be capable of doing early testing, if no
type exceptions are thrown early for |is|, then it is in effect a purely
runtime check, right?

Furthermore, the syntax of type exprs and value exprs are incompatible
(neither can be subset of each other) because of the following issues
(AFAIK):
1) structural type syntax of type expr collides with object and array
literal syntax of value expr
2) union type syntax collides with comma expr syntax of value expr (e.g.
|(1,2)|)
3) type parameter syntax of type expr collides with type argument syntax
of value expr

I've been scratching my head for a good proposal that coherently
distinguishes |is| and |instanceof| and the associated syntax, but I've
restarted several times already with no solution. Now I've begun to
wonder why the two operators can't be unified in some way, considering
that both are runtime checks. If every type had a runtime representation
then this could work (see example I gave above for structural types).

-Yuh-Ruey Chen",
    "header": Object {
      "date": 2007-11-11T05:03:47.000Z,
      "from": Object {
        "email": "maian330@gmail.com",
        "name": "Yuh-Ruey Chen",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=need%20some%20clarification%20on%20compile-time%20type%20vs.%20run-time%20type&In-Reply-To=2DEC70B4-9BD7-4B90-BDBF-94ADFB3A06BB%40mozilla.org",
      "subject": "need some clarification on compile-time type vs. run-time type",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/001513.html",
  },
  Object {
    "body": "On Nov 10, 2007, at 8:00 PM, Mark Miller wrote:

> * To prevent these new keywords breaking ES3 compatibility, these
>   keywords are only recognized when a version attribute on the script
>   tag says the script is in ES4.

This has happened before, FYI -- from ES1-3 under various vendor  
experimental MIME types or script language attribute values -- and it  
continued after ES3 with (at least) JS1.6 and 1.7 (application/ 
javascript;version=1.7).

> * This attribute does create two languages in effect, but not two
>   language implementations, and therefore does not violate the size
>   constraint.

Writing \\"this attribute does create two languages in effect\\" seems to  
conflate compatible successive versions with one a subset of the  
other, and two completely separate programming languages. I'm not  
sure what it means, so it's hard to tell what its significance is in  
the bulleted list. I'm probably missing something obvious -- little  
help?

> * The intersection of ES3 and ES4 must be approximately as pleasant a
>   programming language as ES3 currently is.

No, the intersection is \\"ES3 + reality\\" + two (known) true  
incompatibilities. \\"ES3 + reality\\" means the ES3 spec was not  
followed (for variously better and worse reasons) and the de-jure  
standard needs to be adjusted based on what browsers actually do that  
web developers actually count on.

\\"ES3 + reality\\" does not mean every last JScript bug, of course,  
especially since many have not been emulated by other browsers'  
implementations. It does not mean over-specifying what should remain  
implementation-dependent (e.g., Date.parse as implemented in various  
browsers). It does mean some case-by-case greater specification where  
browsers differ in ways that hurt interoperation.

> If all this makes sense, does the following follow:
>
> * The ES4 language (as recognized with the version attribute) and the
>   ES3 language must be able to smoothly share an implementation.

Yes.

> * Whenever the goals of ES4 can be achieved by removing unneeded
>   features from ES3 (e.g. \\"with\\"), rather than adding features, the  
> shared
>   implementation can smaller, and therefore even better for small
>   devices.

This does not follow if the goals of ES4 include backward  
compatibility (they do), since the web depends all over the place on  
\\"with\\". So the (common) implementation must support ES3 \\"with\\", and  
adding runtime versioning to make \\"with\\" an error in ES4 just adds  
code (a tiny amount for the version check) and makes migration harder  
(more important that the miniscule version check overhead). See also  
reformed with.

> Does this make sense so far? Am I missing something?

You wrote about design constraints, but also talked about goals of  
ES4 without listing them. The two are not the same. Many design  
constraints are imposed by backward compatibility with existing web  
content. Goals such as optional static type checking and programming  
in the large support on the other hand transcend compatibility  
concerns by allowing migration away from old forms toward new ones.  
There are no guarantees, but the best way to move the web is to  
provide better forms and short (low-cost) migration paths to those  
forms, in addition to deprecating the worse forms.

I expect \\"with\\" will be with us forever, BTW. My apologies to all!

If backward compatibility requires \\"with\\", and the new version does  
not remove old forms even when you opt into it explicitly, then the  
footprint is minimized. Since removing \\"with\\" is a non-starter given  
the compatibility constraint, there's no gain in code size by adding  
code to remove \\"with\\" when the new version is selected -- and there's  
no gain in migration costs, since \\"with\\" costs are long-ago sunk and  
not trivial to unsink. Bad sunk costs, i.e. bugs due to \\"with\\"  
ambiguities, could be unearthed, but the existence of these  
hypothetical bugs in quantity enough to offset the unsinking costs  
need to be demonstrated.

Backward compatibility is not simple or static -- it is fuzzy and it  
changes as the web changes. There's hope, but the time scales are  
long and you can't force change by removing things from browsers. You  
have to see competitors take the plunge, and even then you must face  
down the rear guard (e.g., removing gopher from Firefox).

Hope this helps,

/be
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://mail.mozilla.org/pipermail/es-discuss/attachments/20071110/f6d4636b/attachment-0002.html",
    "header": Object {
      "date": 2007-11-11T05:10:39.000Z,
      "from": Object {
        "email": "brendan@mozilla.org",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=I%27m%20confused%20about%20the%20design%20constraints%20on%20ES4&In-Reply-To=fee0a56d0711102000y2acdd9ebm4aa65caf48377329%40mail.gmail.com",
      "subject": "I'm confused about the design constraints on ES4",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004945.html",
  },
  Object {
    "body": "On Nov 10, 2007 9:10 PM, Brendan Eich <brendan at mozilla.org> wrote:
> On Nov 10, 2007, at 8:00 PM, Mark Miller wrote:

[out of order]
>> * The intersection of ES3 and ES4 must be approximately as pleasant a
>>   programming language as ES3 currently is.
>
> No, the intersection is \\"ES3 + reality\\" + two (known) true
> incompatibilities. \\"ES3 + reality\\" means the ES3 spec was not followed (for
> variously better and worse reasons) and the de-jure standard needs to be
> adjusted based on what browsers actually do that web developers actually
> count on.
>
> \\"ES3 + reality\\" does not mean every last JScript bug, of course, especially
> since many have not been emulated by other browsers' implementations. It
> does not mean over-specifying what should remain implementation-dependent
> (e.g., Date.parse as implemented in various browsers). It does mean some
> case-by-case greater specification where browsers differ in ways that hurt
> interoperation.

Yes, I appreciate the point about reality. And well put!

I will use \\"ES3R\\" below to mean \\"ES3 + reality\\".


>> * To prevent these new keywords breaking ES3 compatibility, these
>>   keywords are only recognized when a version attribute on the script
>>   tag says the script is in ES4.
>
> This has happened before, FYI -- from ES1-3 under various vendor
> experimental MIME types or script language attribute values -- and it
> continued after ES3 with (at least) JS1.6 and 1.7
> (application/javascript;version=1.7).

Yes, good. Specifically the overview doc states:

# The mechanism that supplies the dialect information will depend on the
# environment.  In a web browser the information comes from the MIME
type of the
# script or from a version parameter on the SCRIPT tag in the document.14  New
# web pages that choose to use ES4 will have to specify the dialect.

It seems we are agreeing on what this text means so far.


>> * This attribute does create two languages in effect, but not two
>>   language implementations, and therefore does not violate the size
>>   constraint.
>
> Writing \\"this attribute does create two languages in effect\\" seems to
> conflate compatible successive versions with one a subset of the other, and
> two completely separate programming languages. I'm not sure what it means,
> so it's hard to tell what its significance is in the bulleted list. I'm
> probably missing something obvious -- little help?

I'm simply observing that the version switch explained above changes
what language is being recognized. With the switch off (or set to ES3
or ES3R), the new keywords aren't recognized as keywords. With the
switch set to ES4, the new keywords are recognized as keywords. What I
don't understand is: Why can't this switch change other aspects of the
language being recognized, so long as this doesn't result in a larger
implementation? For *example*, if one of the purposes of ES4 can be
served by removing a keyword such as \\"with\\", can we consider having
this same switch (set to ES4) remove it?

I'm using \\"with\\" here only as an example, to try to understand the
nature of the compatibility constraints on the ES4 process.

>> * The ES4 language (as recognized with the version attribute) and the
>>   ES3 language must be able to smoothly share an implementation.
>
> Yes.

Good.


>> * Whenever the goals of ES4 can be achieved by removing unneeded
>>   features from ES3 (e.g. \\"with\\"), rather than adding features, the shared
>>   implementation can smaller, and therefore even better for small
>>   devices.
>
> This does not follow if the goals of ES4 include backward compatibility
> (they do), since the web depends all over the place on \\"with\\". So the
> (common) implementation must support ES3 \\"with\\", and adding runtime
> versioning to make \\"with\\" an error in ES4 just adds code (a tiny amount for
> the version check) and makes migration harder (more important that the
> miniscule version check overhead). See also reformed with.

Let's say, hypothetically, that by removing \\"with\\" from ES4 (with the
version switch) we could avoid adding something else to ES4. Let's say
that the feature we could avoid adding is larger than the code needed
to switch \\"with\\" on and off. Would the removal of \\"with\\" from ES4 then
be an option? If not, what compatibility issue does it raise that
isn't raised by the addition of the other keywords?


>> Does this make sense so far? Am I missing something?
>
> You wrote about design constraints, but also talked about goals of ES4
> without listing them. The two are not the same. [...]

Indeed. That's exactly why I didn't list them. I want to understand
the design constraints first before making proposals regarding goals.


> Backward compatibility is not simple or static -- it is fuzzy and it changes
> as the web changes. There's hope, but the time scales are long and you can't
> force change by removing things from browsers. You have to see competitors
> take the plunge, and even then you must face down the rear guard (e.g.,
> removing gopher from Firefox).

Also well put.

-- 
Text by me above is hereby placed in the public domain

    Cheers,
    --MarkM",
    "header": Object {
      "date": 2007-11-11T05:52:07.000Z,
      "from": Object {
        "email": "erights@gmail.com",
        "name": "Mark Miller",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=I%27m%20confused%20about%20the%20design%20constraints%20on%20ES4&In-Reply-To=6C22D067-1D2B-4516-AE57-58BB2D5204F2%40mozilla.org",
      "subject": "I'm confused about the design constraints on ES4",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004946.html",
  },
  Object {
    "body": "On Nov 10, 2007, at 9:03 PM, Yuh-Ruey Chen wrote:

> I see. I wonder if this can somehow be extended so that it works on
> non-structural types as well. For example, to initialize a Map, you
> could use {a: 0, b: 1, c: 2} : Map, instead of Map({a:0, b:1, c:2}).
> Perhaps it would map onto the |meta static function invoke| method.  
> The
> downside of this syntax sugar though, is that it hides the cost of the
> creation of the object literal, fooling the user into thinking that  
> the
> Map is directly initialized from the literal.

Yeah, it doesn't seem good judging by both hidden costs and redundant  
features. Map has a constructor function and a meta static function  
invoke -- which does exactly what you wonder about above:

         meta static function invoke(x : Object!) {
             let d = new Map.<EnumerableId,V>;
             for ( let n in x )
                 if (x.hasOwnProperty(n))
                     d.put(n, x[n]);
             return d;
         }

This means writing

     let map: Map.<string, *> = {word1: val1, ... wordN: valN};

does exactly what everyone wants from a \\"Dictionary\\" (see the old  
threads on this list under that name). Bonus implementation points  
for optimizing away the object initialiser's Object instance, but not  
a worry to over-specify.

> Can you elaborate on the \\"earlier and more certain type checking\\"? I
> thought you said for |is| checks (along with |instanceof| checks)  
> there
> can be no early type errors, so that leaves |is| to be a purely  
> runtime
> check.

There are questions about exactly what strict mode analyses might be  
mandated as normative if an implementation supports strict mode. This  
may be clearer to Graydon and Cormac than to me, so I'd welcome their  
comments. For example:

     function g(a_not_null: T!) ...

     function f(a: T) {
         if (a !== null)
             g(a);           // no cast required?
     }

Now consider changing the condition from (a !== null) to (a is T!).  
Should strict mode allow the above, generating a runtime check for  
null when g is called? Should it require (a cast T!)? Should it  
figure things out with fancier analysis (this example is trivial, but  
it is of the same kind as much harder-to-analyze ones). We have said  
\\"cast required\\" before, but the question came up again recently.

> Anyway, we still have a similar confusion to what we had with
> |instanceof|, except this time it's all in |is|:
>
> // assume |b| is a class and |a| is an instance of it
> a is type b
> a is b
>
> Since both work, this can fool the user into thinking that the |type|
> operator is optional. Furthermore, the latter can still lead to newbie
> confusion (thinking that the expr is equivalent to |a == b|). So  
> I'm not
> sure there is a net win.

I think we should separate the Python n00b concern that 'is' might be  
taken for ===. That is not a big potential problem in my view; JS is  
not Python, even with things like generators (we don't have  
GeneratorExit, names differ for the iteration protocol hooks, etc.)  
in the mix. You have to be *this* tall; you have to pay attention to  
the basics. False cognates in different parts of Europe can cause  
embarrassment or even legal troubles ;-).

The two-edged nature of the type/value expression split means, as you  
say, someone's naive expectation that there is only one expression  
grammar in the language will be shattered, some of the time. This is  
the problem to fix, or mitigate as best we can.

>> For user-defined functions that instanceof takes as right operands,
>> there's no need to upgrade beyond how things work as in ES3. But the
>> guarantees with classes are gone: if one changes F.prototype after x
>> = new F, (x instanceof F) could change from true to false.
>>
>
> Well, I was just suggesting adding additional functionality to
> |instanceof|, not changing the original behavior of it, so I'm not  
> sure
> where the compatibility issue is coming into play.

Yes, you're upgrading it, but now it makes stronger guarantees for  
the upgrade-case inputs than for the old ones. That seems problematic.

>> But since (x is I) and (x is J) work fine for x = new C where class C
>> implements I, J {...}, perhaps for interface types we could just make
>> instanceof do what 'is' does. Comments?
>
> That works for me.

Besides changing the guarantees, it mixes domains: prototype chain  
and (possibly mutable) function.prototype vs. class/interface  
supertype vs. structural supertype.

> How about |obj instanceof type {a: int}|?

Sure, that follows, but it's unnecessary for backward compatibility  
as I noted. It might be good for clarity, until everyone learned it  
and got tired of typing it too much ;-).

> This makes me wonder: what exactly does |type x| in a value expr  
> resolve
> to? If it \\"resolves to a type\\", that what does that exactly mean?

The RI alas has this in eval.sml:

and evalTypeExpr (regs:Mach.REGS)
                  (te:Ast.TYPE_EXPR)
     : Mach.VAL =
     case te of
         Ast.SpecialType st => Mach.Null (* FIXME *)
       | Ast.UnionType ut => Mach.Null (* FIXME *)
       | Ast.ArrayType at => Mach.Null (* FIXME *)
       | Ast.TypeName tn => evalExpr regs (Ast.LexicalRef { ident=tn,  
loc=NONE })
       | Ast.FunctionType ft => Mach.Null (* FIXME *)
       | Ast.ObjectType ot => Mach.Null (* FIXME *)
       | Ast.NullableType { expr, nullable } => Mach.Null (* FIXME *)
       | Ast.InstanceType { ty, ... } => Mach.Null (* FIXME *)

but I believe the intention is to evaluate to the appropriate type  
meta-object.

> For
> type expr nested within a value expr, that implies to me that it
> resolves to a runtime representation of that type.

Right -- type meta-objects are discussed here:

http://wiki.ecmascript.org/doku.php?id=proposals:meta_object

See also:

http://bugs.ecmascript.org/ticket/248

> And that implies that
> every type must have a runtime representation, including structural
> types, e.g. |type {a: int}| would resolve to some runtime  
> representation
> of the structural type defined by |{a: int}|.

Indeed :-).

> But from what I've heard and read up to now, |type x| isn't as generic
> as I'm implying above, so I'm confused.

If I understand your point, it's that if we allow

   (a is T)

given a type name T bound by a type, class, or interface definition;  
but we disallow

   let (t = T) (a is t)

and insist on

   let (t = T) (a is type t)

where (type t) evaluates at runtime to the meta-object for T and then  
'is' proceeds to test whether a's dynamic type is a subtype of T,  
then what good does our restriction on 'is' (that its right operand  
must be a type fixture) actually *do*?

If I'm following myself, then all I can say is: I hear you! I'm with  
you.

> In any case, one advantage of having a runtime representation for  
> every
> type is that structural types can now be more easily used in a ES3- 
> style
> without the usage of type parameters and also allow type bindings  
> to be
> computed at runtime, e.g.
>
> function foo(x, t) {
>     if (!(x instanceof t))
>        throw some_type_error;
>     print(x);
> }
> ...
> let t;
> if (cond)   // note how t can only be determined at runtime here
>     t = type {a: int};
> else
>     t = type like {a: double};
> ...
> foo(obj, t);

We went down this road before including type parameters, hoping to  
avoid them while saving decidability. Yes, you can write code like  
the above, but it is not the same when foo uses t in a type  
annotation (say x:t in the parameter list). There, t has to be a  
distinguished type parameter, so the checker can see instantiations  
and make sure they pass fixed types too. There's also alpha renaming  
to consider: type params should not collide unhygienically.

> You're right, ES4 does fix some gotchas in ES3.

I certainly hope so -- I'll dance a jig at the end of the day if this  
is clear to everyone.

> I'm going to try to order my thoughts by listing the possible type
> testing functionalities and how they map to operators.
>
> (a) object ISA class or interface (O(1), early test)
> (b) object's class is a superset of a structural type (O(1), early  
> test)
> (c) object is compatible with a structural type (O(n) where n=#  
> props in
> structural type, late test)
> (d) object's prototype chain includes the prototype of another object
> (O(n) where n=length of chain, late test)
> (e) object ISA x, where x is determined at runtime to be a class or
> interface (O(1), late test)
> (f) object's class is a superset of x, where x is determined at  
> runtime
> to be a structural type (O(1), late test)
> (g) object is compatible with x, where x is determined at runtime  
> to be
> a structural type (same as (c))
>
> |is| does (a), (b)

Right.

> |is like| does (c)

Nit: your definition for (c) is not using \\"compatible with structural  
type\\" the way we define the type compatibility relation (written \\"~:\\"  
instead of \\"<:\\", see http://wiki.ecmascript.org/doku.php? 
id=spec:type_relations). We want soundness by some definition, so (a  
is T) must mean that a cannot mutate a split-second later to violate  
T. But let's say your item (b) covers that.

> |instanceof| does (d)
> |instanceof| does (e) for classes
> nothing does (e) for interfaces

The meta-object stuff can be used:

   use namespace reflect
   typeOf(object).isSubtypeOf(iface)

or something like that.

> nothing does (f) and (g) since there's no \\"runtime structural type\\"

No, meta-objects again.

> The asymptotic times don't really matter - only whether the test  
> can be
> performed early does. If something can be tested early, that implies
> that it has to be a type expr. Late testing implies value exprs.
> However, although |is| seems to be capable of doing early testing,  
> if no
> type exceptions are thrown early for |is|, then it is in effect a  
> purely
> runtime check, right?

Yes, modulo strict mode analyses TBD (see above).

> Furthermore, the syntax of type exprs and value exprs are incompatible
> (neither can be subset of each other) because of the following issues
> (AFAIK):
> 1) structural type syntax of type expr collides with object and array
> literal syntax of value expr
> 2) union type syntax collides with comma expr syntax of value expr  
> (e.g.
> |(1,2)|)
> 3) type parameter syntax of type expr collides with type argument  
> syntax
> of value expr

You've got it.

> I've been scratching my head for a good proposal that coherently
> distinguishes |is| and |instanceof| and the associated syntax, but  
> I've
> restarted several times already with no solution. Now I've begun to
> wonder why the two operators can't be unified in some way, considering
> that both are runtime checks. If every type had a runtime  
> representation
> then this could work (see example I gave above for structural types).

The issues are (AFAIK):

* Should instanceof do its loosey-goosey ES3 thing for functions,  
which have mutable .prototype, and mix this backward-compatible  
feature into different-in-many-ways subtype tests done by 'is'-as- 
proposed?

* Should 'is' insist on fixed type name in its right operand, or is  
this inconsistent and pointless, an RI bug even?

I'm going to summon Graydon and stand back now.

/be",
    "header": Object {
      "date": 2007-11-11T05:57:36.000Z,
      "from": Object {
        "email": "brendan@mozilla.org",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=need%20some%20clarification%20on%20compile-time%20type%20vs.%20run-time%20type&In-Reply-To=47368D33.2000207%40gmail.com",
      "subject": "need some clarification on compile-time type vs. run-time type",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004947.html",
  },
  Object {
    "body": "On Nov 10, 2007, at 9:52 PM, Mark Miller wrote:

> What I
> don't understand is: Why can't this switch change other aspects of the
> language being recognized, so long as this doesn't result in a larger
> implementation?

It could. We considered removing \\"with\\" from ES4. But as I noted,  
migration costs (on order of unsinking sunk \\"with\\" costs, whether  
good or bad -- sunk cost fallacy acknowledged!) loomed. Same thinking  
about eval, but we do want to make it better under strict mode, and  
possibly even under explicit version=4. So we could revisit \\"with\\"  
too. Thanks for pointing this out.

> I'm using \\"with\\" here only as an example, to try to understand the
> nature of the compatibility constraints on the ES4 process.

Compatibility imposes footprint costs, but it also creates a  
migration tax proportional to usage, roughly. We're trying not to  
blow either footprint budget or migration budget. These are fuzzy,  
hard to quantify and reason about; nice judgment is required.

> Let's say, hypothetically, that by removing \\"with\\" from ES4 (with the
> version switch) we could avoid adding something else to ES4. Let's say
> that the feature we could avoid adding is larger than the code needed
> to switch \\"with\\" on and off. Would the removal of \\"with\\" from ES4 then
> be an option? If not, what compatibility issue does it raise that
> isn't raised by the addition of the other keywords?

We went through this in considering reformed with. The reformed with  
proposal is small in parser overhead, but we haven't evaluated  
practical implementations' code costs for the runtime semantics  
(ignore strict mode; any implementation supporting it has room for  
lots of stuff). Our belief (mine anyway) was that you would hurt ES4  
adoption-with-migration too much by removing with from version=4 and  
you wouldn't save footprint enough; compared to adding reformed-with  
support. We should check this belief now that we are getting on to  
practical implementations.

Good stuff, keep it coming.

/be",
    "header": Object {
      "date": 2007-11-11T06:08:11.000Z,
      "from": Object {
        "email": "brendan@mozilla.org",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=I%27m%20confused%20about%20the%20design%20constraints%20on%20ES4&In-Reply-To=fee0a56d0711102152p27405f39t17e78ec15e080cb0%40mail.gmail.com",
      "subject": "I'm confused about the design constraints on ES4",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004948.html",
  },
  Object {
    "body": "On Nov 10, 2007, at 10:08 PM, Brendan Eich wrote:

> On Nov 10, 2007, at 9:52 PM, Mark Miller wrote:
>
>> I'm using \\"with\\" here only as an example, to try to understand the
>> nature of the compatibility constraints on the ES4 process.
>
> Compatibility imposes footprint costs, but it also creates a
> migration tax proportional to usage, roughly. We're trying not to
> blow either footprint budget or migration budget. These are fuzzy,
> hard to quantify and reason about; nice judgment is required.

I meant to add: we're on a slippery slope once opt-in versioning  
means removing stuff if the trade against adding compensating/better  
stuff seems to win. Slide a little way down, fix or remove with and  
bad-eval (keep good-eval, TBD ;-). Slide further, you are starting to  
talk \\"two languages\\" and that has brainprint and creeping  
compatibility/shared-code hazards we don't like.

But let's target the bad boys first: with, bad-eval. We've tried to  
reform both. Recidivism is a risk if we misjudge. ;-)

/be",
    "header": Object {
      "date": 2007-11-11T06:15:41.000Z,
      "from": Object {
        "email": "brendan@mozilla.org",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=I%27m%20confused%20about%20the%20design%20constraints%20on%20ES4&In-Reply-To=ADACFE2F-68E0-4237-8E52-4611E31FEB61%40mozilla.org",
      "subject": "I'm confused about the design constraints on ES4",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004949.html",
  },
  Object {
    "body": "On Nov 10, 2007, at 9:57 PM, Brendan Eich wrote:

> If I understand your point, it's that if we allow
>
>    (a is T)
>
> given a type name T bound by a type, class, or interface definition;
> but we disallow
>
>    let (t = T) (a is t)
>
> and insist on
>
>    let (t = T) (a is type t)

Make that

   let (t = type T) (a is type t)

But even that doesn't work. I forgot an agreement from the September  
face-to-face meeting, to make 'is' less future-hostile to an \\"ES5\\"  
that merges type and value expressions somehow: change 'is' to insist  
on a type expression only, therefore not including the unary 'type E'  
vaue-expression.

This results in the current RI's behavior, modulo that bug where  
'type T' => null (those FIXME comments in eval.sml):

 >> type T = {p:int}
 >> let t = T
[locn] /Users/brendaneich/Hacking/es4/com.mozilla.es4.smlnj/builtins/ 
Error.es:86:55-86.55
[stack] [init t()]
**ERROR** EvalError: uncaught exception: TypeError: getValue on a  
type property: <public >::T  (near /Users/brendaneich/Hacking/es4/ 
com.mozilla.es4.smlnj/builtins/Error.es:86:55-86.55)
 >> let t = type T
 >> t
null
 >> o = {p:42}
[object Object]
 >> o is T
false
 >> q = {p:42}:T
[object Object]
 >> q is T
true
 >> q is t
**ERROR** VerifyError: expected type fixture for: [[<public >,  
<internal >], [<public __ES4__>]]::t (near <no filename>:1:2-1.1)  
while normalizing <TypeName: {(<public >, <internal >), (<public  
__ES4__>)}::t> (near <no filename>:1:2-1.1)
 >> q is type t
**ERROR** ParseError: expecting semicolon before identifier(t) (near  
<no filename>:1:2-1.1)
 >> q is (type t)
**ERROR** ParseError: unknown token in unionType (near <no filename>: 
1:2-1.1)

See, 'is' won't even begin to parse 'type t' or parenthesized  
(union!) forms of same. The RI bug that made t null doesn't matter.

> The issues are (AFAIK):
>
> * Should instanceof do its loosey-goosey ES3 thing for functions,
> which have mutable .prototype, and mix this backward-compatible
> feature into different-in-many-ways subtype tests done by 'is'-as-
> proposed?

My current thinking is \\"no\\" but I'd like to think more.

> * Should 'is' insist on fixed type name in its right operand, or is
> this inconsistent and pointless, an RI bug even?

So it's not an RI bug (ignoring the lack of meta-object hookup). It's  
intentional future-proofing against the day when merging type and  
value expressions (somehow!) is upon us. Which you've expedited! ;-)

If we allow a value expression on the right of 'is', the only  
syntactic ambiguities are structural type expressions:

record:   {p:int, q:string}
array:    [boolean, double, string]
union:    (undefined, string)
function: function (A,B):C /* no body, I'm a type */

Requiring these to be prefixed by unary 'type' and committing to the  
consequences (no strict-mode checking of 'is' by fancy, even  
conservative analyses; no future where we merge type and value  
expressions differently) does seem better to me. But I'm forgetting  
something from that September meeting, maybe. Checking minutes...

http://wiki.ecmascript.org/doku.php? 
id=meetings:minutes_sep_27_2007#proposal_walkthrough

Ticket 103: http://bugs.ecmascript.org/ticket/103

Seems the resolution ruled narrowly by pointing to meta-objects, as  
I've done a couple of times in this thread. But the big picture  
confusion you point out, that users expect dyadic operators to take  
value expression operands, and that fixed type names vs. other names,  
even well-bound let variable names (let const even!) can't be used on  
the right of 'is', seems not to have been considered.

If I nerd out over types, yeah: is/cast/wrap all take a right operand  
which must be a type expression. Get used to it, poindexter! ;-) But  
really, it's a bit harsh and anti-JS to say this, for 'is' at any  
rate. Possibly the verb is too short and overloaded. More work  
needed, I think.

/be",
    "header": Object {
      "date": 2007-11-11T06:50:03.000Z,
      "from": Object {
        "email": "brendan@mozilla.org",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=need%20some%20clarification%20on%20compile-time%20type%20vs.%20run-time%20type&In-Reply-To=56210484-F6EB-478C-A236-64C9B8B0E73A%40mozilla.org",
      "subject": "need some clarification on compile-time type vs. run-time type",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004951.html",
  },
  Object {
    "body": "Brendan Eich wrote:
> I'm going to summon Graydon and stand back now.
>
> /be
>   

Right, I'll wait to reply in full until then. I just want to point out
that the spec namespace isn't public.
http://wiki.ecmascript.org/doku.php?id=spec:spec gives me a \\"permission
denied\\" page.",
    "header": Object {
      "date": 2007-11-11T06:51:33.000Z,
      "from": Object {
        "email": "maian330@gmail.com",
        "name": "Yuh-Ruey Chen",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=need%20some%20clarification%20on%20compile-time%20type%20vs.%20run-time%20type&In-Reply-To=56210484-F6EB-478C-A236-64C9B8B0E73A%40mozilla.org",
      "subject": "need some clarification on compile-time type vs. run-time type",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004952.html",
  },
  Object {
    "body": "Hi,

I've noticed that rounding in the reference implementation is implemented using
IEEE roundTiesToEven, but in browsers .5 values appear to round towards zero.
Although roundTiesToEven is desirable from a computational point of view,
there's likely a significant risk that changing to this method could break some
existing ECMAScript.

Math.round(1.5) === Math.round(2.5) // true in RI, false in browsers

Regards,
Jonathan",
    "header": Object {
      "date": 2007-11-11T12:04:10.000Z,
      "from": Object {
        "email": "jwatt@jwatt.org",
        "name": "Jonathan Watt",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=roundTiesToEven&In-Reply-To=",
      "subject": "roundTiesToEven",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004953.html",
  },
  Object {
    "body": "On 11/11/2007, Jonathan Watt <jwatt at jwatt.org> wrote:
> I've noticed that rounding in the reference implementation is implemented using
> IEEE roundTiesToEven, but in browsers .5 values appear to round towards zero.
> Although roundTiesToEven is desirable from a computational point of view,
> there's likely a significant risk that changing to this method could break some
> existing ECMAScript.

That's really serious breakage - books, tutorials, references and real
world code all take for granted that halves alway round up.
-- 
David \\"liorean\\" Andersson",
    "header": Object {
      "date": 2007-11-11T12:11:28.000Z,
      "from": Object {
        "email": "liorean@gmail.com",
        "name": "liorean",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=roundTiesToEven&In-Reply-To=4736EFBA.5040506%40jwatt.org",
      "subject": "roundTiesToEven",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004954.html",
  },
  Object {
    "body": "On Nov 11, 2007 1:34 AM, Brendan Eich <brendan at mozilla.org> wrote:
[snip]
> Got your back here ;-). Narcissus (http://lxr.mozilla.org/mozilla/
> source/js/narcissus/) wants this too, and it's going to end up
> falling out of the reflection APIs:
>
>      reflect::typeOf(this).reflect::construct(arguments)
>
> or of course:
>
>    { use namespace reflect;
>       . . . typeOf(this).constructo(arguments) }
>

+1
eden want this too :)
http://edenrr.googlecode.com/svn/trunk/as3/src/buRRRn/eden/ECMAScript.as

in there I got a scanFunction()
that need to be able to switch between a simple function call with arguments
or a contructor call with arguments, at runtime

so 2 follow up questions about the reflect namespace

is something as

var str = \\"some.thing::MyClass\\";
var c:Class = getObjectFromString( str ); //maybe a use of eval here ?
var instance:* = eflect::typeOf( c ).reflect::construct(arguments);

can work ?

]> in your example. The http://wiki.ecmascript.org/doku.php?
> id=proposals:meta_objects proposal is out of date, it uses iterators
> for the type and value parameters, but IIRC we have agreement to
> satisfy your use-case. See http://bugs.ecmascript.org/ticket/232.
>

and then the second question,
is the meta objects and reflect namespace are optionnal ?

some months ago I remember they were but now in the wiki page
I see
\\"This proposal is to amend the spec with a normative set of meta-objects
which must be present in any program and accessible at runtime.\\"

but as the page is out of date, just wondering

cheers,
zwetan",
    "header": Object {
      "date": 2007-11-11T12:11:50.000Z,
      "from": Object {
        "email": "zwetan@gmail.com",
        "name": "zwetan",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=.newApply%28%29%20%3F&In-Reply-To=C3A3544C-CD0E-4B8B-97D5-001E71C436B1%40mozilla.org",
      "subject": ".newApply() ?",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004955.html",
  },
  Object {
    "body": "Hardcore freak cock action 

      http://geocities.com/JoaquinPhillips33/",
    "header": Object {
      "date": 2007-11-11T12:34:35.000Z,
      "from": Object {
        "email": "dwseatplym@seatply.com",
        "name": "Lorraine Burrell",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=%2A%2A%2ASPAM%2A%2A%2A%20Horny%20sluts%20love%20HUGE%20cocks%20&In-Reply-To=",
      "subject": "***SPAM*** Horny sluts love HUGE cocks",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004956.html",
  },
  Object {
    "body": "On 2007-11-11, at 00:57 EST, Brendan Eich wrote:

> There are questions about exactly what strict mode analyses might be
> mandated as normative if an implementation supports strict mode. This
> may be clearer to Graydon and Cormac than to me, so I'd welcome their
> comments. For example:
>
>     function g(a_not_null: T!) ...
>
>     function f(a: T) {
>         if (a !== null)
>             g(a);           // no cast required?
>     }

IMO, mandating that level of analysis violates the spirit of the goal  
of permitting simple compilers.  You should use \`type switch\` if you  
want to avoid the cast (and guarantee no redundant runtime overhead).",
    "header": Object {
      "date": 2007-11-11T12:52:50.000Z,
      "from": Object {
        "email": "ptw@pobox.com",
        "name": "P T Withington",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=need%20some%20clarification%20on%20compile-time%20type%20vs.%20run-time%20type&In-Reply-To=56210484-F6EB-478C-A236-64C9B8B0E73A%40mozilla.org",
      "subject": "need some clarification on compile-time type vs. run-time type",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004957.html",
  },
  Object {
    "body": "liorean wrote:
> On 11/11/2007, Jonathan Watt <jwatt at jwatt.org> wrote:
>> I've noticed that rounding in the reference implementation is implemented using
>> IEEE roundTiesToEven, but in browsers .5 values appear to round towards zero.
>> Although roundTiesToEven is desirable from a computational point of view,
>> there's likely a significant risk that changing to this method could break some
>> existing ECMAScript.
> 
> That's really serious breakage

Well, it's likely only a small bug in the reference implementation rather than a
requirement of the specification, so not too big a deal I'd think.

> - books, tutorials, references and real
> world code all take for granted that halves alway round up.

Err, right. Round up, not round to zero. Thanks for the correction.",
    "header": Object {
      "date": 2007-11-11T13:23:00.000Z,
      "from": Object {
        "email": "jwatt@jwatt.org",
        "name": "Jonathan Watt",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=roundTiesToEven&In-Reply-To=cee13aa30711110411i76ffe4b9j74c775c59895cd1b%40mail.gmail.com",
      "subject": "roundTiesToEven",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004958.html",
  },
  Object {
    "body": "An HTML attachment was scrubbed...
URL: http://mail.mozilla.org/pipermail/es-discuss/attachments/20071111/b59c7bdf/attachment-0002.html",
    "header": Object {
      "date": 2007-11-11T14:05:43.000Z,
      "from": Object {
        "email": "wf@world-foundation.org",
        "name": "Manufacturing News",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Small%20Business%20and%20Entrepreneurship&In-Reply-To=",
      "subject": "Small Business and Entrepreneurship",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004960.html",
  },
  Object {
    "body": "An HTML attachment was scrubbed...
URL: http://mail.mozilla.org/pipermail/es-discuss/attachments/20071112/ea521dc7/attachment-0002.html",
    "header": Object {
      "date": 2007-11-11T14:31:00.000Z,
      "from": Object {
        "email": "jnl@booyaa.ebay.sun.com",
        "name": "Armando Rivers",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=%2A%2A%2ASPAM%2A%2A%2A%20Beware%20of%20imitators%2C%20this%20is%20the%20original%20men%27s%20phermone&In-Reply-To=",
      "subject": "***SPAM*** Beware of imitators, this is the original men's phermone",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004959.html",
  },
  Object {
    "body": "Hi Brendan,

There are many individual aspects of the the ES4 proposal that I like,
many things I don't. All of which I hope to enumerate for this list
over time. But overall my main distress is still the size of the
language.

At http://weblogs.mozillazine.org/roadmap/archives/2007/11/es4_news_and_opinion.html
you state:

# [...] the proposed ECMAScript 4th edition (ES4) grammar is a bit
more than twice
# as big as ES3's, counting several ways [...]
# This is not out of line given the eight years since ES3, which came less than
# three years after ES1.

It is one thing to sigh with despair at other people's tendencies to
add features to languages over time. It is another to see this as a
virtue. Perhaps EcmaScript 15, eighty years from now, will be 10 times
as large as ES4. I would agree that this may happen, as it seems to be
happening to Java. But should we look forward to this as a good thing?

Please don't dismiss such \\"mood of the language\\" issues. The \\"fuzzy\\"
points you made in your previous reply to me were quite valuable, even
though they are at least as non-objectively \\"mood of the
language\\"-like as many of the arguments you've dismissed on these
grounds. Language size has a real cost. The \\"brainprint\\" you refer to,
at least for my brain, goes up more than linearly in the size of
language.

Fortunately, later in that same paragraph, you say:

# And we're being generous with syntactic conveniences,
# which desugar to a smaller core language.

>From my perspective, this may be very good news! Is this smaller core
language documented anywhere? E, Scheme, Mozart/Oz, and many languages
I like are organized as small core/kernel language + syntactic sugar.
Bottom-up learners like myself can more easily understand such
languages by first absorbing the core language, and then understanding
the rest in terms of their expansion to the constructs they've already
understood.

>From a security perspective, a small core/kernel language is
especially important. Secure computing is best understood as a
multi-player game. In order to plan one's moves, one must understand
not only what one is able to do, one must also understand the limits
on what the other players are able to do. Such arguments, whether
formal or informal, are effectively inductions over all the operations
available to the other players. Fortunately, with the core + sugar
approach, such arguments only need to enumerate the elements of the
core.

-- 
Text by me above is hereby placed in the public domain

    Cheers,
    --MarkM",
    "header": Object {
      "date": 2007-11-11T18:44:00.000Z,
      "from": Object {
        "email": "erights@gmail.com",
        "name": "Mark Miller",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=I%27m%20confused%20about%20the%20design%20constraints%20on%20ES4&In-Reply-To=72B6CBFE-68B4-4E65-8736-AAFB6A8A705F%40mozilla.org",
      "subject": "I'm confused about the design constraints on ES4",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004961.html",
  },
  Object {
    "body": "The spec: namespace holds old, misleadingly inaccurate (for ES4) docs  
based on AS3. Nothing there has been touched in many moons. We made  
it inaccessible to avoid repeated confusion, and sure enough, when it  
was reopened inadventently again for a few days, almost immediately  
there was confusion.

We could just remove spec: at some point. The plan is not to use  
dokuwiki for actual spec production, since it isn't rich enough to  
generate the final Ecma or ISO spec format.

/be

On Nov 10, 2007, at 10:51 PM, Yuh-Ruey Chen wrote:

> Brendan Eich wrote:
>> I'm going to summon Graydon and stand back now.
>>
>> /be
>>
>
> Right, I'll wait to reply in full until then. I just want to point out
> that the spec namespace isn't public.
> http://wiki.ecmascript.org/doku.php?id=spec:spec gives me a  
> \\"permission
> denied\\" page.
> _______________________________________________
> Es4-discuss mailing list
> Es4-discuss at mozilla.org
> https://mail.mozilla.org/listinfo/es4-discuss",
    "header": Object {
      "date": 2007-11-11T19:08:37.000Z,
      "from": Object {
        "email": "brendan@mozilla.org",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=need%20some%20clarification%20on%20compile-time%20type%20vs.%20run-time%20type&In-Reply-To=4736A675.2000504%40gmail.com",
      "subject": "need some clarification on compile-time type vs. run-time type",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004962.html",
  },
  Object {
    "body": "On Nov 11, 2007, at 4:11 AM, liorean wrote:

> On 11/11/2007, Jonathan Watt <jwatt at jwatt.org> wrote:
>> I've noticed that rounding in the reference implementation is  
>> implemented using
>> IEEE roundTiesToEven, but in browsers .5 values appear to round  
>> towards zero.
>> Although roundTiesToEven is desirable from a computational point  
>> of view,
>> there's likely a significant risk that changing to this method  
>> could break some
>> existing ECMAScript.
>
> That's really serious breakage - books, tutorials, references and real
> world code all take for granted that halves alway round up.

Don't worry, that's not an intended change to double rounding  
(decimal is new and has more rounding control, but for double we're  
stuck).

It looks like an unintended consequence of using the SML-NJ Real64  
library. I filed http://bugs.ecmascript.org/ticket/301. Thanks,  
Jonathan, for pointing this out,

/be",
    "header": Object {
      "date": 2007-11-11T19:22:24.000Z,
      "from": Object {
        "email": "brendan@mozilla.org",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=roundTiesToEven&In-Reply-To=cee13aa30711110411i76ffe4b9j74c775c59895cd1b%40mail.gmail.com",
      "subject": "roundTiesToEven",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004963.html",
  },
  Object {
    "body": "On Nov 11, 2007, at 10:44 AM, Mark Miller wrote:

> Hi Brendan,
>
> There are many individual aspects of the the ES4 proposal that I like,
> many things I don't. All of which I hope to enumerate for this list
> over time.

That would be great.

> It is one thing to sigh with despair at other people's tendencies to
> add features to languages over time.

(People tend to do that with all languages, but why despair? It's  
either inevitable or good. I'm assuming the philosophy of despair is  
something we both try to avoid.)

> It is another to see this as a
> virtue. Perhaps EcmaScript 15, eighty years from now, will be 10 times
> as large as ES4. I would agree that this may happen, as it seems to be
> happening to Java. But should we look forward to this as a good thing?

There's not going to be an ES15, and eighty years is way over the  
event horizon. The problems JS users face now won't be solved that  
slowly in the language. Instead, at the margins at first and  
increasing non-linearly, some new runtime (probably only one) will  
eat away at all of the open standards implemented in browsers --  
unless those standards can evolve quickly.

This is a real threat. Right now major web sites are being paid tons  
of money to retool using Silverlight, while others are being paid to  
develop Adobe AIR applications. I'm not saying one bad word about the  
merits of those closed-standard runtimes, except that they are simply  
not open by the same definition as browsers based on web standards  
that co-evolve with the browsers are. Even when those other runtimes  
embrace and extend web standards, the whole result is proprietary,  
single-vendor.

With ES4 and other \\"post Firefox\\" web standards (the WHAT-WG Web Apps  
1 and Web Forms 2 work, which is supposedly feeding into the re- 
chartered W3C HTML Working Group), a combination of browser vendors  
(minority market share, the game theory explains everything here --  
there's no secret alternate-runtime agenda) and web developers (who  
have been traditionally *unrepresented* in pay-to-play standards  
consortia) have tried to evolve open web standards quickly.

This \\"open standards common\\" approach is not easy, and it doesn't  
follow the traditional model for language design. At best it involves  
a high-quality peer group folding the results of experiments into the  
emerging standard, factoring to ensure compositionality and a smaller  
core than syntax indicates. And these efforts tend to be rolling  
standards parties -- nothing is pushed to de-jure status prematurely.  
Again, not ideal for interop, but much better than stagnation.

This model for evolving the web is new since 2004, but something like  
it was already happening behind the scenes, without being formalized,  
when XMLHttpRequest was implemented in other browsers in the early  
2000s. There, an informal peer group (most of the people knew their  
peers at other browser vendors via standards work) was following the  
lead of Microsoft (which gave Java the boot and then had to add XHR  
for Outlook's webmail!), but the general principles of incremental,  
backward-compatible change prefigured the more explicit goals and  
methods of the WHAT-WG. Similar work happened with JavaScript  
variants, including Mozilla's and Macromedia's dialects, which fed  
forward into Ecma TG1.

You can call this process a bad thing because it's far removed from  
what I'll call the Steele/Sussman or Niklaus Wirth language design  
model. I don't care to moralize about it at this critical point in  
web evolution. I think it's at worst the lesser evil, and it is in  
any event inevitable for any of us among the minority-share browser  
vendors, and the Ajax web developers who stick to the browser  
runtime, who together are trying to make progress without commanding  
dominant market power that includes OS auto-updated distribution  
channels.

What I've written here seems far removed from language design  
principles. It is close to a description of fitness characteristics  
and survival threats in the web ecosystem. The principles and harsh  
realities have to meet somehow. Speaking for myself (since you  
addressed me; I'm not sole or lead ES4 designer), I don't see a  
better way to proceed than shared effort in groups such as the Ecma  
TG1 group, the WHAT-WG, etc.

> Please don't dismiss such \\"mood of the language\\" issues. The \\"fuzzy\\"
> points you made in your previous reply to me were quite valuable, even
> though they are at least as non-objectively \\"mood of the
> language\\"-like as many of the arguments you've dismissed on these
> grounds.

First, I don't dismiss \\"mood\\" arguments, I object to them being  
substituted as evidence for categorically distinct claims about  
compatibility and other technical properties. Those \\"break the web\\"  
claims need to be substantiated or withdrawn.

Second, my point about compatibility being fuzzy is not a subjective  
argument. It could be quantified, at great expense, and pretty much  
only in hindsight. The plain fact, and Firefox and Safari rising in  
market share are proof of this, is that web compatibility does not  
mean emulating the last (monopoly or near-monopoly) implementation  
bug-for-bug. It never has, not when Netscape took over from Mosaic,  
not when IE took over Netscape's market share.

> Language size has a real cost. The \\"brainprint\\" you refer to,
> at least for my brain, goes up more than linearly in the size of
> language.

People invoke Scheme when talking about JavaScript. I was originally  
drawn to Scheme when Netscape recruited me in early 1995, but there  
was less than zero time to use it, and anyway, it was and remains a  
teaching and research language. People using it industry have to  
procure or write a lot of code to make it usable, and interoperation  
is not great (as with C) because the reports intentionally  
underspecify. At least with JS we specified more for interop. But I  
over-minimized the original design, and ES2 and 3 were growth- 
restricted. The result has been a big complexity tax on users of the  
language, especially those trying to build robust libraries.

The situation with Scheme today seems relevant to ES4/JS2 in another  
respect. R6RS has grown from R5, a lot, and it has sometimes  
overspecified capriciously, as Will Clinger and others have pointed  
out. This has led to an ERR5RS counter-action. From 100,000 feet, you  
might compare what's going on to ES4 vs. \\"ES3.1\\" or whatever it might  
be called. Closer up, the comparison breaks down badly in my opinion.

Notwithstanding all the differences that prevent easy comparisons, I  
think it's fair to say that those of us in TG1 working on ES4 take  
the traditional first paragraph of the Scheme reports to heart:

\\"Programming languages should be designed not by piling feature on  
top of feature, but by removing the weaknesses and restrictions that  
make additional features appear necessary. Scheme demonstrates that a  
very small number of rules for forming expressions, with no  
restrictions on how they are composed, suffice to form a practical  
and efficient programming language that is flexible enough to support  
most of the major programming paradigms in use today.\\"

Compositional, orthogonal features really do mean (if the language  
designers got it right) that you don't have to think about order N^2  
or N! special case combinations as N grows. ES4 is not being monkey- 
patched or otherwise hacked simplistically or carelessly on top of  
ES3. I note that kind of language-hacking, when it happens in  
standards bodies, is more a hazard of growing by too-small increments  
forced through a standards process that dumbs down the technical  
thinking and stamps the standard before the dominant vendors have  
implemented it fully (this happened with ES3; less so with ES2).

> Fortunately, later in that same paragraph, you say:
>
> # And we're being generous with syntactic conveniences,
> # which desugar to a smaller core language.
>
>> From my perspective, this may be very good news! Is this smaller core
> language documented anywhere? E, Scheme, Mozart/Oz, and many languages
> I like are organized as small core/kernel language + syntactic sugar.
> Bottom-up learners like myself can more easily understand such
> languages by first absorbing the core language, and then understanding
> the rest in terms of their expansion to the constructs they've already
> understood.

The desugarings I'm thinking of are documented in the wiki (e.g.  
destructuring assignment), not so much in the overview. I agree they  
should be documented so as to separate the core language -- we're  
just getting to spec-writing now, but this is something we'll work  
on. The core is still a significantly bigger language than ES3 by a  
good bit, however. This is intentional and we had better get it right  
before it becomes a standard.

>> From a security perspective, a small core/kernel language is
> especially important. Secure computing is best understood as a
> multi-player game. In order to plan one's moves, one must understand
> not only what one is able to do, one must also understand the limits
> on what the other players are able to do. Such arguments, whether
> formal or informal, are effectively inductions over all the operations
> available to the other players. Fortunately, with the core + sugar
> approach, such arguments only need to enumerate the elements of the
> core.

Yeah, we are hip to this. It's a crucial point. We haven't led with  
it, but it's evident in some of the voluminous materials on the wiki.

/be

-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://mail.mozilla.org/pipermail/es-discuss/attachments/20071111/cda4641f/attachment-0002.html",
    "header": Object {
      "date": 2007-11-11T20:14:33.000Z,
      "from": Object {
        "email": "brendan@mozilla.org",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=I%27m%20confused%20about%20the%20design%20constraints%20on%20ES4&In-Reply-To=fee0a56d0711111044x2e16d549x379e5b2880e9d686%40mail.gmail.com",
      "subject": "I'm confused about the design constraints on ES4",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004964.html",
  },
  Object {
    "body": "Brendan Eich wrote:
> I filed http://bugs.ecmascript.org/ticket/301.

Thanks for that. I'll file issues in the bug tracker directly in future.

Jonathan",
    "header": Object {
      "date": 2007-11-11T20:22:35.000Z,
      "from": Object {
        "email": "jwatt@jwatt.org",
        "name": "Jonathan Watt",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=roundTiesToEven&In-Reply-To=A5E119F1-2CFF-458F-8A0B-2F380BF11214%40mozilla.org",
      "subject": "roundTiesToEven",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004965.html",
  },
  Object {
    "body": "Brendan Eich wrote:
> > Anyway, we still have a similar confusion to what we had with
> > |instanceof|, except this time it's all in |is|:
> >
> > // assume |b| is a class and |a| is an instance of it
> > a is type b
> > a is b
> >
> > Since both work, this can fool the user into thinking that the |type|
> > operator is optional. Furthermore, the latter can still lead to newbie
> > confusion (thinking that the expr is equivalent to |a == b|). So  
> > I'm not
> > sure there is a net win.
>
> I think we should separate the Python n00b concern that 'is' might be  
> taken for ===. That is not a big potential problem in my view; JS is  
> not Python, even with things like generators (we don't have  
> GeneratorExit, names differ for the iteration protocol hooks, etc.)  
> in the mix. You have to be *this* tall; you have to pay attention to  
> the basics. False cognates in different parts of Europe can cause  
> embarrassment or even legal troubles ;-).
>   

Okay, agreed.

> > Well, I was just suggesting adding additional functionality to
> > |instanceof|, not changing the original behavior of it, so I'm not  
> > sure
> > where the compatibility issue is coming into play.
>
> Yes, you're upgrading it, but now it makes stronger guarantees for  
> the upgrade-case inputs than for the old ones. That seems problematic.
>   

Sorry, I'm still not getting it. The upgraded |instanceof| will behave
exactly the same for the inputs non-upgraded |instanceof| works on.
There are new guarantees, but they in no way affect the original ones.
There's no way to change the prototype chain of an object instantiated
from a class, right? |obj instanceof klass| is practically equivalent to
|obj is klass|. Am I missing something?

> >> But since (x is I) and (x is J) work fine for x = new C where class C
> >> implements I, J {...}, perhaps for interface types we could just make
> >> instanceof do what 'is' does. Comments?
> >
> > That works for me.
>
> Besides changing the guarantees, it mixes domains: prototype chain  
> and (possibly mutable) function.prototype vs. class/interface  
> supertype vs. structural supertype.
>
> > How about |obj instanceof type {a: int}|?
>
> Sure, that follows, but it's unnecessary for backward compatibility  
> as I noted. It might be good for clarity, until everyone learned it  
> and got tired of typing it too much ;-).
>   

I'm not exactly advocating upgrading |instanceof|. I just want |is| and
|instanceof| to be coherent on some fashion, so that the user can easily
choose one or the other with as little confusion as possible. More on
this later.

> > For
> > type expr nested within a value expr, that implies to me that it
> > resolves to a runtime representation of that type.
>
> Right -- type meta-objects are discussed here:
>
> http://wiki.ecmascript.org/doku.php?id=proposals:meta_object
>
> See also:
>
> http://bugs.ecmascript.org/ticket/248
>
> > And that implies that
> > every type must have a runtime representation, including structural
> > types, e.g. |type {a: int}| would resolve to some runtime  
> > representation
> > of the structural type defined by |{a: int}|.
>
> Indeed :-).
>   

Ah, that clarifies things a lot.

> > But from what I've heard and read up to now, |type x| isn't as generic
> > as I'm implying above, so I'm confused.
>
> If I understand your point, it's that if we allow
>
>    (a is T)
>
> given a type name T bound by a type, class, or interface definition;  
> but we disallow
>
>    let (t = T) (a is t)
>
> and insist on
>
>    let (t = T) (a is type t)
>
> where (type t) evaluates at runtime to the meta-object for T and then  
> 'is' proceeds to test whether a's dynamic type is a subtype of T,  
> then what good does our restriction on 'is' (that its right operand  
> must be a type fixture) actually *do*?
>   

Yes, that's one of the reason I'm confused. I didn't mention it
explicitly, because the way Graydon replied seemed to imply to me that
there was a very good reason that |is| requires type expressions, but on
second look, that's not the case. The other reason I was confused was
because of RI bugs, which you've elaborated on. When I saw that the expr
|(type int)| in the RI was not working, it made me think |type| was some
special operator that can only be used in certain situations.

Actually the fixed example you gave (|let (t = type T) (a is type t)|)
still confuses me. The first |type T| accepts a type expr and evaluates
to a meta-object, binding it to |t|. Now there are two possible
interpretations for the |is| test:
1) |is| expects a type expr, so |type t| is evidently a type expr. So
this is the reverse of the previous usage of the |type| operator, i.e.
this |type t| accepts a meta-object and evaluates to type expr. If this
interpretation is correct, this is extremely confusing.
2) |is| expects either a type expr or a meta-object, but in the latter
case, that meta-object must be from a |type| expr. This is a weird
restriction. Furthermore, I though the |x| in |type x| had to be a type
expr, yet in this case, |x| is a value expr (evaluating to the
meta-object). Again, very confusing.

So again, how exactly is |type| supposed to work?

> If I'm following myself, then all I can say is: I hear you! I'm with  
> you.
>
> > In any case, one advantage of having a runtime representation for  
> > every
> > type is that structural types can now be more easily used in a ES3- 
> > style
> > without the usage of type parameters and also allow type bindings  
> > to be
> > computed at runtime, e.g.
> >
> > function foo(x, t) {
> >     if (!(x instanceof t))
> >        throw some_type_error;
> >     print(x);
> > }
> > ...
> > let t;
> > if (cond)   // note how t can only be determined at runtime here
> >     t = type {a: int};
> > else
> >     t = type like {a: double};
> > ...
> > foo(obj, t);
>
> We went down this road before including type parameters, hoping to  
> avoid them while saving decidability. Yes, you can write code like  
> the above, but it is not the same when foo uses t in a type  
> annotation (say x:t in the parameter list). There, t has to be a  
> distinguished type parameter, so the checker can see instantiations  
> and make sure they pass fixed types too. There's also alpha renaming  
> to consider: type params should not collide unhygienically.
>   

Yeah, ES4 type parameters and type exprs allow early type checking, but
I figured that it would be nice to be able to use some ES4 features
without requiring the usage of the whole shebang. Namely, I can imagine
a user coming from an ES3 background to instantly see the usefulness of
structural types, yet not care at all about classes, type parameters, or
early type checking.

> Nit: your definition for (c) is not using \\"compatible with structural  
> type\\" the way we define the type compatibility relation (written \\"~:\\"  
> instead of \\"<:\\", see http://wiki.ecmascript.org/doku.php? 
> id=spec:type_relations).

BTW, I was mentioning the issue of the spec namespace being non-public
because I couldn't access this page.

Brendan Eich wrote:
> > The issues are (AFAIK):
> >
> > * Should instanceof do its loosey-goosey ES3 thing for functions,
> > which have mutable .prototype, and mix this backward-compatible
> > feature into different-in-many-ways subtype tests done by 'is'-as-
> > proposed?
>
> My current thinking is \\"no\\" but I'd like to think more.
>
> > * Should 'is' insist on fixed type name in its right operand, or is
> > this inconsistent and pointless, an RI bug even?
>
> So it's not an RI bug (ignoring the lack of meta-object hookup). It's  
> intentional future-proofing against the day when merging type and  
> value expressions (somehow!) is upon us. Which you've expedited! ;-)
>
> If we allow a value expression on the right of 'is', the only  
> syntactic ambiguities are structural type expressions:
>
> record:   {p:int, q:string}
> array:    [boolean, double, string]
> union:    (undefined, string)
> function: function (A,B):C /* no body, I'm a type */
>
> Requiring these to be prefixed by unary 'type' and committing to the  
> consequences (no strict-mode checking of 'is' by fancy, even  
> conservative analyses; no future where we merge type and value  
> expressions differently) does seem better to me. But I'm forgetting  
> something from that September meeting, maybe. Checking minutes...
>
> http://wiki.ecmascript.org/doku.php? 
> id=meetings:minutes_sep_27_2007#proposal_walkthrough
>
> Ticket 103: http://bugs.ecmascript.org/ticket/103
>
> Seems the resolution ruled narrowly by pointing to meta-objects, as  
> I've done a couple of times in this thread. But the big picture  
> confusion you point out, that users expect dyadic operators to take  
> value expression operands, and that fixed type names vs. other names,  
> even well-bound let variable names (let const even!) can't be used on  
> the right of 'is', seems not to have been considered.
>
> If I nerd out over types, yeah: is/cast/wrap all take a right operand  
> which must be a type expression. Get used to it, poindexter! ;-) But  
> really, it's a bit harsh and anti-JS to say this, for 'is' at any  
> rate. Possibly the verb is too short and overloaded. More work  
> needed, I think.
>
> /be
>   

Hmm, I can see why it kind of makes sense for |is|, |cast|, and |wrap|
all to require type exprs, considering they are all type operators. But
since |is| is a purely runtime check (pending Graydon's reply), it makes
no sense for it to not accept value exprs.

So far I see a couple solutions:

1) Let |is| work on value exprs, but leave |instanceof| alone. Then the
difference between the two resolves to whether the operand has a
prototype chain. That is, the only inputs that both will work on are
classes. It's still a gotcha, but a minor one.

2) Unify |is| and |instanceof| into a single |instanceof| operator. I'm
still not sure what you mean by guarantees, so at the moment I don't see
an issue other than |is| currently requiring a type expr. I also just
learned from your post that AS3 already has an |is| operator that works
similarly, so that may be another barrier to this solution. |instanceof|
composed with |like| also sounds awkward, e.g. |instanceof like type {a:
int}|, unless it's the other way around, e.g. |instanceof type like {a:
int}|.

3) Let |is| work on value exprs, and upgrade |instanceof| to work on
everything |is| works on. Again, not sure what you mean be guarantees.
This solution doesn't require the removal of |is| and so is more
compatible with AS3. On the other hand, the fewer keywords, the better.

4) As you say (I think), |is| may be too overloaded. That it works both
classes/interfaces and structural types even though the two are very
distinct tests is a cause for concern. Yet it is convenient to group
them into one operator.

In addition to all that, if |is| works on value exprs, there's still the
confusion I've previously pointed out:

// |b| is a class, |a| is instance of |b|
a is type b
a is b

Maybe we can just explain to the user that |type| is only required for
structural types to avoid syntactical ambiguity (in the same vein as
block {} vs. object literal {})?

-Yuh-Ruey Chen",
    "header": Object {
      "date": 2007-11-11T23:09:29.000Z,
      "from": Object {
        "email": "maian330@gmail.com",
        "name": "Yuh-Ruey Chen",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=need%20some%20clarification%20on%20compile-time%20type%20vs.%20run-time%20type&In-Reply-To=56210484-F6EB-478C-A236-64C9B8B0E73A%40mozilla.org",
      "subject": "need some clarification on compile-time type vs. run-time type",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004966.html",
  },
  Object {
    "body": "On Nov 11, 2007, at 3:09 PM, Yuh-Ruey Chen wrote:

> Sorry, I'm still not getting it. The upgraded |instanceof| will behave
> exactly the same for the inputs non-upgraded |instanceof| works on.
> There are new guarantees, but they in no way affect the original ones.

They're stronger than the original ones, and different in kind too.  
Seems like apples and oranges mixed under one operator. Not obviously  
necessary given 'is', but here's a thought: instanceof does its  
prototype chain walk on the left operand, looking for an object equal  
to the value of the right operand's 'prototype' property, iff the  
right operand has [[HasInstance]] as function objects do in ES3.  
Otherwise it does a dynamic form of 'is', and for syntactic  
disambiguation, you may have to use unary 'type' on the right operand.

> There's no way to change the prototype chain of an object instantiated
> from a class, right? |obj instanceof klass| is practically  
> equivalent to
> |obj is klass|. Am I missing something?

No, classes are not really the issue. The key difference is that  
instanceof results can change over time for a given object on the  
left and plain old function on the right, while 'is' results cannot  
vary over the lifetimes of the same operands.

> Yes, that's one of the reason I'm confused. I didn't mention it
> explicitly, because the way Graydon replied seemed to imply to me that
> there was a very good reason that |is| requires type expressions,  
> but on
> second look, that's not the case.

See my followup mail, and http://bugs.ecmascript.org/ticket/103 --  
Graydon and the RI agreed with the last decision, from September -- I  
had forgotten about the exclusion of 'type E' to escape from value  
syntax on the right of 'is', in favor of making 'is' require a type  
expression only on its right.

> Actually the fixed example you gave (|let (t = type T) (a is type t)|)
> still confuses me. The first |type T| accepts a type expr and  
> evaluates
> to a meta-object, binding it to |t|. Now there are two possible
> interpretations for the |is| test:
> 1) |is| expects a type expr, so |type t| is evidently a type expr.

No, |type t| is a way to force a type expression t to be parsed as a  
value expression -- that's all.

> So
> this is the reverse of the previous usage of the |type| operator, i.e.
> this |type t| accepts a meta-object and evaluates to type expr. If  
> this
> interpretation is correct, this is extremely confusing.

Not correct. Sorry for adding to the confusion (temporarily) -- that  
RI session was meant to support 'is' taking a value expression on its  
right, but the RI doesn't do that per the resolution of #103. Ah, but  
you reply later to my subsequent messages. Ok, moving on:

> 2) |is| expects either a type expr or a meta-object, but in the latter
> case, that meta-object must be from a |type| expr. This is a weird
> restriction. Furthermore, I though the |x| in |type x| had to be a  
> type
> expr, yet in this case, |x| is a value expr (evaluating to the
> meta-object). Again, very confusing.

Agreed, and not what anyone wanted.

> So again, how exactly is |type| supposed to work?

It's supposed to parse its operand as a type expression and evaluate  
it to a value (meta-object).

> Namely, I can imagine
> a user coming from an ES3 background to instantly see the  
> usefulness of
> structural types, yet not care at all about classes, type  
> parameters, or
> early type checking.

Possibly, although structural types either are useful for 'is like'  
spot-checks (shape tests), or you end up defining names for them, and  
using those names to type objects, arrays, etc. created by  
initialisers, so as to get fixed property guarantees.

Classes come into the picture with 'wrap'. If you are upgrading an  
existing API with structural type annotations, but you can't afford  
to change all the callers to pass fixture-laden objects (this is  
highly likely; and it shouldn't be necessary to change all the  
callers of the API anyway), just structural type annotations will  
result in type errors for all calls that pass plain old dynamic  
objects and arrays. The API upgrader then has a choice: use 'like'  
for spot checks, or use 'wrap' for complete coverage (in case the API  
client mutates something behind the API implementations back).

GIven wrap, which creates some built-in nominal proxy type that does  
(efficient, we hope, not exponentially complex) checks on all reads  
and writes, you get type safety. But it can cost, even if optimized.  
As your API evolves and new users come along, if they can use ES4,  
you could provide nominal types for their use.

And even if you never expose nominal types in your API, the API's  
factory methods could return nominal types matching the structural  
type constraints in the API parameter and result annotations.

Just pointing out that even without early type checking, there are  
use-cases for programmable nominal types.

Type parameters are used by the iteration protocol (not yet  
implemented in the RI, but it's close). See

http://wiki.ecmascript.org/doku.php? 
id=proposals:iterators_and_generators

This protocol underpins the for-in constructs.

>> Nit: your definition for (c) is not using \\"compatible with structural
>> type\\" the way we define the type compatibility relation (written \\"~:\\"
>> instead of \\"<:\\", see http://wiki.ecmascript.org/doku.php?
>> id=spec:type_relations).
>
> BTW, I was mentioning the issue of the spec namespace being non-public
> because I couldn't access this page.

Sigh. I knew there was something not ancient and based on AS3  
mislocated there. Sorry again, we'll get that split out somehow.

> Hmm, I can see why it kind of makes sense for |is|, |cast|, and |wrap|
> all to require type exprs, considering they are all type operators.  
> But
> since |is| is a purely runtime check (pending Graydon's reply), it  
> makes
> no sense for it to not accept value exprs.

The tension between is/cast/wrap and is/instanceof is painful, isn't it?

> So far I see a couple solutions:
>
> 1) Let |is| work on value exprs, but leave |instanceof| alone. Then  
> the
> difference between the two resolves to whether the operand has a
> prototype chain. That is, the only inputs that both will work on are
> classes. It's still a gotcha, but a minor one.

Noted (more below).

> 2) Unify |is| and |instanceof| into a single |instanceof| operator.  
> I'm
> still not sure what you mean by guarantees, so at the moment I  
> don't see
> an issue other than |is| currently requiring a type expr.

Here's what I mean:

function F(){}
F.prototype = new Date
o = new F
assert(o instanceof F)
assert(!(o is F))

No mutation of the prototype property of F required (although that is  
significant in my view too). It makes no sense for (o is F) => true  
given that F is not a type. It's a function, and if you want function  
instances to stand for types, you need fixed type names for them or  
you lose decidability. But function definitions per ES3 can be  
replaced by new function definitions.

This by itself argues that instanceof and 'is' should not be combined.

> I also just
> learned from your post that AS3 already has an |is| operator that  
> works
> similarly, so that may be another barrier to this solution. | 
> instanceof|
> composed with |like| also sounds awkward, e.g. |instanceof like  
> type {a:
> int}|, unless it's the other way around, e.g. |instanceof type like  
> {a:
> int}|.

(More evidence of Adobe willingness to change ES4 from AS3, in case  
anyone needed it; but I'm still sympathetic to the argument that 'is'  
in ES4 should accept a value expression on its right, as 'is' in AS3  
does.)

> 3) Let |is| work on value exprs, and upgrade |instanceof| to work on
> everything |is| works on. Again, not sure what you mean be guarantees.

Let's split this into its two parts:

3a) Let 'is' work on value exprs -- hold this thought.
3b) Upgrade instanceof to do what it does in ES3, but instead of  
throwing a TypeError if its right operand has no [[HasInstance]]  
internal method, evaluate 'is' on its operands.

> This solution doesn't require the removal of |is| and so is more
> compatible with AS3. On the other hand, the fewer keywords, the  
> better.

I don't think we should combine instanceof and 'is', based on the  
example I gave above.

> 4) As you say (I think), |is| may be too overloaded. That it works  
> both
> classes/interfaces and structural types even though the two are very
> distinct tests is a cause for concern. Yet it is convenient to group
> them into one operator.

No, I don't agree (and I don't think I said anything like this). 'is'  
is <: the subtype relation, which is well-defined for all types.  
Types are not unrelated just because some use name for equivalence  
and identity, while others use structure. You can have a nominal type  
be a subtype of a structural type, and this is important -- of course  
you can't forge a subtype of a nominal type using a structural type,  
or even by nominal inheritance of the would-be superclass is final.

You may know that Modula 3 modeled nominal types by branding  
structural types. See

http://wiki.ecmascript.org/doku.php? 
id=discussion:classes_as_structural_types_with_branding

As noted, this doesn't seem like the right way to model nominal types  
for several reasons. But it sometimes helps people who missed Modula  
3 to see the connections between nominal and structural types.

On the other hand, it's a bit of a mash-up, in my view, to make  
instanceof grow 'is' hair. The right operands are \\"very distinct\\"  
between those operators today. See what I mean?

> In addition to all that, if |is| works on value exprs, there's  
> still the
> confusion I've previously pointed out:
>
> // |b| is a class, |a| is instance of |b|
> a is type b
> a is b

That's less confusing than convenient, I think. But it is a bit of  
redundancy that should raise a flag. Part of the thinking in  
resolving #103 in favor of type expression on right of 'is' was to  
future-proof against a world where type and value expressions are  
combined somehow. I don't believe that world will come to pass,  
though. If it should, sooner is better. Restricting 'is' as #103-as- 
resolved did isn't making anyone too happy right now :-/.

> Maybe we can just explain to the user that |type| is only required for
> structural types to avoid syntactical ambiguity (in the same vein as
> block {} vs. object literal {})?

Yeah, that's why I wrote \\"less confusing than convenient\\". It's not  
that big of a deal compared to other issues here, IMHO.

/be",
    "header": Object {
      "date": 2007-11-12T00:26:49.000Z,
      "from": Object {
        "email": "brendan@mozilla.org",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=need%20some%20clarification%20on%20compile-time%20type%20vs.%20run-time%20type&In-Reply-To=47378BA9.8000302%40gmail.com",
      "subject": "need some clarification on compile-time type vs. run-time type",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004967.html",
  },
  Object {
    "body": "Function findDuplicate is more like \\"mark duplicates\\". The side effect
is that it adds a __marker property to each object. As it stands, this
function can not be called more than once. The second call might be
passed a different array, but containing one of those objects that had
the __marker left over. Calling delete in a second loop would make the
algorithm 2n (best time). But this is not entirely safe; calling
delete on a Host object or window property will throw errors in
JScript env; and the property will still be there. So you can set
__marker = false, but then you've got a 2N algorithm that leaks a
\\"__marker\\" to objects in the program.

Unsafe:
if (map[array[i]])
// array[i].toString() returns a property name that exists in the
prototype chain of map (such as \\"toString\\").

Safer:
if(map.hasOwnProperty([array[i]])

However, relying on toString in the second part is still unsafe.

findDuplicate([1, \\"1\\", !window, \\"false\\", new Date()+'', new Date()+'']);

What is really going into this Array?

I think I see the intent, but the function is easily breakable, even
if fixed to have a second loop to set marker to null when done; and
including the hasOwnProperty fix.

Interop might be an issue, but the code is broken even in ES3.

JavaScript does not provide basic functionality for unique collections.

Consider a case where we have an array-like collection of objects and
we want to exclude duplicates. Not uncommon at all.

This could be a shopping cart of unique items (properties), a list of
attendees, a ledger of customers, a merge of n number of Lists,
containing top-scoring players
We want a unique collection.

Using SortedSet:
//-----------------------------------------------------------
// lis1, lis2 and lis3 are NodeList of LI, in Abstract View.

function compareFn(a, b) {
  return getScore(a) - getScore(b);
}

var players:Set = new SortedSet( compareFn );

players.addAll(lis1);
players.addAll(lis2);
players.addAll(lis3);
var top10:Set = new Set(players);
top10.trimToSize(10);

//-----------------------------------------------------------
Pros: fast, explicit

What's missing from ES4:
Set, SortedSet

Using Array:
//-----------------------------------------------------------
// Copy of array-like, as array, w/o duplicates.
var players = Array.concat(lis1, lis2).concat(lis3).unique();
players.sort(compareFn);
var top10 = players.toArray();
top10.length = 10;
//-----------------------------------------------------------
Pros: compact
Cons:
1) probably not as efficient (using quicksort)
2) slightly less explicit than the SortedSet example

What's missing from ES4:
Array.prototype.unique();
Array.prototype.toArray( arrayLike ) (also as Array.toArray(arrayLike))

ES3 concat and splice are the only way to obtain a copy of an array.
These are not explicit uses, but workarounds for a missing arraycopy
function.

I don't know how this problem could be solved with a Map. Doesn't feel
natural here. Here's my best shot at it:

//----------------------------------------------------------
var players = new Map<Object,Object>();

// Add all the players from each list into the players Map.
for(var i = 0; i < lis1.length; i++) {
  if(!Map.containsKey(lis1[i])
    players.add(lis1[i], null);
}
for(var i = 0; i < lis2.length; i++) {
  if(!Map.containsKey(lis2[i])
    players.add(lis2[i], null);
}
for(var i = 0; i < lis3.length; i++) {
  if(!Map.containsKey(lis3[i])
    players.add(lis3[i], null);
}

var keys = map.getKeys();
var newPlayers = Array.toArray(keys);
newPlayers.sort(compareFn);
newPlayers.length = 10;
//----------------------------------------------------------

Pros:
Cons:
1) not very straightforward or intuitive; not explicit
2) Verbose, requires two collections and a for loop.
3) Not efficient

What's missing:
Array.toArray( arraylike );

On Nov 9, 2007 10:00 AM, Lars Hansen <lhansen at adobe.com> wrote:
>
>
> Map and intrinsic::hashcode are your friends, indeed.  Cleaner solution,
> too.
>
> <rambling>
> For non-dynamic classes you can still use meta::set and meta::get to allow
> for
> limited applications like this.  I keep thinking that there are use cases
> for
> global meta::get and meta::set functions, so just like operator overloading
> can be done by extending global, generic functions a la intrinsic::+, it
> ought to
> be possible to hook into catchalls on the global level, using generic
> functions.
>
> class C { ... } // not dynamic
>
> meta generic function get(c: C, name) {
>     if (name == \\"__marker\\")
>        ...
>     else
>        return nextMethod()
> }
>
> meta generic function set(c: C, name, val) {
>     if (name == \\"__marker\\")
>         ...
>     else
>         nextMethod()
> }
> </rambling>
>
> --lars
>
>
>
>  ________________________________
>  From: es4-discuss-bounces at mozilla.org
> [mailto:es4-discuss-bounces at mozilla.org] On Behalf Of Kris Zyp
> Sent: 9. november 2007 09:20
> To: es4-discuss at mozilla.org
> Subject: ES3 quasi incompatibilities
>
>
>
>
> > or whether ES4 precludes the use of current ES3 AOP patterns and how
> > that might be solved.  Among other things.)
> ES3 AOP is in a class of patterns that is not strictly incompatible as ES3
> code alone won't break, but ES3 code would no longer behave as expected when
> interacting with ES4 code. AOP and other patterns in ES3 rely on the ability
> to add or modify properties on any object. Another example that should be
> noted is the O(n) algorithm for duplicate item and cyclic reference
> detection. For example:
> function findDuplicate(array){
>  var map={};
>  for (var i = 0; i < array.length; i++) {
>   if (typeof array[i] == 'object') {
>    if (array[i].__marker)
>     alert('found duplicate');
>    array[i].__marker = true;
>   }
>   else {
>    if (map[array[i]])
>
>     alert('found duplicate');
>    map[array[i]] = true;  }
>  }
> }
> This algorithm will fail if an array of objects is passed in that includes
> instances of non-dynamic (default for user created) classes. Temporarily
> marking objects with dynamic properties is the only way I am aware of to
> create O(n) algorithms in ES3 to detect duplicates and cyclic references.
> I don't think there is anything that can be done about this, it is just a
> result of static classes. Code written for ES4 can use maps (I think anyway)
> to solve this problem. This has probably already been discussed, but I just
> wanted to make sure it was noted.
> Kris
> _______________________________________________
> Es4-discuss mailing list
> Es4-discuss at mozilla.org
> https://mail.mozilla.org/listinfo/es4-discuss
>
>



-- 
Programming is a collaborative art.",
    "header": Object {
      "date": 2007-11-12T02:01:37.000Z,
      "from": Object {
        "email": "dhtmlkitchen@gmail.com",
        "name": "Garrett Smith",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=ES3%20quasi%20incompatibilities&In-Reply-To=1421FCFA117AA044B447467FDE380715D472B5%40eurmail.eur.adobe.com",
      "subject": "ES3 quasi incompatibilities",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004968.html",
  },
  Object {
    "body": "InterType Declarations

InterType Declarations are a useful Iand popular) way of adding
functionality to an object, usually to the prototype of a constructor.

Lets say I have a class Widget that I want to borrow from:

class Widget {

  private function Widget(){}

  static {
    getByNode : function():Widget { }
  }

  prototype {
    var isBeingDragged : false,
    valueOf : function(){ },
    toString : function():String { },
  }

  function moveTo(x, y){ }
}

Class Orangutan {} // Borrows from Widget

In ES3, I can use a crossCut function:

crossCut : function(receiver, supplier, propsArray, borrowFilter) { }

What is the ES4 way to introspect or modify or a class?

I want to provide beforeAdvice to the static Widget.getInstance.
For other Orangutan, I want to provide afterAdvice to the constructor
(add to pool) (or is this aroundAdvice?).
I want to borrow the prototype properties of Widget, to Orangutan (for
default read access)
I want to borrow the static methods.

Is this done through the traits?

Can I modify a sealed class? My understanding is that a sealed class'
instances can't have dynamic props. what about the class itself?

Also, is there a way to get the function name from an anonymous
function via the identifier it's bound with, or do I have to type:
getByNode: function getByNode():Widget{ }. I find the repetition
annoying to my hands and eyes. I want access to the function name
without having to do this.

-- 
Programming is a collaborative art.",
    "header": Object {
      "date": 2007-11-12T02:03:35.000Z,
      "from": Object {
        "email": "dhtmlkitchen@gmail.com",
        "name": "Garrett Smith",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=InterType%20Declarations%2C%20Cross-Cutting%20-%20how%20to%20in%20ES4%3F&In-Reply-To=",
      "subject": "InterType Declarations, Cross-Cutting - how to in ES4?",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004969.html",
  },
  Object {
    "body": "Garrett Smith wrote:
> JavaScript does not provide basic functionality for unique collections.
>   

It's trivial to implement an efficient Set class even in ES3 (with
certain restrictions on the \\"type\\" of the key) - just use objects which
are pretty much specialized hash tables (maps from string to values,
keys collides with prototype keys). For ES4, we have maps which are hash
tables as bareboned as you'll get in the language. I'm not sure why you
have all those |!Map.containsKey(lisx[i])| checks in your Map example,
since they're totally unnecessary.

A SortedSet is a bit trickier, because that would require some sort of
binary search tree to be efficient. But it can be done.",
    "header": Object {
      "date": 2007-11-12T03:18:31.000Z,
      "from": Object {
        "email": "maian330@gmail.com",
        "name": "Yuh-Ruey Chen",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=ES3%20quasi%20incompatibilities&In-Reply-To=c9e12660711111801h620fd764nc7b42377d7fd9f6f%40mail.gmail.com",
      "subject": "ES3 quasi incompatibilities",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004970.html",
  },
  Object {
    "body": "On Nov 11, 2007 7:18 PM, Yuh-Ruey Chen <maian330 at gmail.com> wrote:
> Garrett Smith wrote:
> > JavaScript does not provide basic functionality for unique collections.
> >
>
> It's trivial to implement an efficient Set class even in ES3 (with
> certain restrictions on the \\"type\\" of the key) - just use objects which
> are pretty much specialized hash tables (maps from string to values,
> keys collides with prototype keys). For ES4, we have maps which are hash
> tables as bareboned as you'll get in the language. I'm not sure why you
> have all those |!Map.containsKey(lisx[i])| checks in your Map example,
> since they're totally unnecessary.
>
Where is the string value in something like:
{a:1}

I wrote an Array-backed sorted set before but ended up not using it. I
did not like all the runtime checks and found another way to do what I
wanted to do.

> A SortedSet is a bit trickier, because that would require some sort of
> binary search tree to be efficient. But it can be done.
>


-- 
Programming is a collaborative art.",
    "header": Object {
      "date": 2007-11-12T03:36:50.000Z,
      "from": Object {
        "email": "dhtmlkitchen@gmail.com",
        "name": "Garrett Smith",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=ES3%20quasi%20incompatibilities&In-Reply-To=4737C607.9050502%40gmail.com",
      "subject": "ES3 quasi incompatibilities",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004971.html",
  },
  Object {
    "body": "On Nov 11, 2007 6:01 PM, Garrett Smith <dhtmlkitchen at gmail.com> wrote:

> Function findDuplicate is more like \\"mark duplicates\\". The side effect
> is that it adds a __marker property to each object. As it stands, this
> function can not be called more than once. The second call might be
> passed a different array, but containing one of those objects that had
> the __marker left over. Calling delete in a second loop would make the
> algorithm 2n (best time). But this is not entirely safe; calling
> delete on a Host object or window property will throw errors in
> JScript env; and the property will still be there. So you can set
> __marker = false, but then you've got a 2N algorithm that leaks a
> \\"__marker\\" to objects in the program.

The standard trick to avoid resetting the mark is to treat it not as a
bit, but to set it to a distinguished value every time (a serial
number).

Just to complete the example for ES4,

function findDuplicate(array) {
    let m = new Map.<*,null>
    for ( let i=0, limit=array.length ; i < limit ; i++ ) {
        let v = array[i]
        if (v is Object) {
            if (m.has(v))
                alert(\\"Found duplicate\\")
            else
                m.put(v,null)
        }
    }
}

Obviously that's reentrant and all that.

By default, Map uses intrinsic::hashcode and intrinsic::=== to handle
objects, so the above code handles object identity without any string
conversions, and unless intrinsic::hashcode is out to lunch, it's
roughly constant time, giving an O(n) algorithm for duplicate finding.
 Rehashing behind the scene may in practice make it more expensive, of
course.  (We've not seen fit to add a method to give a hint to the Map
about how large it may need to be.)

> Consider a case where we have an array-like collection of objects and
> we want to exclude duplicates. Not uncommon at all.

Map provides a collection of key-value mappings without duplicates;
you can always use \\"null\\" for the value as I did above.  It does not
have the Array methods, nor do the generic Array methods work on it,
because you can't talk about elements in terms of their indices.

On the other hand, \\"Array-like\\" and \\"exclude duplicates\\" don't combine
all that well, maybe.  I suspect what you're saying is an object that
behaves like an Array so that the Array generic methods can be used on
it, but to which elements are added by special functionality, or
excluded later by calls to unique().

It's pretty simple in ES4 to create objects that behave like Arrays in
their Get/Put/HasProperty/Delete behavior.  For example, here's a
sketch for an implementation of UniqueArray.<T> that does not store
duplicates:

class UniqueArray.<T>
{
   private var m = new Map.<uint,T>
   private var s = new Map.<T,null>
   private var _length = 0;

   // meta methods intercept all requests for unknown properties

   meta function get(n) {
       if (m.has(n))
           return m.get(n)
       return undefined
   }

   meta function set(n,v) {
       // do not store duplicates
       if (!(s.has(v)))
           m.put(n,v)
       if (n >= _length)
           _length = n+1
   }

   meta function has(n)
       m.has(n)

   meta function delete(n)
       m.remove(n)

   function get length()
       _length

   function set length(n) {
       if (n < _length) {
           for ( let i=n ; i < _length ; i++ )
               m.remove(i)
           _length = n;
       }
   }
}

> What's missing from ES4:
> Set, SortedSet

type Set.<T> = Map.<T,null>,  though obviously does not have
intersect, union -- clearly a weakness.  Good enough in simple cases.

--lars",
    "header": Object {
      "date": 2007-11-12T04:22:30.000Z,
      "from": Object {
        "email": "lth@acm.org",
        "name": "Lars T Hansen",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=ES3%20quasi%20incompatibilities&In-Reply-To=c9e12660711111801h620fd764nc7b42377d7fd9f6f%40mail.gmail.com",
      "subject": "ES3 quasi incompatibilities",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004972.html",
  },
  Object {
    "body": "Ladies always giggled at me and even guys did in the public toilets!    Well now I laugh at them because I took megadik    for 6 months and now my dick is much bigger than \\"average\\" size.Order MegaDik Now

Don't hesitate, make your order todayDid you know... MegaDik was featured in leading mens magazines such as FHM, MAXIM, plus many others,   and rated No.1 choice for penis enlargement... Also seen on TV

http://rapei.com



-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://mail.mozilla.org/pipermail/es-discuss/attachments/20071112/a79420e1/attachment-0002.html",
    "header": Object {
      "date": 2007-11-12T04:29:23.000Z,
      "from": Object {
        "email": "teixeira1@heniq.com.br",
        "name": "Rebekah Sierra",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=%2A%2A%2ASPAM%2A%2A%2A%20Give%20your%20partner%20new%20feelings%20while%20have%20a%20sex&In-Reply-To=",
      "subject": "***SPAM*** Give your partner new feelings while have a sex",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004973.html",
  },
  Object {
    "body": "On Nov 11, 2007, at 4:26 PM, Brendan Eich wrote:

> Part of the thinking in
> resolving #103 in favor of type expression on right of 'is' was to
> future-proof against a world where type and value expressions are
> combined somehow. I don't believe that world will come to pass,
> though. If it should, sooner is better. Restricting 'is' as #103-as-
> resolved did isn't making anyone too happy right now :-/.

Of course, Lars cut the Gordian knot in email just a bit later today:

   type T
   var v

   x is T               // if T is type then the compiler knows that,
                        // otherwise next case applies
   x is v               // reflect::typeOf(x).isSubtypeOf(v)
                        // fails if v not a Type object
   x is { ... }         // interpret as record type
   x is [ ... ]         // interpret as array type
   x is ( ... )         // interpret as union type
   x is function ...    // interpret as function type
   x is null            // interpret as null type
   x is undefined       // interpret as undefined type
   x is like T          // T must be a type expression anyhow

This allows arbitrary value expressions on the right of 'is', just so  
long as they don't look like type expressions in their leftmost  
token. Everyone wins. Yay?

/be",
    "header": Object {
      "date": 2007-11-12T06:35:46.000Z,
      "from": Object {
        "email": "brendan@mozilla.org",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=need%20some%20clarification%20on%20compile-time%20type%20vs.%20run-time%20type&In-Reply-To=F54214AD-B973-4C64-9E31-0A6ED939B033%40mozilla.org",
      "subject": "need some clarification on compile-time type vs. run-time type",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004974.html",
  },
  Object {
    "body": "Brendan Eich wrote:
> On Nov 11, 2007, at 3:09 PM, Yuh-Ruey Chen wrote:
>
> > Sorry, I'm still not getting it. The upgraded |instanceof| will behave
> > exactly the same for the inputs non-upgraded |instanceof| works on.
> > There are new guarantees, but they in no way affect the original ones.
>
> They're stronger than the original ones, and different in kind too.  
> Seems like apples and oranges mixed under one operator. Not obviously  
> necessary given 'is', but here's a thought: instanceof does its  
> prototype chain walk on the left operand, looking for an object equal  
> to the value of the right operand's 'prototype' property, iff the  
> right operand has [[HasInstance]] as function objects do in ES3.  
> Otherwise it does a dynamic form of 'is', and for syntactic  
> disambiguation, you may have to use unary 'type' on the right operand.
>   

Yes, the upgraded |instanceof| would have to perform two different types
of checks. But while the value of |instanceof| can change for function
operands, its value cannot change for type operands, just like |is|. The
two different type checks are distinct, and the new |is|-like type check
in no way affects the former prototype-chain type check, considering
that the only overlap between the two is type checking against classes
and the two type checks always agree on classes.

> > There's no way to change the prototype chain of an object instantiated
> > from a class, right? |obj instanceof klass| is practically  
> > equivalent to
> > |obj is klass|. Am I missing something?
>
> No, classes are not really the issue. The key difference is that  
> instanceof results can change over time for a given object on the  
> left and plain old function on the right, while 'is' results cannot  
> vary over the lifetimes of the same operands.
>   

If |is| is a purely runtime check, does this really matter? Can you give
me a use case involving a runtime type check that requires that the type
check always be the same for a pair of operands?

> > 2) |is| expects either a type expr or a meta-object, but in the latter
> > case, that meta-object must be from a |type| expr. This is a weird
> > restriction. Furthermore, I though the |x| in |type x| had to be a  
> > type
> > expr, yet in this case, |x| is a value expr (evaluating to the
> > meta-object). Again, very confusing.
>
> Agreed, and not what anyone wanted.
>   

Ok, thanks for the clarification. However, that still doesn't answer
this question: if the |x| in |type x| has to be a type expr, then how
did |type x| in the example work? |x| in that case was a value expr
(evaluating to a meta-object), not a type expr.

> > Namely, I can imagine
> > a user coming from an ES3 background to instantly see the  
> > usefulness of
> > structural types, yet not care at all about classes, type  
> > parameters, or
> > early type checking.
>
> Possibly, although structural types either are useful for 'is like'  
> spot-checks (shape tests), or you end up defining names for them, and  
> using those names to type objects, arrays, etc. created by  
> initialisers, so as to get fixed property guarantees.
>
> Classes come into the picture with 'wrap'. If you are upgrading an  
> existing API with structural type annotations, but you can't afford  
> to change all the callers to pass fixture-laden objects (this is  
> highly likely; and it shouldn't be necessary to change all the  
> callers of the API anyway), just structural type annotations will  
> result in type errors for all calls that pass plain old dynamic  
> objects and arrays. The API upgrader then has a choice: use 'like'  
> for spot checks, or use 'wrap' for complete coverage (in case the API  
> client mutates something behind the API implementations back).
>
> GIven wrap, which creates some built-in nominal proxy type that does  
> (efficient, we hope, not exponentially complex) checks on all reads  
> and writes, you get type safety. But it can cost, even if optimized.  
> As your API evolves and new users come along, if they can use ES4,  
> you could provide nominal types for their use.
>
> And even if you never expose nominal types in your API, the API's  
> factory methods could return nominal types matching the structural  
> type constraints in the API parameter and result annotations.
>
> Just pointing out that even without early type checking, there are  
> use-cases for programmable nominal types.
>
> Type parameters are used by the iteration protocol (not yet  
> implemented in the RI, but it's close). See
>
> http://wiki.ecmascript.org/doku.php? 
> id=proposals:iterators_and_generators
>
> This protocol underpins the for-in constructs.
>   

I wasn't disputing the usefulness of nominal types, but thanks for the
info anyway. Maintainers of large and complex ES3 libraries should
definitely consider migrating to nominal types and learn the whole type
system thoroughly. I was just pointing out that it would be nice to be
able to use some aspects of ES4 without having to understand everything
about it. Makes it more attractive to learn and more newbie-friendly,
and as we all know, the web is full of them.

> > Hmm, I can see why it kind of makes sense for |is|, |cast|, and |wrap|
> > all to require type exprs, considering they are all type operators.  
> > But
> > since |is| is a purely runtime check (pending Graydon's reply), it  
> > makes
> > no sense for it to not accept value exprs.
>
> The tension between is/cast/wrap and is/instanceof is painful, isn't it?
>   

Indeed. And it's all so subjective too...

> > So far I see a couple solutions:
> >
> > 1) Let |is| work on value exprs, but leave |instanceof| alone. Then  
> > the
> > difference between the two resolves to whether the operand has a
> > prototype chain. That is, the only inputs that both will work on are
> > classes. It's still a gotcha, but a minor one.
>
> Noted (more below).
>
> > 2) Unify |is| and |instanceof| into a single |instanceof| operator.  
> > I'm
> > still not sure what you mean by guarantees, so at the moment I  
> > don't see
> > an issue other than |is| currently requiring a type expr.
>
> Here's what I mean:
>
> function F(){}
> F.prototype = new Date
> o = new F
> assert(o instanceof F)
> assert(!(o is F))
>
> No mutation of the prototype property of F required (although that is  
> significant in my view too). It makes no sense for (o is F) => true  
> given that F is not a type. It's a function, and if you want function  
> instances to stand for types, you need fixed type names for them or  
> you lose decidability. But function definitions per ES3 can be  
> replaced by new function definitions.
>
> This by itself argues that instanceof and 'is' should not be combined.
>   

As I said before, is there any value in making sure that the value of |x
is y| never changes for a given pair x and y? I can understand the
importance of that guarantee for type annotations, but since |is| is a
late type check, I don't see the value.

FYI, I'm not really in favor of merging to the two operators. I do
recognize that there is a fundamental difference between the
|instanceof| test and the |is| test. But I could also say that there is
a fundamental difference between the |is| test and the |is like| test.
On the other hand, unless structural types are mutable, |is| and |is
like| are similar in that the values of both |is| and |is like| are for
a given pair of operands can never change. And structural types are
immutable, right?

Hmm, this makes me wonder if we could add an unary |instanceof| operator
that's analogous to the |like| operator. Just going to write out my
thoughts as they come... Consider |type T = (like some_structural_type,
instanceof some_constructor}|. However, that would make the |o is T|
test - and more importantly, type annotations involving T - unreliable,
since its value can change for the same operands. So I guess that's a no
go (just ignore this paragraph).

> > I also just
> > learned from your post that AS3 already has an |is| operator that  
> > works
> > similarly, so that may be another barrier to this solution. | 
> > instanceof|
> > composed with |like| also sounds awkward, e.g. |instanceof like  
> > type {a:
> > int}|, unless it's the other way around, e.g. |instanceof type like  
> > {a:
> > int}|.
>
> (More evidence of Adobe willingness to change ES4 from AS3, in case  
> anyone needed it; but I'm still sympathetic to the argument that 'is'  
> in ES4 should accept a value expression on its right, as 'is' in AS3  
> does.)
>
> > 3) Let |is| work on value exprs, and upgrade |instanceof| to work on
> > everything |is| works on. Again, not sure what you mean be guarantees.
>
> Let's split this into its two parts:
>
> 3a) Let 'is' work on value exprs -- hold this thought.
> 3b) Upgrade instanceof to do what it does in ES3, but instead of  
> throwing a TypeError if its right operand has no [[HasInstance]]  
> internal method, evaluate 'is' on its operands.
>
> > This solution doesn't require the removal of |is| and so is more
> > compatible with AS3. On the other hand, the fewer keywords, the  
> > better.
>
> I don't think we should combine instanceof and 'is', based on the  
> example I gave above.
>
> > 4) As you say (I think), |is| may be too overloaded. That it works  
> > both
> > classes/interfaces and structural types even though the two are very
> > distinct tests is a cause for concern. Yet it is convenient to group
> > them into one operator.
>
> No, I don't agree (and I don't think I said anything like this). 'is'  
> is <: the subtype relation, which is well-defined for all types.  
> Types are not unrelated just because some use name for equivalence  
> and identity, while others use structure. You can have a nominal type  
> be a subtype of a structural type, and this is important -- of course  
> you can't forge a subtype of a nominal type using a structural type,  
> or even by nominal inheritance of the would-be superclass is final.
>
> You may know that Modula 3 modeled nominal types by branding  
> structural types. See
>
> http://wiki.ecmascript.org/doku.php? 
> id=discussion:classes_as_structural_types_with_branding
>
> As noted, this doesn't seem like the right way to model nominal types  
> for several reasons. But it sometimes helps people who missed Modula  
> 3 to see the connections between nominal and structural types.
>   

Yeah, misunderstood you. I can see now that record types are like
undeclared interfaces. However, as I noted before, the |like| test for
structural types is still a different beast.

> > In addition to all that, if |is| works on value exprs, there's  
> > still the
> > confusion I've previously pointed out:
> >
> > // |b| is a class, |a| is instance of |b|
> > a is type b
> > a is b
>
> That's less confusing than convenient, I think. But it is a bit of  
> redundancy that should raise a flag. Part of the thinking in  
> resolving #103 in favor of type expression on right of 'is' was to  
> future-proof against a world where type and value expressions are  
> combined somehow. I don't believe that world will come to pass,  
> though. If it should, sooner is better. Restricting 'is' as #103-as- 
> resolved did isn't making anyone too happy right now :-/.
>
> > Maybe we can just explain to the user that |type| is only required for
> > structural types to avoid syntactical ambiguity (in the same vein as
> > block {} vs. object literal {})?
>
> Yeah, that's why I wrote \\"less confusing than convenient\\". It's not  
> that big of a deal compared to other issues here, IMHO.
>
> /be
>   

A thought: If the |type| operator can accept a value expr that resolves
to a meta-object and returns that meta-object, then |type| can be
chained, e.g. |type type type T| is equivalent to |type T|. In this way,
a user that's unsure if a particular type expression is ambigious can
just prefix it with |type| without worries.

-Yuh-Ruey Chen",
    "header": Object {
      "date": 2007-11-12T06:41:47.000Z,
      "from": Object {
        "email": "maian330@gmail.com",
        "name": "Yuh-Ruey Chen",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=need%20some%20clarification%20on%20compile-time%20type%20vs.%20run-time%20type&In-Reply-To=F54214AD-B973-4C64-9E31-0A6ED939B033%40mozilla.org",
      "subject": "need some clarification on compile-time type vs. run-time type",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004975.html",
  },
  Object {
    "body": "Given the following definitions:

class C {var p: int};
type S1 = {p: int};
type S2 = {p: int, p2: double};
generic function foo(x);
generic function foo(x: *) 0
generic function foo(x: C) 1
generic function foo(x: S1) 2
generic function foo(x: S2) 3
generic function foo(x: like S1) 4
generic function foo(x: like S2) 5
var o1: C = new C();
var o2: S1 = {p: 10};
var o3: S2 = {p: 10, p2: 3.14};
var o4 = {p: 10};
var o5 = {p: 10, p2: 3.14};
var o6 = {p: 10, p2: 3.14, p3: \\"hi\\"};

What do the following exprs evaluate to?
foo(o1);
foo(o2);
foo(o3);
foo(o4);
foo(o5);
foo(o6);

Also, I know that S1 <: Object, but is S2 <: S1? I've looked at
http://wiki.ecmascript.org/doku.php?id=clarification:type_system and
it's not clear to me. Is it still true that C <: S1?

-Yuh-Ruey Chen",
    "header": Object {
      "date": 2007-11-12T06:42:09.000Z,
      "from": Object {
        "email": "maian330@gmail.com",
        "name": "Yuh-Ruey Chen",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=generic%20function%20with%20structural%20types%20questions&In-Reply-To=",
      "subject": "generic function with structural types questions",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004976.html",
  },
  Object {
    "body": "On Nov 11, 2007, at 10:41 PM, Yuh-Ruey Chen wrote:

>> The key difference is that
>> instanceof results can change over time for a given object on the
>> left and plain old function on the right, while 'is' results cannot
>> vary over the lifetimes of the same operands.
>
> If |is| is a purely runtime check, does this really matter? Can you  
> give
> me a use case involving a runtime type check that requires that the  
> type
> check always be the same for a pair of operands?

Your poor-man's type parameters example will do. The 'is' operator is  
how you write an expression testing subtype, and the : type  
annotation colon enforces subtype relation for all writes to the  
annotated slot. So 'is' and annotations are closely related (ignore  
the hardcoded conversions within AnyString, AnyNumber, and AnyBoolean  
respectively).

> Ok, thanks for the clarification. However, that still doesn't answer
> this question: if the |x| in |type x| has to be a type expr, then how
> did |type x| in the example work? |x| in that case was a value expr
> (evaluating to a meta-object), not a type expr.

Maybe that was just a mistake :-).

>> The tension between is/cast/wrap and is/instanceof is painful,  
>> isn't it?
>
> Indeed. And it's all so subjective too...

See latest mail from me, Lars's Gordian knot slicing. It makes 'is'  
DWIM. 'cast' need not accept value expressions since it is useful  
only for the type checker (optional strict mode), and for  
documentation purposes. 'wrap' should do what 'like' does (require a  
type expression, currently).

> As I said before, is there any value in making sure that the value  
> of |x
> is y| never changes for a given pair x and y? I can understand the
> importance of that guarantee for type annotations, but since |is| is a
> late type check, I don't see the value.

Even if (as we believe so far) 'is' should not be analyzed by strict  
mode, you want the parallel between type annotations and 'is' to hold  
up over the lifetime of the slot in the case of a type annotation,  
and the operands in the case of 'is'. Well, I do, at any rate. Both  
'let x:T' and 'x is T' invoke the subtype relation. And the prototype  
relation is not the subtype relation.

> FYI, I'm not really in favor of merging to the two operators. I do
> recognize that there is a fundamental difference between the
> |instanceof| test and the |is| test. But I could also say that  
> there is
> a fundamental difference between the |is| test and the |is like| test.

Remember, nothing special goes on with 'is like'. Imagine explicit  
parenthese (not allowed because they mean union type, but pretend):

   x is T
   x is (like T)

We know this must be the case since you could have defined

   type T = like U

before the first line (x is T), and the result should be the same as  
if you expanded the typename:

   x is like U

> On the other hand, unless structural types are mutable, |is| and |is
> like| are similar in that the values of both |is| and |is like| are  
> for
> a given pair of operands can never change. And structural types are
> immutable, right?

Right. But don't believe 'is like' is a compound-keyword type  
operator -- it's two operators, the right one a unary prefix type op  
(type constructor really).

> Yeah, misunderstood you. I can see now that record types are like
> undeclared interfaces.

Not sure if you meant anonymous interfaces, but interfaces can have  
only methods, which can be overridden along the inheritance chain in  
the nominal type system. Structural types on the other hand describe  
records with fields -- not methods, although a field's type could be  
a function structural type.

Bottom line: interfaces != structural object types.

> However, as I noted before, the |like| test for
> structural types is still a different beast.

There's a possible generalization of 'like' to accept any type on its  
right (conversion is not an issue: http://bugs.ecmascript.org/ticket/ 
258). Remember, no non-compositional special cases or ad-hoc patches,  
if we can avoid 'em.

> A thought: If the |type| operator can accept a value expr that  
> resolves
> to a meta-object and returns that meta-object, then |type| can be
> chained, e.g. |type type type T| is equivalent to |type T|. In this  
> way,
> a user that's unsure if a particular type expression is ambigious can
> just prefix it with |type| without worries.

But the parser (not optional strict mode, the fundamental grammar)  
will reject a non-type expression (if we want it to). This is a case  
of load/edit/reload at worst.

But hey, I'm jazzed by Lars's \\"have our cake and eat it\\" proposal for  
'is'. For instanceof, we could do what you and I seem to be talking  
about: extend it to do what 'is' does, with the gravy that its right  
operand is always a value expression. So 'instanceof' could be used  
to handle all kinds of instantiation, ES3 mutable-prototype function  
constructors and ES4 types. Comments?

/be",
    "header": Object {
      "date": 2007-11-12T07:04:02.000Z,
      "from": Object {
        "email": "brendan@mozilla.org",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=need%20some%20clarification%20on%20compile-time%20type%20vs.%20run-time%20type&In-Reply-To=4737F5AB.6000607%40gmail.com",
      "subject": "need some clarification on compile-time type vs. run-time type",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004977.html",
  },
  Object {
    "body": "¹©Ó¦£º¼ô°å»ú¡¢ÕÛÍä»ú¡¢¾í°å»ú¡¢³å´²¡¢Ð£Æ½»ú
°²»ÕÊ¡ÈýÁ¦»ú´²ÖÆÔìÓÐÏÞ¹«Ë¾£¬Êô°²»ÕÊ¡ÃûÅÆ¡¢Ãâ¼ì²úÆ·Éú²úÆóÒµ£¬°²»ÕÊ¡¸ßÐÂ¼¼ÊõÆóÒµ£¬Âí°°É½ÊÐ¡°×¨¡¢¾«¡¢ÌØ¡¢ÐÂ¡±ÆóÒµ£¬Âí°°É½ÊÐÏÂ¸ÚÊ§ÒµÖ°¹¤ÔÙ¾ÍÒµ»ùµØ£¬½éÓÚÄÏ¾©¡¢ÎßºþÖ®¼ä£¬×øÂäÔÚÖøÃûµÄ¸Ö³ÇÂí°°É½ÊÐ£¬·á¸»µÄ¸ÖÌú×ÊÔ´Îª¹«Ë¾µÄ·¢Õ¹Ìá¹©ÁËµÃÌì¶ÀºñµÄÓÅÊÆ¡£¹«Ë¾Õ¼µØÃæ»ý108000Æ½·½Ã×£¬Ö÷ÒªÉú²ú¡°´óÊ¢¡±ÅÆÏµÁÐ¼ô°å»ú¡¢ÕÛÍä»ú¡¢¾í°å»ú¡¢¿ìËÙÑ¹Á¦»ú¡¢³å´²¡¢¿ª¾íÐ£Æ½»ú¡¢ÐÍ²ÄÍäÇú»úµ¶Ä£¾ßµÈ²úÆ·£¬×¨ÒµÎªº½¿Õ¡¢Çá¹¤¡¢Ò±½ð¡¢»¯¹¤¡¢½¨ÖþÆû³µ¡¢µçÁ¦¡¢×°äêµÈÐÐÒµÌá¹©ËùÐèÒªµÄ×¨ÓÃ»úÐµºÍ³ÉÌ×Éè±¸£¬²úÆ·ÏúÍùÈ«¹ú¸÷µØºÍÅ·ÃË¼°¶«ÄÏÑÇµØÇø²¢Ô¶ÏúÄÏ·Ç¡£ ¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¹«Ë¾ÓÃÏÖ´úÆóÒµµÄ¹ÜÀí·½·¨¡¢Á¢×ãÓÚ²úÆ·¹ÜÀí£¬ÒÔÆäÓÅÐãµÄÆ·ÖÊ£¬ÐÂÓ±µÄÉè¼Æ£¬ºÏÀíµÄ¼Û¸ñ£¬ÍêÉÆµÄÊÛºó·þÎñÓ®µÃÁË¹ã´ó¿Í»§µÄÒ»ÖÂºÃÆÀ£¬±»ÆÀÎª°²»ÕÊ¡¡°ÖØºÏÍ¬¡¢ÊØÐÅÓÃÏÈ½øµ¥Î»¡±¡¢°²»ÕÊ¡¡°ÖøÃûÉÌ±ê¡±¡¢°²»ÕÊ¡¡°ÃûÅÆ²úÆ·¡±¡¢¡°ÆóÒµ½ø³ö¿Ú×Ê¸ñÖ¤¡±¡¢¡°CE¹ú¼ÊÈÏÖ¤¡±°²»ÕÊ¡Å©ÐÐ¡°AA+¼¶ÐÅÓÃÆóÒµ¡±¡¢°²»ÕÊ¡¡°ÓÅÐã³ÏÐÅÃñÓªÆóÒµ¡±¡¢°²»ÕÊ¡¡°³ÏÐÅµ¥Î»¡±¡¢¡°Âí°°É½ÊÐÏÈ½ø¼¯Ìå¡±¡¢¡°Âí°°É½ÊÐÓÅÐãË½ÓªÆóÒµ¡±¡¢¡°Âí°°É½ÊÐ³ÏÐÅÄÉË°ÈË¡±¡¢¡°Âí°°É½ÊÐÒøÐÐÐÅ´û³ÏÐÅÖÐÐ¡ÆóÒµ¡±¡¢¡°È«¹úÓÃ»§²úÆ·ÖÊÁ¿ÂúÒâ£¬ÊÛºó·þÎñÂúÒâÊ¾·¶µ¥Î»¡±¡¢¡°AAA¼¶ÖÊÁ¿³ÏÐÅ»áÔ±µ¥Î»¡±¡¢¡°ÖÐ¹úÖÊÁ¿¹ýÓ²·ÅÐÄÆ·ÅÆ¡±¡¢¡°ÖÐ¹úÊÐ³¡¹«ÈÏ³©ÏúÆ·ÅÆ¡±¡¢¡°È«¹ú»ú´²Ê®¼ÑÃûÓÅÆ·ÅÆ¡±µÈÈÙÓþ³ÆºÅ ¡¡¡¡È«ÌåÔ±¹¤ÒÔÏÈ½øµÄ¼¼ÊõºÍÏÖ´ú»¯µÄ¹ÜÀíÊÖ¶ÎÎª×·Çó²úÆ·µÄÍêÃÀ¶ø²»Ð¸Å¬Á¦¡£¹«Ë¾ÓÚ2001Äê10ÔÂÈ«ÃæÍ¨¹ýISO9001£º2000ÖÊÁ¿¹ÜÀíÌåÏµÈÏÖ¤£¬2003Äê8ÔÂÍ¨¹ýÁËÈý¼¶¼ÆÁ¿È·ÈÏ£¬ÓµÓÐ×ÔÓª½ø³ö¿ÚÈ¨£¬ÎªÌá¸ß²úÆ·¿Æ¼¼µÄº¬½ðÁ¿¼°²úÆ·ÐÔÄÜ£¬2003Äê12ÔÂ¹«Ë¾ÓëºÏ·Ê¹¤Òµ´óÑ§ºÏ×÷³ÉÁ¢ÁË¡°»ú´²¹¤³Ì¼¼ÊõÑÐ¾¿ÖÐÐÄ¡±¡£2004ÄêWF67KÊý¿Ø°åÁÏÕÛÍä»úÐÂÆ·Éú²úÏßÏîÄ¿±»È«Ê¡·¢Õ¹¸Ä¸ïÎ¯Ô±»áÅú×¼ÎªÊ¡¡°Èý¸ß¡±ÏîÄ¿£¬²¢±»ÁÐÈëÊ¡¡°861¡±¼Æ»®ÖØµã½¨ÉèÏîÄ¿¡£¹ú¼ÒÖÊÁ¿¼ìÑé¼ìÒß×Ü¾ÖÓÚ2006Äê9ÔÂ¶ÔÎÒ¹«Ë¾µÄQC12Y-4£ª3200ÒºÑ¹°ÚÊ½¼ô°å»ú½øÐÐÁË²úÆ·ÖÊÁ¿¹ú¼Ò¼à¶½³é²é¡£ÎÒ¹«Ë¾²úÆ·Ò»´ÎÐÔÍ¨¹ý¸÷ÏîÖ¸±ê¼ìÑé£¬³É¼¨È«²¿¸ñ£¨¼ìÑé±¨¸æ±àºÅ£ºDJ-1055-D01-Q£©¡£¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡ÈýÁ¦²úÆ·¾«ÒæÇó¾«£¬ÈýÁ¦ÈË½«²»¶Ï¿ªÍØ£¬²»¶Ï´´ÐÂ£¬²¢Õæ³ÏµØÔ¸Óë¸÷½çÅóÓÑÐ¯ÊÖ¹²½ø£¬¹²Í¬·¢Õ¹¡£
µ¥Î»£º°²»ÕÊ¡ÈýÁ¦»ú´²ÖÆÔìÓÐÏÞ¹«Ë¾
µç»°£º0555-6721249   ´«Õæ£º0555-6612848
www.cnjczz.com
sl at cnjczz.com

¡ª¡ª¡ª¡ª¡ª¡ª¡ª¡ª¡ª¡ª¡ª¡ª¡ª¡ª¡ª¡ª¡ª¡ª¡ª¡ª¡ª¡ª¡ª¡ª¡ª¡ª¡ª¡ª¡ª¡ª
¡¾×¢Òâ¡¿ÉÏÃæµÄÓÊ¼þÄÚÈÝÓëÒÔÏÂÎÄ×ÖÎÞ¹Ø¡£±¾Èí¼þ½öÏÞÓÚºÏ·¨ÓÃÍ¾!
¸ÃÓÊ¼þÓÉ¡¶VolleymailÓÊ¼þÈº·¢×¨¼Ò¡·Èí¼þ·¢ËÍ£»±»ÍøÓÑÆÀÎª×îÀ÷º¦
µÄÓÊ¼þÈº·¢Èí¼þ¶ø¶à´ÎÒªÇóÆÆ½â£¡ÏÖÃâ·ÑÏÂÔØ£¬ÎÞÏÞÊ±¼äÊ¹ÓÃ¡£
ÏêÇéÇë·ÃÎÊÎÒÃÇµÄÖ÷Ò³£ºhttp://www.cnysoft.com/",
    "header": Object {
      "date": 2007-11-12T07:34:53.000Z,
      "from": Object {
        "email": "sl@cnjczz.com",
        "name": "=?GB2312?B?sLK71cqhyP3Bprv6tLLWxtTs09DP3rmry74=?=",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=%2A%2A%2ASPAM%2A%2A%2A%0A%09%3D%3FGB2312%3FB%3FuanTpqO6vPSw5bv6oaLV283ku/qhor7tsOW7%2BqGis%2BW0sqGi0KPGvbv6%3F%3D&In-Reply-To=",
      "subject": "***SPAM***	=?GB2312?B?uanTpqO6vPSw5bv6oaLV283ku/qhor7tsOW7+qGis+W0sqGi0KPGvbv6?=",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004978.html",
  },
  Object {
    "body": "Hey Amanda,

Here's that fat loss pill site you asked about, the one I told you with the amazing Anatrim pills. Hey- if they're good enough for Oprah, then they must be good enough for us lol ;)

Check the site out and let me know later how they work for you, hope you lose as many pounds as I did! :)

http://www.rasev.cn/?ubxvsvwpt

Later babe xo

Dudley Galindo",
    "header": Object {
      "date": 2007-11-12T08:02:34.000Z,
      "from": Object {
        "email": "eggm@bondscpa.com",
        "name": "Dudley Galindo",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=%2A%2A%2ASPAM%2A%2A%2A%20Lean%20and%20mean%20is%20in%21%20&In-Reply-To=",
      "subject": "***SPAM*** Lean and mean is in!",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004979.html",
  },
  Object {
    "body": "The OpenAjax Alliance website (OpenAjax.Org) was recently hacked (a
phishing attack according to Jon Ferraiolo) and so I have let the group
use the domain http://OpenAjax.Com in it's place until everything is
worked out.

It seems GoDaddy has been very responsive, and the DNS is switched back, 
and the Alliance admins have both domains pointing to the correct
server, including my email. I do not know of the legal ramifications,
although Jon did mention he had contacted the FBI.

This makes it even more critical to push for stronger security.  This was
one of the more expensive OpenDomains I have donated, and I am extremely
upset that someone has stolen it.  I would appreciate it if everyone on
this list would be help the community become aware that if this could
happen to IBM, it can happen to them.

Thank you
Ric Johnson",
    "header": Object {
      "date": 2007-11-12T11:39:06.000Z,
      "from": Object {
        "email": "Cedric@OpenDomain.Org",
        "name": "Ric Johnson",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Security%20in%20ES4%20-%20%28OpenAjax%29&In-Reply-To=",
      "subject": "Security in ES4 - (OpenAjax)",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004980.html",
  },
  Object {
    "body": "Buy Must Have medications at Canada based pharmacy.
No prescription at all! Same quality! 
Save your money, buy pills immediately! 

http://nobwrb.crypufullewad.net/?95347636

We provide confidential and secure purchase!",
    "header": Object {
      "date": 2007-11-12T12:53:52.000Z,
      "from": Object {
        "email": "dwselbermachenm@selbermachen.de",
        "name": "Nell Champion",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=%2A%2A%2ASPAM%2A%2A%2A%20Medications%20that%20you%20need.&In-Reply-To=",
      "subject": "***SPAM*** Medications that you need.",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004981.html",
  },
  Object {
    "body": "Hi,

As I understand it the reason assignment to ReadOnly properties fails silently
is that there was no try-catch prior to ECMAScript 3. Could/will edition 4
require an exception to be thrown in strict mode?

Jonathan",
    "header": Object {
      "date": 2007-11-12T17:00:19.000Z,
      "from": Object {
        "email": "jwatt@jwatt.org",
        "name": "Jonathan Watt",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Assigning%20to%20ReadOnly%20properties&In-Reply-To=",
      "subject": "Assigning to ReadOnly properties",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004982.html",
  },
  Object {
    "body": "On Nov 12, 2007, at 9:00 AM, Jonathan Watt wrote:

> Hi,
>
> As I understand it the reason assignment to ReadOnly properties  
> fails silently
> is that there was no try-catch prior to ECMAScript 3.

Right. Netscape 2 reported a fatal error, but during ES1  
standardization we agreed to go with silence is (golden|deadly).

> Could/will edition 4 require an exception to be thrown in strict mode?

Overtly incompatible, also highly desirable. So opt-in versioning  
could enable this, but it's one more migration headache (see recent  
exchange between Mark Miller and myself). An alternative would be a  
pragma of some sort:

   use readonly error

or perhaps

   use readonly throw

We try to make pragmas more readable, sometimes with an extra word;  
not sure this is the best way to phrase it still, but the idea would  
be to enable throwing of a ReadOnlyError on assignment to a ReadOnly  
property. Comments?

/be",
    "header": Object {
      "date": 2007-11-12T17:05:21.000Z,
      "from": Object {
        "email": "brendan@mozilla.org",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Assigning%20to%20ReadOnly%20properties&In-Reply-To=473886A3.80800%40jwatt.org",
      "subject": "Assigning to ReadOnly properties",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004983.html",
  },
  Object {
    "body": "Brendan Eich wrote:
> On Nov 12, 2007, at 9:00 AM, Jonathan Watt wrote:
> 
>> Hi,
>>
>> As I understand it the reason assignment to ReadOnly properties  
>> fails silently
>> is that there was no try-catch prior to ECMAScript 3.
> 
> Right. Netscape 2 reported a fatal error, but during ES1  
> standardization we agreed to go with silence is (golden|deadly).
> 
>> Could/will edition 4 require an exception to be thrown in strict mode?
> 
> Overtly incompatible, also highly desirable. So opt-in versioning  
> could enable this, but it's one more migration headache (see recent  
> exchange between Mark Miller and myself). An alternative would be a  
> pragma of some sort:

I like the idea of a pragma more than opt-in versioning since it can be used
in-place, and (I guess) placed before and after a section of code to turn the
handling on then off again.

>    use readonly error
> 
> or perhaps
> 
>    use readonly throw
> 
> We try to make pragmas more readable, sometimes with an extra word;  
> not sure this is the best way to phrase it still, but the idea would  
> be to enable throwing of a ReadOnlyError on assignment to a ReadOnly  
> property. Comments?

Why not just:

  use ReadOnlyError

It's short, intuitive, and you don't need to remember whether it's \\"error\\" or
\\"throw\\" in the pragma. If you can use pragmas multiple times to toggle things on
and then off again, perhaps make it:

  use ReadOnlyError on

  // some code that should throw on assignment to ReadOnly properties

  use ReadOnlyError off

Ultimately, the ability to catch this class of error is more important to me
than the syntax to turn the feature on.

Jonathan",
    "header": Object {
      "date": 2007-11-12T17:34:56.000Z,
      "from": Object {
        "email": "jwatt@jwatt.org",
        "name": "Jonathan Watt",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Assigning%20to%20ReadOnly%20properties&In-Reply-To=297F8851-B173-4DB4-87AC-46CB325D2AD9%40mozilla.org",
      "subject": "Assigning to ReadOnly properties",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004984.html",
  },
  Object {
    "body": "It would be really nice to be able to search the mailing list archives.",
    "header": Object {
      "date": 2007-11-12T17:36:01.000Z,
      "from": Object {
        "email": "jwatt@jwatt.org",
        "name": "Jonathan Watt",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Searching%20the%20mailing%20list%20archives&In-Reply-To=",
      "subject": "Searching the mailing list archives",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004985.html",
  },
  Object {
    "body": "On Nov 12, 2007 9:05 AM, Brendan Eich <brendan at mozilla.org> wrote:
> [..], but the idea would
> be to enable throwing of a ReadOnlyError on assignment to a ReadOnly
> property. Comments?

Hi Brendan,

I'm glad to hear that this possibility is in scope. In the Caja spec, we write:

  \\\\item[Silent errors.] In JavaScript, various operations, such as setting a
  ReadOnly property, fail silently rather than throwing an error. Program
  logic then proceeds along normal control flow paths premised on the
  assumption that these operations succeeded, leading to inconsistency. To
  program defensively in the face of this hazard, every assignment would be
  followed by a \`\`\\\\emph{did it really happen?}'' test. This would render
  programs unreadable and unmaintainable. Where practical, Caja deviates from
  standard JavaScript by throwing an exception rather than failing silently.

For defensive consistency (as defined in my thesis) to be practical, I
believe this change is necessary. I also believe that defensive
consistency (or some close relative) is necessary for secure
programming. Caja goes to a lot of trouble to achieve this while
running on an ES3 platform. If ES4 made this change, it might make
Caja's future life easier.

-- 
Text by me above is hereby placed in the public domain

    Cheers,
    --MarkM",
    "header": Object {
      "date": 2007-11-12T17:40:17.000Z,
      "from": Object {
        "email": "erights@gmail.com",
        "name": "Mark Miller",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Assigning%20to%20ReadOnly%20properties&In-Reply-To=297F8851-B173-4DB4-87AC-46CB325D2AD9%40mozilla.org",
      "subject": "Assigning to ReadOnly properties",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004986.html",
  },
  Object {
    "body": "What is the scope of a pragma such as that? Is it just the current
lexical scope, like a \\"use namespace\\" statement, or does it change the
behaviour for the entire program? If it's the latter, isn't there a
compatibility problem between libraries? If it's the former, do you
anticipate that es4 programs will be littered with \\"use strict\\"
pragmas? Think Fortran and \\"implicit none\\"....

I assume this has been previously discussed, but I couldn't find it,
so apologies if that is the case.

Peter


On 11/12/07, Brendan Eich <brendan at mozilla.org> wrote:
> On Nov 12, 2007, at 9:00 AM, Jonathan Watt wrote:
>
> > Hi,
> >
> > As I understand it the reason assignment to ReadOnly properties
> > fails silently
> > is that there was no try-catch prior to ECMAScript 3.
>
> Right. Netscape 2 reported a fatal error, but during ES1
> standardization we agreed to go with silence is (golden|deadly).
>
> > Could/will edition 4 require an exception to be thrown in strict mode?
>
> Overtly incompatible, also highly desirable. So opt-in versioning
> could enable this, but it's one more migration headache (see recent
> exchange between Mark Miller and myself). An alternative would be a
> pragma of some sort:
>
>    use readonly error
>
> or perhaps
>
>    use readonly throw
>
> We try to make pragmas more readable, sometimes with an extra word;
> not sure this is the best way to phrase it still, but the idea would
> be to enable throwing of a ReadOnlyError on assignment to a ReadOnly
> property. Comments?
>
> /be
>
> _______________________________________________
> Es4-discuss mailing list
> Es4-discuss at mozilla.org
> https://mail.mozilla.org/listinfo/es4-discuss
>",
    "header": Object {
      "date": 2007-11-12T18:18:49.000Z,
      "from": Object {
        "email": "peter.hall@memorphic.com",
        "name": "Peter Hall",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Pragmas&In-Reply-To=",
      "subject": "Pragmas",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004987.html",
  },
  Object {
    "body": "Pragmas are invariably lexically scoped.

Some pragmas are probably more useful at the top level, \\"use strict\\"
is among these.  One pattern we think might develop is  \\"use strict\\"
at the top level, followed by \\"use standard\\" inside some blocks where
strict mode gets in the way (if only temporarily during program
development).

--lars

On Nov 12, 2007 10:18 AM, Peter Hall <peter.hall at memorphic.com> wrote:
> What is the scope of a pragma such as that? Is it just the current
> lexical scope, like a \\"use namespace\\" statement, or does it change the
> behaviour for the entire program? If it's the latter, isn't there a
> compatibility problem between libraries? If it's the former, do you
> anticipate that es4 programs will be littered with \\"use strict\\"
> pragmas? Think Fortran and \\"implicit none\\"....
>
> I assume this has been previously discussed, but I couldn't find it,
> so apologies if that is the case.
>
> Peter
>
>
> On 11/12/07, Brendan Eich <brendan at mozilla.org> wrote:
> > On Nov 12, 2007, at 9:00 AM, Jonathan Watt wrote:
> >
> > > Hi,
> > >
> > > As I understand it the reason assignment to ReadOnly properties
> > > fails silently
> > > is that there was no try-catch prior to ECMAScript 3.
> >
> > Right. Netscape 2 reported a fatal error, but during ES1
> > standardization we agreed to go with silence is (golden|deadly).
> >
> > > Could/will edition 4 require an exception to be thrown in strict mode?
> >
> > Overtly incompatible, also highly desirable. So opt-in versioning
> > could enable this, but it's one more migration headache (see recent
> > exchange between Mark Miller and myself). An alternative would be a
> > pragma of some sort:
> >
> >    use readonly error
> >
> > or perhaps
> >
> >    use readonly throw
> >
> > We try to make pragmas more readable, sometimes with an extra word;
> > not sure this is the best way to phrase it still, but the idea would
> > be to enable throwing of a ReadOnlyError on assignment to a ReadOnly
> > property. Comments?
> >
> > /be
> >
> > _______________________________________________
> > Es4-discuss mailing list
> > Es4-discuss at mozilla.org
> > https://mail.mozilla.org/listinfo/es4-discuss
> >
> _______________________________________________
> Es4-discuss mailing list
> Es4-discuss at mozilla.org
> https://mail.mozilla.org/listinfo/es4-discuss
>",
    "header": Object {
      "date": 2007-11-12T18:24:54.000Z,
      "from": Object {
        "email": "lth@acm.org",
        "name": "Lars T Hansen",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Pragmas&In-Reply-To=9ac110a90711121018j4f0400c0nf4b5fd3bc5e6ed05%40mail.gmail.com",
      "subject": "Pragmas",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004988.html",
  },
  Object {
    "body": "Also, there is a minor bug [1] with the pragma syntax:

Pragma :
	UsePragma  SemicolonFull
	ImportPragma  SemicolonFull
	
UsePragma :
	use  PragmaItems  SemicolonFull


resulting in two semicolons being required after a \\"use\\" pragma.


Peter


[1] http://wiki.ecmascript.org/doku.php?id=proposals:syntax_for_pragmas





On 11/12/07, Peter Hall <peter.hall at memorphic.com> wrote:
> What is the scope of a pragma such as that? Is it just the current
> lexical scope, like a \\"use namespace\\" statement, or does it change the
> behaviour for the entire program? If it's the latter, isn't there a
> compatibility problem between libraries? If it's the former, do you
> anticipate that es4 programs will be littered with \\"use strict\\"
> pragmas? Think Fortran and \\"implicit none\\"....
>
> I assume this has been previously discussed, but I couldn't find it,
> so apologies if that is the case.
>
> Peter
>
>
> On 11/12/07, Brendan Eich <brendan at mozilla.org> wrote:
> > On Nov 12, 2007, at 9:00 AM, Jonathan Watt wrote:
> >
> > > Hi,
> > >
> > > As I understand it the reason assignment to ReadOnly properties
> > > fails silently
> > > is that there was no try-catch prior to ECMAScript 3.
> >
> > Right. Netscape 2 reported a fatal error, but during ES1
> > standardization we agreed to go with silence is (golden|deadly).
> >
> > > Could/will edition 4 require an exception to be thrown in strict mode?
> >
> > Overtly incompatible, also highly desirable. So opt-in versioning
> > could enable this, but it's one more migration headache (see recent
> > exchange between Mark Miller and myself). An alternative would be a
> > pragma of some sort:
> >
> >    use readonly error
> >
> > or perhaps
> >
> >    use readonly throw
> >
> > We try to make pragmas more readable, sometimes with an extra word;
> > not sure this is the best way to phrase it still, but the idea would
> > be to enable throwing of a ReadOnlyError on assignment to a ReadOnly
> > property. Comments?
> >
> > /be
> >
> > _______________________________________________
> > Es4-discuss mailing list
> > Es4-discuss at mozilla.org
> > https://mail.mozilla.org/listinfo/es4-discuss
> >
>",
    "header": Object {
      "date": 2007-11-12T18:25:51.000Z,
      "from": Object {
        "email": "peter.hall@memorphic.com",
        "name": "Peter Hall",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Pragmas&In-Reply-To=9ac110a90711121018j4f0400c0nf4b5fd3bc5e6ed05%40mail.gmail.com",
      "subject": "Pragmas",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004989.html",
  },
  Object {
    "body": "Got it. Thanks!

Jd


On 11/12/07 10:25 AM, Peter Hall wrote:

> Also, there is a minor bug [1] with the pragma syntax:
> 
> Pragma :
> UsePragma  SemicolonFull
> ImportPragma  SemicolonFull
> 
> UsePragma :
> use  PragmaItems  SemicolonFull
> 
> 
> resulting in two semicolons being required after a \\"use\\" pragma.
> 
> 
> Peter
> 
> 
> [1] http://wiki.ecmascript.org/doku.php?id=proposals:syntax_for_pragmas
> 
> 
> 
> 
> 
> On 11/12/07, Peter Hall <peter.hall at memorphic.com> wrote:
>> What is the scope of a pragma such as that? Is it just the current
>> lexical scope, like a \\"use namespace\\" statement, or does it change the
>> behaviour for the entire program? If it's the latter, isn't there a
>> compatibility problem between libraries? If it's the former, do you
>> anticipate that es4 programs will be littered with \\"use strict\\"
>> pragmas? Think Fortran and \\"implicit none\\"....
>> 
>> I assume this has been previously discussed, but I couldn't find it,
>> so apologies if that is the case.
>> 
>> Peter
>> 
>> 
>> On 11/12/07, Brendan Eich <brendan at mozilla.org> wrote:
>>> On Nov 12, 2007, at 9:00 AM, Jonathan Watt wrote:
>>> 
>>>> Hi,
>>>> 
>>>> As I understand it the reason assignment to ReadOnly properties
>>>> fails silently
>>>> is that there was no try-catch prior to ECMAScript 3.
>>> 
>>> Right. Netscape 2 reported a fatal error, but during ES1
>>> standardization we agreed to go with silence is (golden|deadly).
>>> 
>>>> Could/will edition 4 require an exception to be thrown in strict mode?
>>> 
>>> Overtly incompatible, also highly desirable. So opt-in versioning
>>> could enable this, but it's one more migration headache (see recent
>>> exchange between Mark Miller and myself). An alternative would be a
>>> pragma of some sort:
>>> 
>>>    use readonly error
>>> 
>>> or perhaps
>>> 
>>>    use readonly throw
>>> 
>>> We try to make pragmas more readable, sometimes with an extra word;
>>> not sure this is the best way to phrase it still, but the idea would
>>> be to enable throwing of a ReadOnlyError on assignment to a ReadOnly
>>> property. Comments?
>>> 
>>> /be
>>> 
>>> _______________________________________________
>>> Es4-discuss mailing list
>>> Es4-discuss at mozilla.org
>>> https://mail.mozilla.org/listinfo/es4-discuss
>>> 
>> 
> _______________________________________________
> Es4-discuss mailing list
> Es4-discuss at mozilla.org
> https://mail.mozilla.org/listinfo/es4-discuss",
    "header": Object {
      "date": 2007-11-12T18:29:10.000Z,
      "from": Object {
        "email": "jodyer@adobe.com",
        "name": "Jeff Dyer",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Pragmas&In-Reply-To=9ac110a90711121025w18422f6bna2306599d0cda2b8%40mail.gmail.com",
      "subject": "Pragmas",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004990.html",
  },
  Object {
    "body": "On the surface, that sounds like it makes sense. But if I'm writing an
application in strict mode, that uses a pre-existing library, will I
have to edit that library to add \\"use standard\\" to every file?

\\"Inheriting\\" the pragma is not straightforward unless you inherit only
from the program entry point. After that, it doesn't seem possible to
derive a well-defined ancestry tree, since source code may be
referenced from many different locations, often cyclically.

Peter


On 11/12/07, Lars T Hansen <lth at acm.org> wrote:
> Pragmas are invariably lexically scoped.
>
> Some pragmas are probably more useful at the top level, \\"use strict\\"
> is among these.  One pattern we think might develop is  \\"use strict\\"
> at the top level, followed by \\"use standard\\" inside some blocks where
> strict mode gets in the way (if only temporarily during program
> development).
>
> --lars
>
> On Nov 12, 2007 10:18 AM, Peter Hall <peter.hall at memorphic.com> wrote:
> > What is the scope of a pragma such as that? Is it just the current
> > lexical scope, like a \\"use namespace\\" statement, or does it change the
> > behaviour for the entire program? If it's the latter, isn't there a
> > compatibility problem between libraries? If it's the former, do you
> > anticipate that es4 programs will be littered with \\"use strict\\"
> > pragmas? Think Fortran and \\"implicit none\\"....
> >
> > I assume this has been previously discussed, but I couldn't find it,
> > so apologies if that is the case.
> >
> > Peter
> >
> >
> > On 11/12/07, Brendan Eich <brendan at mozilla.org> wrote:
> > > On Nov 12, 2007, at 9:00 AM, Jonathan Watt wrote:
> > >
> > > > Hi,
> > > >
> > > > As I understand it the reason assignment to ReadOnly properties
> > > > fails silently
> > > > is that there was no try-catch prior to ECMAScript 3.
> > >
> > > Right. Netscape 2 reported a fatal error, but during ES1
> > > standardization we agreed to go with silence is (golden|deadly).
> > >
> > > > Could/will edition 4 require an exception to be thrown in strict mode?
> > >
> > > Overtly incompatible, also highly desirable. So opt-in versioning
> > > could enable this, but it's one more migration headache (see recent
> > > exchange between Mark Miller and myself). An alternative would be a
> > > pragma of some sort:
> > >
> > >    use readonly error
> > >
> > > or perhaps
> > >
> > >    use readonly throw
> > >
> > > We try to make pragmas more readable, sometimes with an extra word;
> > > not sure this is the best way to phrase it still, but the idea would
> > > be to enable throwing of a ReadOnlyError on assignment to a ReadOnly
> > > property. Comments?
> > >
> > > /be
> > >
> > > _______________________________________________
> > > Es4-discuss mailing list
> > > Es4-discuss at mozilla.org
> > > https://mail.mozilla.org/listinfo/es4-discuss
> > >
> > _______________________________________________
> > Es4-discuss mailing list
> > Es4-discuss at mozilla.org
> > https://mail.mozilla.org/listinfo/es4-discuss
> >
> _______________________________________________
> Es4-discuss mailing list
> Es4-discuss at mozilla.org
> https://mail.mozilla.org/listinfo/es4-discuss
>",
    "header": Object {
      "date": 2007-11-12T18:38:10.000Z,
      "from": Object {
        "email": "peter.hall@memorphic.com",
        "name": "Peter Hall",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Pragmas&In-Reply-To=12c6978a0711121024r471960d8ma1fab0b034923c4%40mail.gmail.com",
      "subject": "Pragmas",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004991.html",
  },
  Object {
    "body": "On Nov 12, 2007, at 9:34 AM, Jonathan Watt wrote:

> I like the idea of a pragma more than opt-in versioning since it  
> can be used
> in-place, and (I guess) placed before and after a section of code  
> to turn the
> handling on then off again.

Pragmas are block-scoped, so just one should do.

>>    use readonly error
>>
>> or perhaps
>>
>>    use readonly throw
>>
>> We try to make pragmas more readable, sometimes with an extra word;
>> not sure this is the best way to phrase it still, but the idea would
>> be to enable throwing of a ReadOnlyError on assignment to a ReadOnly
>> property. Comments?
>
> Why not just:
>
>   use ReadOnlyError

Sure -- pragma convention so far  has been terse and lower-case, e.g.  
'use strict' or 'use decimal ...'.

> It's short, intuitive, and you don't need to remember whether it's  
> \\"error\\" or
> \\"throw\\" in the pragma. If you can use pragmas multiple times to  
> toggle things on
> and then off again, perhaps make it:
>
>   use ReadOnlyError on
>
>   // some code that should throw on assignment to ReadOnly properties
>
>   use ReadOnlyError off

I'm going to summon Jeff Dyer here.

> Ultimately, the ability to catch this class of error is more  
> important to me
> than the syntax to turn the feature on.

Indeed, but syntax is necessary and we may as well hash it out here.

Speaking of catching, it would be unfortunate if you wrote

   try { something that might set a ReadOnly property }
   catch (e : ReadOnlyError) { ... }

but forgot the pragma, and never heard a word of warning. There are  
no warnings in the spec, so normative error seems best. But if you're  
bothering to catch ReadOnlyError, must you also 'use ReadOnlyError'  
first (in the try, or in a block enclosing the whole try-catch)?

The pragma is necessary, since you may want termination semantics  
(use ReadOnlyError w/o ever catching that exception). But if you do  
catch, must you use as well? I'm throwing this out for some quick  
discussion. Thanks for posting about ReadOnly errors, I had it on my  
to-do list but you beat me to it :-).

/be",
    "header": Object {
      "date": 2007-11-12T19:26:32.000Z,
      "from": Object {
        "email": "brendan@mozilla.org",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Assigning%20to%20ReadOnly%20properties&In-Reply-To=47388EC0.90601%40jwatt.org",
      "subject": "Assigning to ReadOnly properties",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004992.html",
  },
  Object {
    "body": "On Nov 12, 2007, at 9:40 AM, Mark Miller wrote:

> On Nov 12, 2007 9:05 AM, Brendan Eich <brendan at mozilla.org> wrote:
>> [..], but the idea would
>> be to enable throwing of a ReadOnlyError on assignment to a ReadOnly
>> property. Comments?
>
> Hi Brendan,
>
> I'm glad to hear that this possibility is in scope.

Me too -- this was one of the biggest botches during standardization  
of ES1, and it should have been revisited when exception handling was  
added in ES3.

> In the Caja spec, we write:
>
>   \\\\item[Silent errors.] In JavaScript, various operations, such as  
> setting a
>   ReadOnly property, fail silently rather than throwing an error.  
> Program
>   logic then proceeds along normal control flow paths premised on the
>   assumption that these operations succeeded, leading to  
> inconsistency. To
>   program defensively in the face of this hazard, every assignment  
> would be
>   followed by a \`\`\\\\emph{did it really happen?}'' test. This would  
> render
>   programs unreadable and unmaintainable. Where practical, Caja  
> deviates from
>   standard JavaScript by throwing an exception rather than failing  
> silently.
>
> For defensive consistency (as defined in my thesis) to be practical, I
> believe this change is necessary. I also believe that defensive
> consistency (or some close relative) is necessary for secure
> programming. Caja goes to a lot of trouble to achieve this while
> running on an ES3 platform. If ES4 made this change, it might make
> Caja's future life easier.

This may have been what I was thinking of when I wrote \\"incompatible  
subset\\" the other week, now that you mention it. Syntactically Caja  
is a subset of ES3, but the runtime semantics not only add  
capabilities, they make even programs that are running in a single  
trust label world, and that blithely continue past an attempt to set  
a ReadOnly property in ES3, stop cold instead. As any sane runtime  
semantics should!

We could just \\"make this change\\" if ES4 is selected. But ES4 already  
makes Object, Array, etc. ReadOnly|DontDelete bindings in the global  
object, necessary for sound typing, JSON defense in depth, etc. We  
reckoned any AOP on these constructor functions was rare compared to  
AOP on prototype methods (a spider of the web confirmed this; only an  
old MSN .js file hacked Error for some reason). And it's not as if  
ES1-3 provide for consistent AOP on the global constructor functions  
anway:

http://wiki.ecmascript.org/doku.php?id=clarification:which_prototype

Therefore ES4 making the standard constructors bound by immutable  
global properties is one of the two true incompatibilities mentioned in

http://www.ecmascript.org/es4/spec/incompatibilities.pdf

and we think it won't break the web, since the situation in real  
browsers is inconsistent, not only per ES3's wild inconsistencies,  
but because some browsers more than others avoid reflecting on  
current values of the mutable bindings in spite of ES3 specifying  
that sporadically.

If some script somewhere does set Error = MyError, though, the  
silence-is-golden behavior will let that pass without exception in  
today's implementations. So changing ES4 to throw ReadOnlyError will  
\\"break\\" what might have been benignly broken already. Not sure this  
is going to cause hardship, or that it should *not* cause hardship.  
You could argue that it's better to find out sooner than later. But  
the costs may be born by browser users, not web developers, since the  
content was written in 2002, the team that wrote it is long gone, and  
no one helpful is reading hostmaster at bigcompany.com.

If we instead add a pragma to enable ReadOnlyError, that would still  
help Caja at some point, right?

/be",
    "header": Object {
      "date": 2007-11-12T20:39:28.000Z,
      "from": Object {
        "email": "brendan@mozilla.org",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Assigning%20to%20ReadOnly%20properties&In-Reply-To=fee0a56d0711120940v7f671d58xe98c26a220cd9cf7%40mail.gmail.com",
      "subject": "Assigning to ReadOnly properties",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004993.html",
  },
  Object {
    "body": "Responding to 2 emails here...

On Nov 12, 2007 12:35 AM, Brendan Eich <brendan at mozilla.org> wrote:

> On Nov 11, 2007, at 4:26 PM, Brendan Eich wrote:
>
> > Part of the thinking in
> > resolving #103 in favor of type expression on right of 'is' was to
> > future-proof against a world where type and value expressions are
> > combined somehow. I don't believe that world will come to pass,
> > though. If it should, sooner is better. Restricting 'is' as #103-as-
> > resolved did isn't making anyone too happy right now :-/.
>
> Of course, Lars cut the Gordian knot in email just a bit later today:
>
>   type T
>   var v
>
>   x is T               // if T is type then the compiler knows that,
>                        // otherwise next case applies
>   x is v               // reflect::typeOf(x).isSubtypeOf(v)
>                        // fails if v not a Type object
>   x is { ... }         // interpret as record type
>   x is [ ... ]         // interpret as array type
>   x is ( ... )         // interpret as union type
>   x is function ...    // interpret as function type
>   x is null            // interpret as null type
>   x is undefined       // interpret as undefined type
>   x is like T          // T must be a type expression anyhow
>
> This allows arbitrary value expressions on the right of 'is', just so
> long as they don't look like type expressions in their leftmost
> token. Everyone wins. Yay?
>
> /be


Definitely like it. I wonder how convoluted the grammar change was - did it
require a new value_expr_no_conflicts_with_type_expr production and all
related productions/rules?

I don't want to rain on the parade, but I have some worries on how it would
impact an upgraded |instanceof|. More below.

On Nov 12, 2007 1:04 AM, Brendan Eich <brendan at mozilla.org> wrote:

> On Nov 11, 2007, at 10:41 PM, Yuh-Ruey Chen wrote:
>
> >> The key difference is that
> >> instanceof results can change over time for a given object on the
> >> left and plain old function on the right, while 'is' results cannot
> >> vary over the lifetimes of the same operands.
> >
> > If |is| is a purely runtime check, does this really matter? Can you
> > give
> > me a use case involving a runtime type check that requires that the
> > type
> > check always be the same for a pair of operands?
>
> Your poor-man's type parameters example will do. The 'is' operator is
> how you write an expression testing subtype, and the : type
> annotation colon enforces subtype relation for all writes to the
> annotated slot. So 'is' and annotations are closely related (ignore
> the hardcoded conversions within AnyString, AnyNumber, and AnyBoolean
> respectively).


I see - I was thinking that it was a technical limitation - but apparently
not. You've convinced me that pairing the semantics of |is| and type
notations is just as important, if not more, as pairing the syntax of |is|
and |instanceof|, so I'll drop the attempt to unify |is| and |instanceof|.


> > Ok, thanks for the clarification. However, that still doesn't answer
> > this question: if the |x| in |type x| has to be a type expr, then how
> > did |type x| in the example work? |x| in that case was a value expr
> > (evaluating to a meta-object), not a type expr.
>
> Maybe that was just a mistake :-).
>

Doh!


> > FYI, I'm not really in favor of merging to the two operators. I do
> > recognize that there is a fundamental difference between the
> > |instanceof| test and the |is| test. But I could also say that
> > there is
> > a fundamental difference between the |is| test and the |is like| test.
>
> Remember, nothing special goes on with 'is like'. Imagine explicit
> parenthese (not allowed because they mean union type, but pretend):
>
>   x is T
>   x is (like T)
>
> We know this must be the case since you could have defined
>
>   type T = like U
>
> before the first line (x is T), and the result should be the same as
> if you expanded the typename:
>
>   x is like U
>

I'm aware that |like| is an unary type operator that can be used outside of
|is| exprs. It's just more convenient to write |is like| instead of \\"|is|
composed with |like|\\" :)


> > Yeah, misunderstood you. I can see now that record types are like
> > undeclared interfaces.
>
> Not sure if you meant anonymous interfaces, but interfaces can have
> only methods, which can be overridden along the inheritance chain in
> the nominal type system. Structural types on the other hand describe
> records with fields -- not methods, although a field's type could be
> a function structural type.
>
> Bottom line: interfaces != structural object types.
>

Yeah, I meant \\"anonymous interfaces\\". I know they're not the same as
interfaces, but they're similar in that they place a set of restrictions or
guarantees on a class or object that \\"implements\\" them.


> > However, as I noted before, the |like| test for
> > structural types is still a different beast.
>
> There's a possible generalization of 'like' to accept any type on its
> right (conversion is not an issue: http://bugs.ecmascript.org/ticket/
> 258). Remember, no non-compositional special cases or ad-hoc patches,
> if we can avoid 'em.


I think that would be a good thing. Another thought: if |x is v|, where |v|
is a meta-object, works, then one would think that it should also work for
|like|, e.g.

var x = int
10 is x; // ok
10 is like x; // ?

But if that last statement is allowed, then so is |var y: like x|, which is
undecidable (if that's the correct term), so evidently |like| shouldn't work
with value exprs.

Might want to mention this in any clarification you put into the spec, even
if it's strictly disallowed in the formal grammar - that even though |is|
allows a value expr on the right side, it cannot be nested within a type
expr. That means given |var x|, none of |10 is like x|, |10 is (x)|, |10 is
{p: x}|, etc. are syntactically allowed.


> > A thought: If the |type| operator can accept a value expr that
> > resolves
> > to a meta-object and returns that meta-object, then |type| can be
> > chained, e.g. |type type type T| is equivalent to |type T|. In this
> > way,
> > a user that's unsure if a particular type expression is ambigious can
> > just prefix it with |type| without worries.
>
> But the parser (not optional strict mode, the fundamental grammar)
> will reject a non-type expression (if we want it to). This is a case
> of load/edit/reload at worst.


Okay, this proposal stemmed from the error in your previous example, in
which you had |type x| where |x| was a value expr resolving to a
meta-object. I was thinking that if |type| could already recognize both
value exprs evaluating to meta-objects and type exprs, then it would be
trivial to implement this. Whether it is needed or not...see below.


> But hey, I'm jazzed by Lars's \\"have our cake and eat it\\" proposal for
> 'is'. For instanceof, we could do what you and I seem to be talking
> about: extend it to do what 'is' does, with the gravy that its right
> operand is always a value expression. So 'instanceof' could be used
> to handle all kinds of instantiation, ES3 mutable-prototype function
> constructors and ES4 types. Comments?
>
> /be
>

There are couple potential problems with upgrading |instanceof| to match the
syntax of the revised |is|:

1) Function expr syntax ambiguity. Consider:

a) x is function(p: int): int // ok
b) x is function(p: int): int {} // syntax error
c) x instanceof function(p: int): int // ok?
d) x instanceof function(p: int): int {} // syntax error?

Will it try to parse the |function ...| in (c)/(d) as a function expr or a
function type? (d), ignoring the type annotations, is currently legal in ES3
and is pretty much guaranteed to resolve to false. In the upgraded
|instanceof| however, if |function ...| is interpreted as a type, it would
be a syntax error. On the other hand, if |function ...| is interpreted as a
function expr, (c) would be a syntax error and it |instanceof| would no
longer match |is|. So treating |function ...| as a type will be backwards
compatible, but the compat issue is so minor (who the heck would do (d)?)
that I wouldn't mind it.

2) Object literal syntax ambiguity. If it is possible to simulate a
constructor with an object literal, namely creating an object with
[[HasInstance]], we'll have a similar situation to (1). I'm not sure if it's
possible, so I'll make up some syntax in the following example to indicate
what I mean:

x instanceof {meta::construct: function() {}}

That object literal is supposed to create a constructor-like object, but
like I said, I'm not sure if it's really possible and of the exact syntax
required. Anyway, that |{...}| is ambiguous in that it can either be treated
as a record structural type or an object literal. In ES3, there's no way to
create a constructor from an object literal (AFAIK), so the above syntax
(ignoring the namespace) would be a runtime error. Thus, there is no
backwards compat issue. If it were allowed in ES3, as before, it is
guaranteed to resolve to false. So the |{...}| should be treated as a record
structural type.

3) Parenthesis ambiguity. This is the most troublesome one. Consider:

a) x is (int) // ok
b) x is (some_constructor) // syntax error
c) x is ({p: int}) // ok
d) x instanceof (int) // ok
e) x instanceof (some_constructor) // syntax error?
f) x instanceof ({p: int}) // how should this be treated?

(e) is currently allowed in ES3, and unlike the the function expr ambiguity,
|(some_constructor)| is meaningful. That means it must be allowed in ES4 for
backwards compatibility. However, to match |is|, |(...)| must be treated as
a union type. And whether |(...)| is treated as a union type or a value
parens expr really matters as shown in (f). I'm stumped.

If we really want to upgrade |instanceof| yet keep it coherent with |is| in
both semantics and syntax, we may have to visit the |type| operator again,
but that should be a last resort.

-Yuh-Ruey Chen
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://mail.mozilla.org/pipermail/es-discuss/attachments/20071112/6dccca0b/attachment-0002.html",
    "header": Object {
      "date": 2007-11-12T21:40:14.000Z,
      "from": Object {
        "email": "maian330@gmail.com",
        "name": "YR Chen",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=need%20some%20clarification%20on%20compile-time%20type%20vs.%20run-time%20type&In-Reply-To=9F3A0B44-6D2C-4158-B8E6-7A252CA0D9B2%40mozilla.org",
      "subject": "need some clarification on compile-time type vs. run-time type",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004994.html",
  },
  Object {
    "body": "On Nov 12, 2007 11:40 AM, Mark Miller <erights at gmail.com> wrote:

> On Nov 12, 2007 9:05 AM, Brendan Eich <brendan at mozilla.org> wrote:
> > [..], but the idea would
> > be to enable throwing of a ReadOnlyError on assignment to a ReadOnly
> > property. Comments?
>
> Hi Brendan,
>
> I'm glad to hear that this possibility is in scope. In the Caja spec, we
> write:
>
>  \\\\item[Silent errors.] In JavaScript, various operations, such as setting
> a
>  ReadOnly property, fail silently rather than throwing an error. Program
>  logic then proceeds along normal control flow paths premised on the
>  assumption that these operations succeeded, leading to inconsistency.


Out of curiosity, what other JS operations fail silently?

-Yuh-Ruey Chen
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://mail.mozilla.org/pipermail/es-discuss/attachments/20071112/6c76658d/attachment-0002.html",
    "header": Object {
      "date": 2007-11-12T21:43:47.000Z,
      "from": Object {
        "email": "maian330@gmail.com",
        "name": "YR Chen",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Assigning%20to%20ReadOnly%20properties&In-Reply-To=fee0a56d0711120940v7f671d58xe98c26a220cd9cf7%40mail.gmail.com",
      "subject": "Assigning to ReadOnly properties",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004995.html",
  },
  Object {
    "body": "Personally, I'm still mixed on the introduction of the whole nominal type
system with classes and whatnot. I'm very sympathetic to views that ES4
should concentrate on ES3's weak points. At times, I feel that ES3 is just
too \\"alien\\" a base to build the \\"programming in the large\\" features that ES4
advocates on to. Like fitting a square peg into a circle.

Nonetheless, I see that languages based on the old ES4 draft (2002?) that
have been successful, namely ActionScript. I'm not very familiar with it,
but the overall feeling I get from ppl developing in AS is positive. I also
want to get my hands dirty testing out classes in ES4, but sadly the RI is
too buggy at the moment. Basically, what I'm saying is, I'm willing to give
the Java-esque type system a chance.

With that said, some of your ideas are interesting, such as multiple
prototypes. I imagine, however, that that would slightly less efficient, and
more importantly, result in similar problems to multiple inheritance (think
diamond inheritance issues). I would like to know how Self handled that
issue.

Macros have been proposed and discussed before - they're somewhere on the
wiki. AFAIK, they've been deferred to a future ES5.

-Yuh-Ruey Chen

On Nov 8, 2007 1:28 PM, Peter Michaux <petermichaux at gmail.com> wrote:

> I've been reading the blogs and fuss over the the ES4 proposal. It
> seems to me that if ES3 was so horribly inadequate then big changes to
> the language would be welcomed unanimously. It must be that ES3 is
> sufficient to get by well enough that we have the luxury to argue
> about the worth of the proposed changes.
>
> Was incremental change to the ES3 language ever considered at the
> beginning of the process for ES4? It seems there are many places where
> the ES3 language could be improved without changing it's character (ie
> adding classes). If ES was developed in a hurry then perhaps there was
> plenty of room to strengthen the paradigms it already contains. If
> work had continued on ES immediately after ES3 was released, isn't
> that what would have happened?
>
> There are things that cannot be done with ES3 that could be added...
>
> Could the Self aspect of ES be strengthened? For example, more control
> over prototypes and the prototype chain would make programming with
> that model of inheritance a stronger competitor to class-based
> inheritance. The read/write __proto__ property could be standardized.
> Objects could have multiple prototypes like in Self. A obj.clone()
> function.
>
> Could the Scheme aspect of ES be strengthened? Tail recursion and let
> statements seem like good additions. What about macros? Please!
>
> Binary download for hiding code seems to be something people have been
> trying to achieve through obfuscation but cannot truly do with ES3.
>
> Complete support for secure mash-ups seems essential and not just
> because Douglas Crockford says so. Developers want to mash-up and are
> doing it now even with the security risks to their unknowing users.
>
> Adding types, classes and interfaces is drawing inspiration from
> languages with other models of programming. The new look of ES4 is
> very Java-like. Are the screams from the Java programmers enough to
> control the future of ES? Adding these constructs seems like an
> attempt to try to please everyone. This is the classic anti-pattern in
> marketing.
>
> There is an argument that the changes in ES4 are needed for the open
> web to keep up with rich platforms like Flash and Silverlight. As far
> as snazzy, sparkley user interfaces go, the ES3 language isn't the
> problem here but rather it is HTML, the DOM and CSS. Even if Internet
> Explorer and all browsers suddenly implemented these other standards
> correctly an HTML/JavaScript/CSS page wouldn't be very impressive
> compared with a Flash animation. I gulped last weekend when I saw a
> friend's flash portfolio with sound, video and vector graphics and
> then thought about my rectangular tabbed panes and drop down menus. I
> won't be able to do any of the Flash-like stuff with ES4. This
> paragraph isn't intended as an argument against changing ES but I
> don't think change to ES should be justified by the \\"keeping up\\"
> argument.
>
> Has ES3 proven itself to be such a disaster that trying to improve it
> incrementally while retaining its character is obviously the wrong
> choice? Was ES founded on such poor choices (Self and Scheme) that we
> should be moving to completely different style of programming (Java)?
>
> I wouldn't be writing this email had others not spoken up. It seems
> somewhat inappropriate and rude to speak against what Brendan Eich is
> proposing since it is his language.
>
> Peter
> _______________________________________________
> Es4-discuss mailing list
> Es4-discuss at mozilla.org
> https://mail.mozilla.org/listinfo/es4-discuss
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://mail.mozilla.org/pipermail/es-discuss/attachments/20071112/dcf95956/attachment-0002.html",
    "header": Object {
      "date": 2007-11-12T21:56:46.000Z,
      "from": Object {
        "email": "maian330@gmail.com",
        "name": "YR Chen",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Is%20ES3%20good%20enough%3F%20Was%20incrementally%20strengthening%20ES3%20paradigms%0A%09considered%3F&In-Reply-To=3cbaf1c80711081128rb9de0beta63e490cf7e3b2d2%40mail.gmail.com",
      "subject": "Is ES3 good enough? Was incrementally strengthening ES3 paradigms	considered?",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004996.html",
  },
  Object {
    "body": "On Nov 12, 2007 3:56 PM, YR Chen <maian330 at gmail.com> wrote:

> I'm very sympathetic to views that ES4 should concentrate on ES3's weak
> points.


Oops, I meant that strong points, not weak points.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://mail.mozilla.org/pipermail/es-discuss/attachments/20071112/cbe372e4/attachment-0002.html",
    "header": Object {
      "date": 2007-11-12T21:57:42.000Z,
      "from": Object {
        "email": "maian330@gmail.com",
        "name": "YR Chen",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Is%20ES3%20good%20enough%3F%20Was%20incrementally%20strengthening%20ES3%20paradigms%0A%09considered%3F&In-Reply-To=9154babf0711121356v4f06daf8ocaa0fe0ca0c8fab%40mail.gmail.com",
      "subject": "Is ES3 good enough? Was incrementally strengthening ES3 paradigms	considered?",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004997.html",
  },
  Object {
    "body": "Hello all,

Thank you for adding me to this list.

I have just finished reading the language proposal spec, and was  
struck by the richness of the additions to the language. I haven't  
been following this effort at all; and so thank people in advance for  
their patience with my ignorance. Now that I've seen the spec, there  
are two more documents that would really help my understanding:

I was wondering if there exists a document that sets out the language  
design goals and the connection between each feature and the goals it  
supports? In my mind's eye, I picture a table of goals along one axis,  
and features on the other, with entries filled in where a given  
feature helps or hinders a given goal. Does this document exist? If  
not, would it be helpful if it did?

Also, sometimes a feature can, in combination with some other language  
feature, create undesirable interactions. Again, in my mind's eye, I  
picture a table with all of the features in each axis, and the entries  
describe how each pair of features either reinforce, interfere with,  
or have no effect on each other. Does such a document exist? And would  
it be helpful if it did?

Thank you,

- David


PS: Is there a list of the original committee members anywhere? I  
haven't run across that.",
    "header": Object {
      "date": 2007-11-12T22:17:27.000Z,
      "from": Object {
        "email": "ungar@mac.com",
        "name": "ungar at mac.com",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Is%20there%20a%20design%20rationale%20document%3F&In-Reply-To=",
      "subject": "Is there a design rationale document?",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004998.html",
  },
  Object {
    "body": "Brendan Eich wrote:
> On Nov 12, 2007, at 9:34 AM, Jonathan Watt wrote:
> 
>> I like the idea of a pragma more than opt-in versioning since it  
>> can be used
>> in-place, and (I guess) placed before and after a section of code  
>> to turn the
>> handling on then off again.
> 
> Pragmas are block-scoped, so just one should do.

Okay.

>>>    use readonly error
>>>
>>> or perhaps
>>>
>>>    use readonly throw
>>>
>>> We try to make pragmas more readable, sometimes with an extra word;
>>> not sure this is the best way to phrase it still, but the idea would
>>> be to enable throwing of a ReadOnlyError on assignment to a ReadOnly
>>> property. Comments?
>> Why not just:
>>
>>   use ReadOnlyError
> 
> Sure -- pragma convention so far  has been terse and lower-case, e.g.  
> 'use strict' or 'use decimal ...'.

I'm not sure what maintaining case convention gives you here. Using |use
ReadOnlyError| is about as intuitive and easy to remember as it could be I think.

> Speaking of catching, it would be unfortunate if you wrote
> 
>    try { something that might set a ReadOnly property }
>    catch (e : ReadOnlyError) { ... }
> 
> but forgot the pragma, and never heard a word of warning. There are  
> no warnings in the spec, so normative error seems best. But if you're  
> bothering to catch ReadOnlyError, must you also 'use ReadOnlyError'  
> first (in the try, or in a block enclosing the whole try-catch)?

Implicitly enabling ReadOnlyError seems like a very good idea to me (assuming it
can be implemented efficiently). Of course implementations that have facilities
to warn should still warn. Maybe the spec can have non-normative text saying as
much.

Alternatively, maybe it should simply be an error to use ReadOnlyError if it
hasn't been turned on.

Jonathan",
    "header": Object {
      "date": 2007-11-12T22:22:33.000Z,
      "from": Object {
        "email": "jwatt@jwatt.org",
        "name": "Jonathan Watt",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Assigning%20to%20ReadOnly%20properties&In-Reply-To=7F97CD0E-1425-41A8-B991-E756F8A53063%40mozilla.org",
      "subject": "Assigning to ReadOnly properties",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/004999.html",
  },
  Object {
    "body": "On Nov 12, 2007, at 1:43 PM, YR Chen wrote:

> On Nov 12, 2007 11:40 AM, Mark Miller <erights at gmail.com> wrote:
> On Nov 12, 2007 9:05 AM, Brendan Eich <brendan at mozilla.org> wrote:
> > [..], but the idea would
> > be to enable throwing of a ReadOnlyError on assignment to a ReadOnly
> > property. Comments?
>
> Hi Brendan,
>
> I'm glad to hear that this possibility is in scope. In the Caja  
> spec, we write:
>
>  \\\\item[Silent errors.] In JavaScript, various operations, such as  
> setting a
>  ReadOnly property, fail silently rather than throwing an error.  
> Program
>  logic then proceeds along normal control flow paths premised on the
>  assumption that these operations succeeded, leading to inconsistency.
>
> Out of curiosity, what other JS operations fail silently?

Nothing as badly silent as assigning to a ReadOnly property, but here  
I'll bitch about a similar change during ES1 standardization: delete  
x => false if x is in the scope chain but bound with the DontDelete  
attribute -- otherwise delete x => true, either if it was found  
without DontDelete and therefore deleted -- or just not found! So  
delete asdfewr => true. Same for any more qualified reference, e.g.  
delete foo.bar when you mean foo.baz. Oh, and if bar was found in a  
prototype object of foo, delete foo.bar => true without doing anything!

This all seems wrong, and IIRC in Netscape 2, JS1, the original buggy  
progenitor language, delete would report an uncatchable error on bad  
inputs. Just as assigning to ReadOnly would. Someone with an old PC  
and Netscape 2 or 3, please confirm.

I forget why I gave this up in committee. Lot of horse-trading back  
then to get to ES1.

Anyway, with exception handling these both seem like warts. At least  
with delete, the expression using that operator at the top level has  
a boolean result -- but the result could be true and the property is  
still \\"in\\" the object (via prototype-based delegation). Beware.

/be



-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://mail.mozilla.org/pipermail/es-discuss/attachments/20071112/802d8913/attachment-0002.html",
    "header": Object {
      "date": 2007-11-12T22:30:56.000Z,
      "from": Object {
        "email": "brendan@mozilla.org",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Assigning%20to%20ReadOnly%20properties&In-Reply-To=9154babf0711121343i577cc6bg54de4e3b12ad3878%40mail.gmail.com",
      "subject": "Assigning to ReadOnly properties",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005000.html",
  },
  Object {
    "body": "Hi, new here.

On Nov 12, 2007 2:22 PM, Jonathan Watt <jwatt at jwatt.org> wrote:
>
> >>>    use readonly error
> >>>
> >>> or perhaps
> >>>
> >>>    use readonly throw
> >>>
> >>> We try to make pragmas more readable, sometimes with an extra word;
> >>> not sure this is the best way to phrase it still, but the idea would
> >>> be to enable throwing of a ReadOnlyError on assignment to a ReadOnly
> >>> property. Comments?
> >> Why not just:
> >>
> >>   use ReadOnlyError
> >
> > Sure -- pragma convention so far  has been terse and lower-case, e.g.
> > 'use strict' or 'use decimal ...'.
>
> I'm not sure what maintaining case convention gives you here. Using |use
> ReadOnlyError| is about as intuitive and easy to remember as it could be I think.

Since the existing pragma directives are all single words, they could
be camel-humped or underscored for all we know.

Actually, no, I guess there's \\"use xml namespace [string or Namespace
object]\\", which might suggest \\"use error [Class reference or object]\\".
The latter could be used for other types of errors as well.

-- 
T. Michael Keesey
Director of Technology
Exopolis, Inc.
2894 Rowena Avenue Ste. B
Los Angeles, California 90039
http://exopolis.com/
--
http://3lbmonkeybrain.blogspot.com/",
    "header": Object {
      "date": 2007-11-12T22:44:20.000Z,
      "from": Object {
        "email": "keesey@gmail.com",
        "name": "T. Michael Keesey",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Assigning%20to%20ReadOnly%20properties&In-Reply-To=4738D229.6010501%40jwatt.org",
      "subject": "Assigning to ReadOnly properties",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005001.html",
  },
  Object {
    "body": "T. Michael Keesey wrote:
> On Nov 12, 2007 2:22 PM, Jonathan Watt <jwatt at jwatt.org> wrote:
>> I'm not sure what maintaining case convention gives you here. Using |use
>> ReadOnlyError| is about as intuitive and easy to remember as it could be I think.
> 
> Since the existing pragma directives are all single words, they could
> be camel-humped or underscored for all we know.
> 
> Actually, no, I guess there's \\"use xml namespace [string or Namespace
> object]\\", which might suggest \\"use error [Class reference or object]\\".
> The latter could be used for other types of errors as well.

use error ReadOnlyError

seems fine to me, if a little redundant.",
    "header": Object {
      "date": 2007-11-12T22:50:47.000Z,
      "from": Object {
        "email": "jwatt@jwatt.org",
        "name": "Jonathan Watt",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Assigning%20to%20ReadOnly%20properties&In-Reply-To=1f4a892d0711121444t40d3361r7bee9583052fb224%40mail.gmail.com",
      "subject": "Assigning to ReadOnly properties",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005002.html",
  },
  Object {
    "body": "On 11/12/07 2:17 PM, ungar at mac.com wrote:

> Hello all,
> 
> Thank you for adding me to this list.
> 
> I have just finished reading the language proposal spec, and was
> struck by the richness of the additions to the language. I haven't
> been following this effort at all; and so thank people in advance for
> their patience with my ignorance. Now that I've seen the spec, there
> are two more documents that would really help my understanding:

I'm guessing you've read the overview whitepaper. No official spec exists
yet.

> 
> I was wondering if there exists a document that sets out the language
> design goals and the connection between each feature and the goals it
> supports? In my mind's eye, I picture a table of goals along one axis,
> and features on the other, with entries filled in where a given
> feature helps or hinders a given goal. Does this document exist? If
> not, would it be helpful if it did?

Such a document doesn't exist. I have been thinking that something like this
should be written to help people understand how the individual features fit
together to make the whole language work.

I'll take a crack at this.

> 
> Also, sometimes a feature can, in combination with some other language
> feature, create undesirable interactions. Again, in my mind's eye, I
> picture a table with all of the features in each axis, and the entries
> describe how each pair of features either reinforce, interfere with,
> or have no effect on each other. Does such a document exist? And would
> it be helpful if it did?

Good idea too.

The reference implementation is a kind of empirical version of this. But I
agree, an abstract presentation would give a nice overview of what we, as
the designers, believe to be true about the feature interactions.

Jd

> Thank you,
> 
> - David
> 
> 
> PS: Is there a list of the original committee members anywhere? I
> haven't run across that.
> _______________________________________________
> Es4-discuss mailing list
> Es4-discuss at mozilla.org
> https://mail.mozilla.org/listinfo/es4-discuss",
    "header": Object {
      "date": 2007-11-12T23:02:26.000Z,
      "from": Object {
        "email": "jodyer@adobe.com",
        "name": "Jeff Dyer",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Is%20there%20a%20design%20rationale%20document%3F&In-Reply-To=70AEE485-91DF-4A7B-A879-2768A4DB4E52%40mac.com",
      "subject": "Is there a design rationale document?",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005003.html",
  },
  Object {
    "body": "On Nov 12, 2007 2:50 PM, Jonathan Watt <jwatt at jwatt.org> wrote:
> >
> > Actually, no, I guess there's \\"use xml namespace [string or Namespace
> > object]\\", which might suggest \\"use error [Class reference or object]\\".
> > The latter could be used for other types of errors as well.
>
> use error ReadOnlyError
>
> seems fine to me, if a little redundant.

Then again, it doesn't exactly lend itself to an obvious negative....

-- 
T. Michael Keesey
Director of Technology
Exopolis, Inc.
2894 Rowena Avenue Ste. B
Los Angeles, California 90039
http://exopolis.com/
--
http://3lbmonkeybrain.blogspot.com/",
    "header": Object {
      "date": 2007-11-12T23:13:55.000Z,
      "from": Object {
        "email": "keesey@gmail.com",
        "name": "T. Michael Keesey",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Assigning%20to%20ReadOnly%20properties&In-Reply-To=4738D8C7.5030603%40jwatt.org",
      "subject": "Assigning to ReadOnly properties",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005004.html",
  },
  Object {
    "body": "On Nov 12, 2007, at 1:56 PM, YR Chen wrote:

> Personally, I'm still mixed on the introduction of the whole  
> nominal type system with classes and whatnot. I'm very sympathetic  
> to views that ES4 should concentrate on ES3's weak points. At  
> times, I feel that ES3 is just too \\"alien\\" a base to build the  
> \\"programming in the large\\" features that ES4 advocates on to. Like  
> fitting a square peg into a circle.

I think this is a valid criticism of ES3, not ES4. ES3 had \\"native\\"  
and \\"host\\" objects right there in the spec and real browser  
embeddings. These objects were clearly instances of nominal types, in  
the case of the DOM with interfaces, even -- single-inherited classes  
with interfaces for method-suite mixins.

That these built-in object types were alien to the core language, and  
hard to deal with, was obvious. That users would want to emulate,  
wrap, and extend such types did not seem as well-motivated in 1998 as  
it does now.

Now, Ajax apps and libraries routinely wrap, etc., and try to blur  
the lines. This succeeds only to the extent that a bad actor doesn't  
attack the mutable bindings in prototypes and the global object, and  
the good JS programmers don't (have to) worry too much about the  
costs of closures for this-binding, name hiding, etc. But there are  
real limits to JS1's scaling in several dimensions. See the \\"Side  
Discussion\\" at

http://ejohn.org/blog/native-json-support-is-required/

and note that the requirement is to produce a DOM (not some tree of  
JS objects to be walked in order to generate a DOM). I've heard this  
from many Ajax devs: XML, XSLT (yuck, but it works pretty well in  
browsers), and HTML with its DOM beat pure JS approaches that then  
must generate a DOM, at scale. And the DOM is nominally typed.

Two ways forward:

* Change the native and DOM bindings to look more like prototypal JS,  
or ES4 with structural types only, or something like that -- but  
that's a whole new DOM binding and even DOM interface formalism, and  
the DOM ships sailed many times already. This task would involve  
rolling big stones up many browser-war hills, at the same time.

* Add enough support to ES3 to self-host, which is more or less what  
ES4's nominal types do, plus interfaces for the DOM and many similar  
\\"host\\" object systems already hooked up to ES3 engines. Self-hosting  
much of the DOM is possible (and may even perform better, besides  
being memory-safe compared to a C++ DOM implementation).

Given the programming-in-the-large and integrity goals, the second  
path looks much more attractive, not to mention realistic. It  
supports self-hosting and so levels the playing field between \\"native/ 
host\\" and \\"hosted\\" (written-in-ES) abstractions, which has further  
good effects in the ecosystem. It provides tools for scaling and  
hardening those abstractions that need to scale and become hard  
across larger populations, higher method call rates (but this is a  
non-goal in my book, more later), and accidents or intentional attacks.

Yes, this path leads to a bigger language than the first path. But  
nothing will avoid growth, and too little growth can compromise both  
the language's integrity and leave too big a complexity tax on its  
users.

Having written this, I will say that the general objection to ES4 as  
too big, I find deeply \\"true\\" in many ways, and the most serious  
challenge to those of us working on ES4.

Yet the web is big. There's a lot in the real world that is too big.  
My emphasis on nothing being lost from the ES3 core is not meant to  
excuse bigness, only to observe that (unlike in other parts of  
virtual and real worlds, where bigness is imposed and smallness is  
lost, through exclusive offerings and even coercion), we are not  
\\"breaking the web\\".

Still, I'm strongly sympathetic to those who are \\"defending the  
Shire\\" (if you get my reference) by objecting to ES4's bigness. And  
there's a real risk that ES4, even though backward compatible, will  
be twisted via bad programming \\"culture wars\\" that in effect stamp  
out the old ways. Should it come to this, I'll be on the other side  
of those wars, with the Hobbits and Doug Crockford (if they'll have  
me. :-/).

But I don't think the old ways suffice. I've seen too many users  
waste hours and days struggling to enforce latent types with ad-hoc  
checks, or no checks at all. I've seen lots of security exploits that  
take advantage of mutability and extensibility at the heart of JS1.  
And I hope we all can see the onslaught of alternative but near-the- 
web (typically browser plugin at first, but then embrace, extend,  
extinguish soon follow) runtimes that boast bigger, stronger, and  
more scaleable (in practice) programming languages.

Against these, JS1 or a small \\"cleanup\\" of it cannot compete, not  
only in my opinion, but in the successful marketing judgments of  
several mighty companies (including Microsoft and Yahoo!). And to be  
fair to those big companies, many (most?) programmers do deserve  
better programming-in-the-large and integrity support, including an  
expressive type system with optional static checking. If they have to  
switch to C# or ActionScript to get it, many programmers will. JSLint  
is not enough.

> Nonetheless, I see that languages based on the old ES4 draft  
> (2002?) that have been successful, namely ActionScript. I'm not  
> very familiar with it, but the overall feeling I get from ppl  
> developing in AS is positive. I also want to get my hands dirty  
> testing out classes in ES4, but sadly the RI is too buggy at the  
> moment.

Please mail me about these RI bugs, or file them yourself at http:// 
bugs.ecmascript.org/ -- I have access to the monotone repository, and  
I see classes and interfaces doing more right than wrong, but we need  
to see your testcases. Thanks.

> Basically, what I'm saying is, I'm willing to give the Java-esque  
> type system a chance.

Java-esque is not fair, even if you are talking only about the  
nominal types. Unbounded type parameters are not classically \\"Java- 
esque\\", and Java generics go beyond what we are doing in some ways  
(variance annotations) while still being much less (erased, static  
only) in others. ES4 is a dynamic language. Java-esque doesn't begin  
to do it justice.

> With that said, some of your ideas are interesting, such as  
> multiple prototypes. I imagine, however, that that would slightly  
> less efficient, and more importantly, result in similar problems to  
> multiple inheritance (think diamond inheritance issues). I would  
> like to know how Self handled that issue.

Self supported multiple prototypes. Since Self came up, I thought I'd  
point out Cecil, Craig Chambers' Self-with-optional-types-and-generic- 
methods sequel. It has been an inspiration to ES4 at least for me:

http://www.cs.washington.edu/research/projects/cecil/pubs/cecil- 
spec.html

> Macros have been proposed and discussed before - they're somewhere  
> on the wiki. AFAIK, they've been deferred to a future ES5.

Researchers on the list may be willing to speak to macros with more  
authority than I have. I'll just say that apart from the fun with C- 
like syntax (which can be handled; we're close to specifying standard  
ASTs for ES4), sound hygiene theory is still a research topic. I  
expect good results from academia in a year or so, and hope that TG1  
will take advantage of them.

In the mean time, I think it would be very wrong to defer syntactic  
conveniences until after macros are done. With macros, conveniences  
that de-sugar in ES4 could be re-specified (and implemented at the  
same time) cheaply, for sure -- but users deserve convenient syntax  
sooner than \\"after macros\\".

/be",
    "header": Object {
      "date": 2007-11-12T23:19:30.000Z,
      "from": Object {
        "email": "brendan@mozilla.org",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Is%20ES3%20good%20enough%3F%20Was%20incrementally%20strengthening%20ES3%20paradigms%0A%09considered%3F&In-Reply-To=9154babf0711121356v4f06daf8ocaa0fe0ca0c8fab%40mail.gmail.com",
      "subject": "Is ES3 good enough? Was incrementally strengthening ES3 paradigms	considered?",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005005.html",
  },
  Object {
    "body": "Jonathan Watt wrote:
> It would be really nice to be able to search the mailing list archives.

Use Google:

   site:https://mail.mozilla.org/pipermail/es4-discuss/  closure

Chris",
    "header": Object {
      "date": 2007-11-12T23:22:34.000Z,
      "from": Object {
        "email": "chrispi@opera.com",
        "name": "Chris Pine",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Searching%20the%20mailing%20list%20archives&In-Reply-To=47388F01.4070400%40jwatt.org",
      "subject": "Searching the mailing list archives",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005006.html",
  },
  Object {
    "body": "Many thanks. If there is any way I can be of any help, please don't  
hesitate to ask. I would be delighted.

- David


On Nov 12, 2007, at 3:02 PM, Jeff Dyer wrote:

>
> On 11/12/07 2:17 PM, ungar at mac.com wrote:
>
>> Hello all,
>>
>> Thank you for adding me to this list.
>>
>> I have just finished reading the language proposal spec, and was
>> struck by the richness of the additions to the language. I haven't
>> been following this effort at all; and so thank people in advance for
>> their patience with my ignorance. Now that I've seen the spec, there
>> are two more documents that would really help my understanding:
>
> I'm guessing you've read the overview whitepaper. No official spec  
> exists
> yet.
>
>>
>> I was wondering if there exists a document that sets out the language
>> design goals and the connection between each feature and the goals it
>> supports? In my mind's eye, I picture a table of goals along one  
>> axis,
>> and features on the other, with entries filled in where a given
>> feature helps or hinders a given goal. Does this document exist? If
>> not, would it be helpful if it did?
>
> Such a document doesn't exist. I have been thinking that something  
> like this
> should be written to help people understand how the individual  
> features fit
> together to make the whole language work.
>
> I'll take a crack at this.
>
>>
>> Also, sometimes a feature can, in combination with some other  
>> language
>> feature, create undesirable interactions. Again, in my mind's eye, I
>> picture a table with all of the features in each axis, and the  
>> entries
>> describe how each pair of features either reinforce, interfere with,
>> or have no effect on each other. Does such a document exist? And  
>> would
>> it be helpful if it did?
>
> Good idea too.
>
> The reference implementation is a kind of empirical version of this.  
> But I
> agree, an abstract presentation would give a nice overview of what  
> we, as
> the designers, believe to be true about the feature interactions.
>
> Jd
>
>> Thank you,
>>
>> - David
>>
>>
>> PS: Is there a list of the original committee members anywhere? I
>> haven't run across that.
>> _______________________________________________
>> Es4-discuss mailing list
>> Es4-discuss at mozilla.org
>> https://mail.mozilla.org/listinfo/es4-discuss
>",
    "header": Object {
      "date": 2007-11-12T23:55:15.000Z,
      "from": Object {
        "email": "ungar@mac.com",
        "name": "ungar at mac.com",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Is%20there%20a%20design%20rationale%20document%3F&In-Reply-To=C35E1B82.F8F7%25jodyer%40adobe.com",
      "subject": "Is there a design rationale document?",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005007.html",
  },
  Object {
    "body": "On Nov 12, 2007, at 1:40 PM, YR Chen wrote:

> Definitely like it. I wonder how convoluted the grammar change was  
> - did it require a new value_expr_no_conflicts_with_type_expr  
> production and all related productions/rules?

Not sure, but top-down parsers have it easy, discriminating on the  
leftmost token and if none of the short list of structural type  
tokens match, falling into a value-expression sub-parser invocation.

As I noted elsewhere, we have such a grammar (not quite the same,  
consider '(' as the leftmost token of the new operand) for the new  
operator (see the overview, \\"Record and array types\\" section).

> Yeah, I meant \\"anonymous interfaces\\". I know they're not the same  
> as interfaces, but they're similar in that they place a set of  
> restrictions or guarantees on a class or object that \\"implements\\"  
> them.

Just FYI, we tried for self-types (see Kim Bruce's work) to make  
structural types with \\"methods\\" stronger, but deferred. See

http://wiki.ecmascript.org/doku.php?id=proposals:self_type

> I think that would be a good thing. Another thought: if |x is v|,  
> where |v| is a meta-object, works, then one would think that it  
> should also work for |like|, e.g.
>
> var x = int
> 10 is x; // ok
> 10 is like x; // ?
>
> But if that last statement is allowed, then so is |var y: like x|,  
> which is undecidable (if that's the correct term), so evidently | 
> like| shouldn't work with value exprs.

This is a hot topic. We could indeed allow all sorts of type  
expressions, and define evaluation rules so that (I hope) nothing  
diverges and we don't need to set a watchdog timer on strict mode's  
type checker. The static guarantees go down because strict mode will  
punt anything it can't figure out to runtime, treating the compile- 
time type as *. It seems wiser at the moment to restrict type  
annotations and remain future proof, but make 'is' friendlier as you  
and I have been discussing.

> Might want to mention this in any clarification you put into the  
> spec, even if it's strictly disallowed in the formal grammar - that  
> even though |is| allows a value expr on the right side, it cannot  
> be nested within a type expr. That means given |var x|, none of |10  
> is like x|, |10 is (x)|, |10 is {p: x}|, etc. are syntactically  
> allowed.

I think we're now inclined to allow those but insist on a type at  
runtime. But this is something to discuss more.

> There are couple potential problems with upgrading |instanceof| to  
> match the syntax of the revised |is|:
>
> 1) Function expr syntax ambiguity. Consider:
>
> a) x is function(p: int): int // ok
> b) x is function(p: int): int {} // syntax error
> c) x instanceof function(p: int): int // ok?
> d) x instanceof function(p: int): int {} // syntax error?

Oh, I see -- on second thought I meant nothing like allowing (d) --  
sorry. instanceof only takes a value expression on its right, but if  
that evaluates to a type meta-object, it does something sane and  
\\"instance-of\\"ish.

> 2) Object literal syntax ambiguity. If it is possible to simulate a  
> constructor with an object literal, namely creating an object with  
> [[HasInstance]], we'll have a similar situation to (1). I'm not  
> sure if it's possible, so I'll make up some syntax in the following  
> example to indicate what I mean:
>
> x instanceof {meta::construct: function() {}}
>
> That object literal is supposed to create a constructor-like  
> object, but like I said, I'm not sure if it's really possible and  
> of the exact syntax required.

Not possible, so if we want to allow {p: t, q: u} on the right of  
instanceof, we have the choice to treat that as a type expression  
(likewise for [a, b] and (c, d)). Again the new operator can handle  
array and object types similarly, because there's no way for you to  
write a constructible value initialiser (object or, needless to say,  
array initialiser). If we do not fear closing the door to future  
extensions that enable constructible or has-instance-able  
initialisers, then I think we're on solid ground. And I see no point  
in adding ways to make such things, given the alternative meanings  
competing for the same syntax here (value vs. type expressions with  
instanceof and new, I mean).

> Anyway, that |{...}| is ambiguous in that it can either be treated  
> as a record structural type or an object literal. In ES3, there's  
> no way to create a constructor from an object literal (AFAIK), so  
> the above syntax (ignoring the namespace) would be a runtime error.  
> Thus, there is no backwards compat issue. If it were allowed in  
> ES3, as before, it is guaranteed to resolve to false. So the | 
> {...}| should be treated as a record structural type.
>
> 3) Parenthesis ambiguity. This is the most troublesome one. Consider:
>
> a) x is (int) // ok
> b) x is (some_constructor) // syntax error
> c) x is ({p: int}) // ok
> d) x instanceof (int) // ok
> e) x instanceof (some_constructor) // syntax error?
> f) x instanceof ({p: int}) // how should this be treated?

Yes, and parenthesized expression may follow operator new, so this is  
a hard limit.

> If we really want to upgrade |instanceof| yet keep it coherent with  
> |is| in both semantics and syntax, we may have to visit the |type|  
> operator again, but that should be a last resort.
>

That unary type operator is still around in the spec space, awaiting  
hookup in the RI, at least as far as I can recall. But with the  
unification (partial, but practical) of type and (else) value  
expressions for 'is\\", or vice versa for instanceof/new, I agree we  
should avoid reaching for unary 'type'.

/be",
    "header": Object {
      "date": 2007-11-12T23:58:22.000Z,
      "from": Object {
        "email": "brendan@mozilla.org",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=need%20some%20clarification%20on%20compile-time%20type%20vs.%20run-time%20type&In-Reply-To=9154babf0711121340l2ce52237i9eb32331d42968e8%40mail.gmail.com",
      "subject": "need some clarification on compile-time type vs. run-time type",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005008.html",
  },
  Object {
    "body": "On Nov 12, 2007 2:30 PM, Brendan Eich <brendan at mozilla.org> wrote:
> Nothing as badly silent as assigning to a ReadOnly property, but here I'll
> bitch about a similar change during ES1 standardization: delete x => false
>
> Anyway, with exception handling these both seem like warts. At least with
> delete, the expression using that operator at the top level has a boolean
> result -- but the result could be true and the property is still \\"in\\" the
> object (via prototype-based delegation). Beware.

Another point of agreement! Caja attempts to be approximately a
\\"fail-stop subset\\" of ES3 (or ES3R), meaning (from the Caja spec):

# Caja is only a subset of JavaScript in a limited sense: While a Caja program
# has not explicitly indicated a failure, it executes within JavaScript's
# semantics. By \\\\emph{indicate a failure}, we mean either throwing an exception
# or returning \\\\code{undefined} for a property read.

To fix delete within this constraint, \\"delete <whatever>\\" in Caja
either return true or throws.

-- 
Text by me above is hereby placed in the public domain

    Cheers,
    --MarkM",
    "header": Object {
      "date": 2007-11-13T00:01:22.000Z,
      "from": Object {
        "email": "erights@gmail.com",
        "name": "Mark Miller",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Assigning%20to%20ReadOnly%20properties&In-Reply-To=36E270B9-E0C0-4CCA-9D32-C5B61EB3082C%40mozilla.org",
      "subject": "Assigning to ReadOnly properties",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005009.html",
  },
  Object {
    "body": "On Nov 12, 2007, at 3:58 PM, Brendan Eich wrote:

>> There are couple potential problems with upgrading |instanceof| to
>> match the syntax of the revised |is|:
>>
>> 1) Function expr syntax ambiguity. Consider:
>>
>> a) x is function(p: int): int // ok
>> b) x is function(p: int): int {} // syntax error
>> c) x instanceof function(p: int): int // ok?
>> d) x instanceof function(p: int): int {} // syntax error?
>
> Oh, I see -- on second thought I meant nothing like allowing (d) --

Er, I meant (c), if you remove type annotations from the function  
param and result. In ES3 today, you can write

js> ({}) instanceof function (){}
false

It's silly, of course, because the function expression is captured by  
the right operand and could not have been constructed via operator  
new to get the left operand. But it's valid ES3 syntax, so we can't  
switch instanceof's right operand to favor a function structural type.

/be",
    "header": Object {
      "date": 2007-11-13T00:15:45.000Z,
      "from": Object {
        "email": "brendan@mozilla.org",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=need%20some%20clarification%20on%20compile-time%20type%20vs.%20run-time%20type&In-Reply-To=1000114D-BDB8-433B-AC19-D5AE718788C5%40mozilla.org",
      "subject": "need some clarification on compile-time type vs. run-time type",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005010.html",
  },
  Object {
    "body": "On Nov 12, 2007, at 4:01 PM, Mark Miller wrote:

> To fix delete within this constraint, \\"delete <whatever>\\" in Caja
> either return true or throws.

At this point, either ES4 slides down the slippery slope a bit and  
courts migration pain that holds it back (we really do expect most  
pages on the web today to work if shipped as application/ 
ecmascript;version=4 or application/javascript;version=2); or I think  
we need a better pragma story.

We could support

   use DeleteError, ReadOnlyError

and encourage users to litter their new code with this line at the  
top. There's good precedent from Perl and other languages for a  
superstitious

   use strict

at the top. But the Errors are a mouthful and eyeful. Since I just  
mentioned strict mode, I'll note again that the single runtime  
semantic change strict mode causes from standard mode (assuming the  
program passes strict mode's type checker and lint-like sanity  
checker) is a change to eval: strict mode results in a different  
runtime eval, such that eval cannot create bindings in its dynamic  
scope. We could slide down *this* slope a bit by adding DeleteError  
and ReadOnlyError exception behavior to 'use strict'.

Comments welcome, but you're probably in favor of opt-in versioning  
making all of these changes implicitly ;-). Or perhaps a 'use Caja'  
pragma :-P.

/be",
    "header": Object {
      "date": 2007-11-13T00:25:36.000Z,
      "from": Object {
        "email": "brendan@mozilla.org",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Assigning%20to%20ReadOnly%20properties&In-Reply-To=fee0a56d0711121601s6a4183a6o11cb8c12c37743a1%40mail.gmail.com",
      "subject": "Assigning to ReadOnly properties",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005011.html",
  },
  Object {
    "body": "Hello!

Since we now have a namespace for uint specific math operations, and
discussion in another thread about using pragmas for throwing if
assigning to ReadOnly properties... Is it possible we could have a
look at the idea of adding constrained primitive types or adding a
pragma changing the mechanism for, or adding a separate set of
operations, constraining number types by the simple rule of (input >
output_type.MAX_VALUE) and (input < output_type.MIN_VALUE) throwing an
out-of-bounds error.

I'm a little concerned that a type of uint allows assigning negatives
with a silent round-the-corner conversion and allows values of NaN and
Infinity. (I imagine for example the DOM interfaces that have uint
constraints really would like these to throw an out-of-bounds
exception or similar.)

Also, the RI gives an Overflow exception for values 2^32 or greater,
which I'm not sure whether it's the intended behaviour or a result of
the underlying implementation that is in fact intended to fail
silently like the other cases.

>> function fn(input:uint):uint input;
>> fn(0x7fffffff);
2147483647
>> fn(-0x80000000);
2147483648
>> fn(Infinity);
0
>> fn(NaN);
0
>> fn(0x100000000);
unhandled exception: Overflow

>> function fn(input:int):int input;
>> fn(0x7fffffff)
2147483647
>> fn(0x80000000)
-2147483648
>> fn(-0x80000000)
-2147483648
>> fn(NaN)
0
>> fn(Infinity)
0
>> fn(0x100000000)
unhandled exception: Overflow
-- 
David \\"liorean\\" Andersson",
    "header": Object {
      "date": 2007-11-13T00:56:39.000Z,
      "from": Object {
        "email": "liorean@gmail.com",
        "name": "liorean",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Bringing%20up%20the%20issue%20of%20numerical%20constraints%20again&In-Reply-To=",
      "subject": "Bringing up the issue of numerical constraints again",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005012.html",
  },
  Object {
    "body": "On Nov 12, 2007 4:25 PM, Brendan Eich <brendan at mozilla.org> wrote:
> On Nov 12, 2007, at 4:01 PM, Mark Miller wrote:
>
> > To fix delete within this constraint, \\"delete <whatever>\\" in Caja
> > either return true or throws.
>
> At this point, either ES4 slides down the slippery slope a bit and
> courts migration pain that holds it back (we really do expect most
> pages on the web today to work if shipped as application/
> ecmascript;version=4 or application/javascript;version=2); or I think
> we need a better pragma story.
>
> We could support
>
>    use DeleteError, ReadOnlyError
>
> and encourage users to litter their new code with this line at the
> top. There's good precedent from Perl and other languages for a
> superstitious
>
>    use strict
>
> at the top. But the Errors are a mouthful and eyeful. Since I just
> mentioned strict mode, I'll note again that the single runtime
> semantic change strict mode causes from standard mode (assuming the
> program passes strict mode's type checker and lint-like sanity
> checker) is a change to eval: strict mode results in a different
> runtime eval, such that eval cannot create bindings in its dynamic
> scope. We could slide down *this* slope a bit by adding DeleteError
> and ReadOnlyError exception behavior to 'use strict'.
>
> Comments welcome, but you're probably in favor of opt-in versioning
> making all of these changes implicitly ;-). Or perhaps a 'use Caja'
> pragma :-P.

IMO the only sane thing to do in this regard, if we were to do
anything, is to add what we consider bug-fixing behavior to the
effects of \\"use strict\\".  We've already hung the eval change there,
and though I don't remember right now if \\"with\\" has to be \\"reformed
with\\" in strict mode I know we've talked about it (obviously this is a
syntactic constraint only); if everyone agrees that deleting an
unknown property would be an error in a rational world, or that
writing to a read-only property should be, then these are clear
language bugs that don't need their own knobs.  We need knobs, but too
many knobs are if anything worse than none at all.

We made a very special exception for eval wrt changing run-time
semantics in strict mode for the code in the scope of the \\"use strict\\"
pragma, and we've been careful to state that it's the exception that
proves the rule: no run-time differences between strict and standard
modes.  The question about the bug fixes for delete and read-only
properties is: are these errors so important and wide-spread that they
warrant breaking that rule?  The value of the rule is that \\"use
strict\\" gives you verification only, after that you don't have to
remember anything special (except for the change to eval); if we
attach these bug fixes to the same rule, then (a) where do we stop and
(b) is the language better, worse, or just different?

--lars",
    "header": Object {
      "date": 2007-11-13T01:19:21.000Z,
      "from": Object {
        "email": "lth@acm.org",
        "name": "Lars T Hansen",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Assigning%20to%20ReadOnly%20properties&In-Reply-To=455B1A10-C6E4-4F44-84AF-1ED527E901BF%40mozilla.org",
      "subject": "Assigning to ReadOnly properties",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005013.html",
  },
  Object {
    "body": "On Nov 12, 2007, at 5:19 PM, Lars T Hansen wrote:

> IMO the only sane thing to do in this regard, if we were to do
> anything, is to add what we consider bug-fixing behavior to the
> effects of \\"use strict\\".  We've already hung the eval change there,

For good reason too -- if eval can create bindings in its dynamic  
scope, the type checker and even name sanity checks in strict mode  
are a bit lost, aren't they?

> and though I don't remember right now if \\"with\\" has to be \\"reformed
> with\\" in strict mode I know we've talked about it (obviously this is a
> syntactic constraint only);

I asked whether strict mode should require \\"reformed with\\" here:

http://wiki.ecmascript.org/doku.php?id=discussion:reformed_with

There may be a meeting note soon after that date, but wiki search  
seems broken, especially at finding meeting notes. Do you want a  
ticket on this?

> if everyone agrees that deleting an
> unknown property would be an error in a rational world, or that
> writing to a read-only property should be, then these are clear
> language bugs that don't need their own knobs.  We need knobs, but too
> many knobs are if anything worse than none at all.

Agreed.

> We made a very special exception for eval wrt changing run-time
> semantics in strict mode for the code in the scope of the \\"use strict\\"
> pragma, and we've been careful to state that it's the exception that
> proves the rule: no run-time differences between strict and standard
> modes.  The question about the bug fixes for delete and read-only
> properties is: are these errors so important and wide-spread that they
> warrant breaking that rule?  The value of the rule is that \\"use
> strict\\" gives you verification only, after that you don't have to
> remember anything special (except for the change to eval); if we
> attach these bug fixes to the same rule, then (a) where do we stop and
> (b) is the language better, worse, or just different?

This is the slippery slope, indeed.

But first, let me check my understanding: 'use strict' must restrict  
eval from creating bindings in its dynamic scope, or type checking is  
defeated (eval could shadow an outer binding). Right?

/be",
    "header": Object {
      "date": 2007-11-13T01:29:42.000Z,
      "from": Object {
        "email": "brendan@mozilla.org",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Assigning%20to%20ReadOnly%20properties&In-Reply-To=12c6978a0711121719q7a7bf795y96f49e0789cdc804%40mail.gmail.com",
      "subject": "Assigning to ReadOnly properties",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005014.html",
  },
  Object {
    "body": "Jonathan Watt wrote:
> liorean wrote:
>> On 11/11/2007, Jonathan Watt <jwatt at jwatt.org> wrote:
>>> I've noticed that rounding in the reference implementation is implemented using
>>> IEEE roundTiesToEven, but in browsers .5 values appear to round towards zero.
>>> Although roundTiesToEven is desirable from a computational point of view,
>>> there's likely a significant risk that changing to this method could break some
>>> existing ECMAScript.
>> That's really serious breakage
> 
> Well, it's likely only a small bug in the reference implementation rather than a
> requirement of the specification, so not too big a deal I'd think.
> 
>> - books, tutorials, references and real
>> world code all take for granted that halves alway round up.
> 
> Err, right. Round up, not round to zero. Thanks for the correction.

I believe there is some confusion here. There is no proposed change to 
the *binary* floating point operations in ES4, relative to ES3.

There is a new datatype for *decimal* floating point, and this datatype 
has a different default rounding mode than the rounding mode in ES3 
binary floating point. But this datatype has a wide variety of 
arithmetical differences. In particular:

   - You can actually represent 0.5 in the first place! Binary floating
     point cannot. Decimal can. In the default decimal context, 0.5 + 0.5
     gives an exact decimal answer; there is no rounding to worry about.

   - You can adjust the rounding modes and precision used for decimal
     arithmetic, to precisely match your local monetary / banking / tax
     regulations. The choice of half-even as a default mode is based on
     precedent of other decimal libraries and banking locales. See the
     sage advice of Mike Cowlishaw on choice of decimal rounding modes:
     http://www2.hursley.ibm.com/decimal/decifaq1.html#rounding

There is no existing ES3 code in the wild that uses decimal arithmetic 
at all, much less a particular decimal rounding mode.

-Graydon",
    "header": Object {
      "date": 2007-11-13T02:24:03.000Z,
      "from": Object {
        "email": "graydon@mozilla.com",
        "name": "Graydon Hoare",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=roundTiesToEven&In-Reply-To=47370234.3030102%40jwatt.org",
      "subject": "roundTiesToEven",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005015.html",
  },
  Object {
    "body": "Graydon Hoare wrote:

>    - You can actually represent 0.5 in the first place! Binary floating
>      point cannot. Decimal can. In the default decimal context, 0.5 + 0.5
>      gives an exact decimal answer; there is no rounding to worry about.

Oops, excuse me: 0.1. As I've had pointed out, 0.5 is happily 
representable in both :)

(And ... I appear to be quick on the draw on this thread anyways; if the 
RI happens to set up its binary floating point rounding modes, that's a 
correctly-reported bug in it. SML/NJ has surprised us with its mapping 
of IEEE754 binary floating point several times already. No change to the 
existing ES3 binary floating point is intended. Sorry, mea culpa.)

-Graydon",
    "header": Object {
      "date": 2007-11-13T02:57:21.000Z,
      "from": Object {
        "email": "graydon@mozilla.com",
        "name": "Graydon Hoare",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=roundTiesToEven&In-Reply-To=47390AC3.3050608%40mozilla.com",
      "subject": "roundTiesToEven",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005016.html",
  },
  Object {
    "body": "Hi everyone,

What's the expected behaviour for a function returning a value, of which
the type is contrary to the type defined in the function declaration? 

For example:

    var func:Function = function():int {
        return \\"This is not an int\\";
    }
    typeof(func()); // string

Is this expected behaviour? Here's some similar Actionscript 3 code:

    package {
        class ReturnTest {
            public function ReturnTest():void {
                returnInt();
            }
            private function returnInt():int {
                return \\"String instead\\";
            }
        }
    }

...which produces the following compile-time error:

    Implicit coercion of a value of type String to an unrelated type 
    int.


Regards,

--
Nathan de Vries

PS: Fantastic work with the Linux build of the reference implementation.
I'm working my way through the overview documentation, and will probably
have a poke at the SML when I'm feeling more game :).
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/x-pkcs7-signature
Size: 2139 bytes
Desc: not available
Url : http://mail.mozilla.org/pipermail/es-discuss/attachments/20071113/c71cee7e/attachment-0002.bin",
    "header": Object {
      "date": 2007-11-13T07:38:31.000Z,
      "from": Object {
        "email": "nathan@atnan.com",
        "name": "Nathan de Vries",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Enforcing%20return%20value%20types&In-Reply-To=",
      "subject": "Enforcing return value types",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005017.html",
  },
  Object {
    "body": "I'm guessing you're just experiencing the effects of
http://bugs.ecmascript.org/ticket/285.  The correct behavior is a
run-time error in standard mode; compile-time error in strict mode.

--lars


On Nov 12, 2007 11:38 PM, Nathan de Vries <nathan at atnan.com> wrote:
> Hi everyone,
>
> What's the expected behaviour for a function returning a value, of which
> the type is contrary to the type defined in the function declaration?
>
> For example:
>
>     var func:Function = function():int {
>         return \\"This is not an int\\";
>     }
>     typeof(func()); // string
>
> Is this expected behaviour? Here's some similar Actionscript 3 code:
>
>     package {
>         class ReturnTest {
>             public function ReturnTest():void {
>                 returnInt();
>             }
>             private function returnInt():int {
>                 return \\"String instead\\";
>             }
>         }
>     }
>
> ...which produces the following compile-time error:
>
>     Implicit coercion of a value of type String to an unrelated type
>     int.
>
>
> Regards,
>
> --
> Nathan de Vries
>
> PS: Fantastic work with the Linux build of the reference implementation.
> I'm working my way through the overview documentation, and will probably
> have a poke at the SML when I'm feeling more game :).
>
> _______________________________________________
> Es4-discuss mailing list
> Es4-discuss at mozilla.org
> https://mail.mozilla.org/listinfo/es4-discuss
>
>",
    "header": Object {
      "date": 2007-11-13T07:50:58.000Z,
      "from": Object {
        "email": "lth@acm.org",
        "name": "Lars T Hansen",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Enforcing%20return%20value%20types&In-Reply-To=1194939511.28500.54.camel%40ooboontoo",
      "subject": "Enforcing return value types",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005018.html",
  },
  Object {
    "body": "On Mon, 2007-11-12 at 23:50 -0800, Lars T Hansen wrote:
> I'm guessing you're just experiencing the effects of
> http://bugs.ecmascript.org/ticket/285.  The correct behavior is a
> run-time error in standard mode; compile-time error in strict mode.

Ah, so it is. I'll assume the implementers will know that the scope of
the ticket is greater than that of functions with void return value
types defined.


Regards,

--
Nathan de Vries
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/x-pkcs7-signature
Size: 2139 bytes
Desc: not available
Url : http://mail.mozilla.org/pipermail/es-discuss/attachments/20071113/65f1193c/attachment-0002.bin",
    "header": Object {
      "date": 2007-11-13T08:09:13.000Z,
      "from": Object {
        "email": "nathan@atnan.com",
        "name": "Nathan de Vries",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Enforcing%20return%20value%20types&In-Reply-To=12c6978a0711122350j598c291enfa97411b9f480a7b%40mail.gmail.com",
      "subject": "Enforcing return value types",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005019.html",
  },
  Object {
    "body": "An HTML attachment was scrubbed...
URL: http://mail.mozilla.org/pipermail/es-discuss/attachments/20071113/90c31a0f/attachment-0002.html",
    "header": Object {
      "date": 2007-11-13T14:36:21.000Z,
      "from": Object {
        "email": "trqm@bmw-online.com",
        "name": "Raquel Kenney",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=%2A%2A%2ASPAM%2A%2A%2A%20Tired%20of%20being%20overweight%3F%20We%20can%20help%21&In-Reply-To=",
      "subject": "***SPAM*** Tired of being overweight? We can help!",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005020.html",
  },
  Object {
    "body": "Every man wants to achieve better, longer-lasting, amazing orgasms. Intensity of orgasm can be increased by a greater volume of cum. WonderCum is an amazing product designed to in large the volume of sperm and thereby intensity and power of orgasms.

 Contact our customer service if you need help and have questions or just fill online form to make your order. 100% money back guarantee ensures the top quality of product.

http://vieshine.com

  Great product for men's health.",
    "header": Object {
      "date": 2007-11-13T17:48:15.000Z,
      "from": Object {
        "email": "vjavd@blue-concept.com",
        "name": "Violet Finch",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=%2A%2A%2ASPAM%2A%2A%2A%20More%20sperm%20means%20longer%20orgasms.&In-Reply-To=",
      "subject": "***SPAM*** More sperm means longer orgasms.",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005021.html",
  },
  Object {
    "body": "> Could the Scheme aspect of ES be strengthened? Tail recursion and let
> statements seem like good additions. What about macros? Please!

I can speak to the topic of macros. The group has been open to the 
possibility of macros for a future version of ES, but not Edition 4. 
There are not very many languages with non-Lisp syntax that have come 
close to the power of Lisp/Scheme macros. CPP is distinctly *not* an 
inspiration! :) Dylan may provide some inspiration, and possibly Boo and 
Nemerle, though I have to learn more about these languages.

JavaScript's complicated syntax makes macros very tricky. Contrary to 
the popular view that parsing is a wholly solved problem in CS, moving 
Lisp-style macros out of the domain of S-expressions and into 
token-based syntaxes is far trickier than you might first suspect.

Hygiene is another important desideratum; scaling up C macros to be 
closer to the power of Lisp macros means dealing with the kinds of bugs 
that arise from name clashes[*]. Automatically hygienic systems 
generally \\"do the right thing\\" but there are a number of different 
algorithms to choose from, and as Brendan says the last word about 
hygiene has not been written (this is in fact the topic of my 
dissertation work). However, the theory doesn't have to be set in stone 
for the practice to proceed, and there are plenty of excellent, working 
Scheme implementations with fantastic macro systems that have been 
around for many years. There's lots of good inspiration to draw from.

So the short answer to your question is: maybe, but not yet. :)

Dave

[*] These problems don't arise in standard C, but with e.g. the GCC 
extensions to CPP you can easily cause these kinds of name capture.",
    "header": Object {
      "date": 2007-11-13T19:04:42.000Z,
      "from": Object {
        "email": "dherman@ccs.neu.edu",
        "name": "Dave Herman",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Is%20ES3%20good%20enough%3F%20Was%20incrementally%20strengthening%20ES3%20paradigms%0A%09considered%3F&In-Reply-To=3cbaf1c80711081128rb9de0beta63e490cf7e3b2d2%40mail.gmail.com",
      "subject": "Is ES3 good enough? Was incrementally strengthening ES3 paradigms	considered?",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005022.html",
  },
  Object {
    "body": "Purchase perfectly working software available in all European languages! Also for Macintosh! Fast to download, only original versions are offered at very cheap prices. Special offers and discounts allow you to save!

 Buy software and be sure our professional customer support team will help to install it. Be also sure, if some problem occurs and your software does not run, we give your money back. You also will be able to do all the updates.

http://tasofta.com

   Purchase perfectly functioning software.",
    "header": Object {
      "date": 2007-11-13T19:08:03.000Z,
      "from": Object {
        "email": "lwdpwv@bluehammock.com",
        "name": "Leonel Ware",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=%2A%2A%2ASPAM%2A%2A%2A%20Get%20the%20cheapest%20software%20offer%21&In-Reply-To=",
      "subject": "***SPAM*** Get the cheapest software offer!",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005023.html",
  },
  Object {
    "body": "On 2007-11-12, at 02:04 EST, Brendan Eich wrote:

>                                                 Imagine explicit
> parenthese (not allowed because they mean union type, but pretend)

I was just thinking how clever it was that parentheses meant both  
union type and expression grouping, because a union type of only one  
type is that type, so you could use parentheses here?

>   x is (like T)

What am I missing?",
    "header": Object {
      "date": 2007-11-13T21:08:32.000Z,
      "from": Object {
        "email": "ptw@pobox.com",
        "name": "P T Withington",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=need%20some%20clarification%20on%20compile-time%20type%20vs.%20run-time%20type&In-Reply-To=8E16C901-45FF-447D-9C13-0F8FB55E6DF9%40mozilla.org",
      "subject": "need some clarification on compile-time type vs. run-time type",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005024.html",
  },
  Object {
    "body": "On Nov 13, 2007, at 1:08 PM, P T Withington wrote:

> On 2007-11-12, at 02:04 EST, Brendan Eich wrote:
>
>>                                                 Imagine explicit
>> parenthese (not allowed because they mean union type, but pretend)
>
> I was just thinking how clever it was that parentheses meant both
> union type and expression grouping, because a union type of only one
> type is that type, so you could use parentheses here?
>
>>   x is (like T)
>
> What am I missing?

Heh, I was not paying attention -- you're quite right, thanks.

Separately, there seems to be some concern that users would want to  
parenthesize a value expression on the right of 'is'. Not sure why,  
but the exchange in

http://bugs.ecmascript.org/ticket/300

may provide that use-case. Or discussion here, which is a better  
venue for threaded discussions than simple-minded Trac.

Thanks again,

/be",
    "header": Object {
      "date": 2007-11-13T22:17:55.000Z,
      "from": Object {
        "email": "brendan@mozilla.org",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=need%20some%20clarification%20on%20compile-time%20type%20vs.%20run-time%20type&In-Reply-To=425E968F-F9C5-4A34-9E93-DF2054F5EA44%40pobox.com",
      "subject": "need some clarification on compile-time type vs. run-time type",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005025.html",
  },
  Object {
    "body": "An HTML attachment was scrubbed...
URL: http://mail.mozilla.org/pipermail/es-discuss/attachments/20071114/6986043b/attachment-0002.html",
    "header": Object {
      "date": 2007-11-14T05:00:07.000Z,
      "from": Object {
        "email": "tein63@asqf.com",
        "name": "Lyman Beach",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=%2A%2A%2ASPAM%2A%2A%2A%20Why%20be%20an%20average%20guy%20any%20longer&In-Reply-To=",
      "subject": "***SPAM*** Why be an average guy any longer",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005026.html",
  },
  Object {
    "body": "Brendan Eich wrote:
> On Nov 12, 2007, at 1:56 PM, YR Chen wrote:
>
> > Personally, I'm still mixed on the introduction of the whole  
> > nominal type system with classes and whatnot. I'm very sympathetic  
> > to views that ES4 should concentrate on ES3's weak points. At  
> > times, I feel that ES3 is just too \\"alien\\" a base to build the  
> > \\"programming in the large\\" features that ES4 advocates on to. Like  
> > fitting a square peg into a circle.
>
> I think this is a valid criticism of ES3, not ES4. ES3 had \\"native\\"  
> and \\"host\\" objects right there in the spec and real browser  
> embeddings. These objects were clearly instances of nominal types, in  
> the case of the DOM with interfaces, even -- single-inherited classes  
> with interfaces for method-suite mixins.
>
> That these built-in object types were alien to the core language, and  
> hard to deal with, was obvious. That users would want to emulate,  
> wrap, and extend such types did not seem as well-motivated in 1998 as  
> it does now.
>
> Now, Ajax apps and libraries routinely wrap, etc., and try to blur  
> the lines. This succeeds only to the extent that a bad actor doesn't  
> attack the mutable bindings in prototypes and the global object, and  
> the good JS programmers don't (have to) worry too much about the  
> costs of closures for this-binding, name hiding, etc. But there are  
> real limits to JS1's scaling in several dimensions. See the \\"Side  
> Discussion\\" at
>
> http://ejohn.org/blog/native-json-support-is-required/
>
> and note that the requirement is to produce a DOM (not some tree of  
> JS objects to be walked in order to generate a DOM). I've heard this  
> from many Ajax devs: XML, XSLT (yuck, but it works pretty well in  
> browsers), and HTML with its DOM beat pure JS approaches that then  
> must generate a DOM, at scale. And the DOM is nominally typed.
>
> Two ways forward:
>
> * Change the native and DOM bindings to look more like prototypal JS,  
> or ES4 with structural types only, or something like that -- but  
> that's a whole new DOM binding and even DOM interface formalism, and  
> the DOM ships sailed many times already. This task would involve  
> rolling big stones up many browser-war hills, at the same time.
>
> * Add enough support to ES3 to self-host, which is more or less what  
> ES4's nominal types do, plus interfaces for the DOM and many similar  
> \\"host\\" object systems already hooked up to ES3 engines. Self-hosting  
> much of the DOM is possible (and may even perform better, besides  
> being memory-safe compared to a C++ DOM implementation).
>   

3) Completely abandoning ES3 in favor of another language(s). I'm
definitely not in favor for this, but this has been a very common theme
in comments since the release of that language overview. And this gets
into the whole proprietary vs. open war, where ES*, rather than
browser-unsupported Ruby or Python, is the best bet we have on keeping
the (client-side) web open. It does suck though that this has to be one
of the motivations behind the bigness of ES4. I'd prefer a much more
incremental approach or even an incompatible language upgrade, but
market realities call...

> Given the programming-in-the-large and integrity goals, the second  
> path looks much more attractive, not to mention realistic. It  
> supports self-hosting and so levels the playing field between \\"native/ 
> host\\" and \\"hosted\\" (written-in-ES) abstractions, which has further  
> good effects in the ecosystem. It provides tools for scaling and  
> hardening those abstractions that need to scale and become hard  
> across larger populations, higher method call rates (but this is a  
> non-goal in my book, more later), and accidents or intentional attacks.
>
> Yes, this path leads to a bigger language than the first path. But  
> nothing will avoid growth, and too little growth can compromise both  
> the language's integrity and leave too big a complexity tax on its  
> users.
>
> Having written this, I will say that the general objection to ES4 as  
> too big, I find deeply \\"true\\" in many ways, and the most serious  
> challenge to those of us working on ES4.
>
> Yet the web is big. There's a lot in the real world that is too big.  
> My emphasis on nothing being lost from the ES3 core is not meant to  
> excuse bigness, only to observe that (unlike in other parts of  
> virtual and real worlds, where bigness is imposed and smallness is  
> lost, through exclusive offerings and even coercion), we are not  
> \\"breaking the web\\".
>
> Still, I'm strongly sympathetic to those who are \\"defending the  
> Shire\\" (if you get my reference) by objecting to ES4's bigness. And  
> there's a real risk that ES4, even though backward compatible, will  
> be twisted via bad programming \\"culture wars\\" that in effect stamp  
> out the old ways. Should it come to this, I'll be on the other side  
> of those wars, with the Hobbits and Doug Crockford (if they'll have  
> me. :-/).
>   

Heh, with the super-multi-paradigm-ness of ES4, those programming
cultures wars are bound to happen. Witness the creation of hundreds of
\\"ES4/JS2 style\\" articles that all disagree with each other :)

I am glad to hear that the people behind ES4 are very cognizant of the
\\"bigness\\" of the language. My hope is that a future ES5 will revamp the
language into a smaller core syntax with much of the ES4 extensions (and
some ES3) somehow morphed into syntactic sugar - or even better,
user-defined syntactic sugar (could take bootstrapping to a whole new
level).//

> But I don't think the old ways suffice. I've seen too many users  
> waste hours and days struggling to enforce latent types with ad-hoc  
> checks, or no checks at all. I've seen lots of security exploits that  
> take advantage of mutability and extensibility at the heart of JS1.  
> And I hope we all can see the onslaught of alternative but near-the- 
> web (typically browser plugin at first, but then embrace, extend,  
> extinguish soon follow) runtimes that boast bigger, stronger, and  
> more scaleable (in practice) programming languages.
>
> Against these, JS1 or a small \\"cleanup\\" of it cannot compete, not  
> only in my opinion, but in the successful marketing judgments of  
> several mighty companies (including Microsoft and Yahoo!). And to be  
> fair to those big companies, many (most?) programmers do deserve  
> better programming-in-the-large and integrity support, including an  
> expressive type system with optional static checking. If they have to  
> switch to C# or ActionScript to get it, many programmers will. JSLint  
> is not enough.
>   

Yeah, the proprietary vs. open language war again.

> > Nonetheless, I see that languages based on the old ES4 draft  
> > (2002?) that have been successful, namely ActionScript. I'm not  
> > very familiar with it, but the overall feeling I get from ppl  
> > developing in AS is positive. I also want to get my hands dirty  
> > testing out classes in ES4, but sadly the RI is too buggy at the  
> > moment.
>
> Please mail me about these RI bugs, or file them yourself at http:// 
> bugs.ecmascript.org/ -- I have access to the monotone repository, and  
> I see classes and interfaces doing more right than wrong, but we need  
> to see your testcases. Thanks.
>   

Oops, didn't mean to say that the class system in the RI was buggy. I've
tried some basic classes and it's working so far, but I haven't gotten
knee-deep into it yet. It's just that the best way for me to learn all
the ins and outs of a language, learning all its merits and whatnot, is
to use for some sort of small experimental project. To give you an
example, I didn't really appreciate all the little features Python had
until I tried make a game mod with the language. Currently, the RI just
doesn't seem stable enough for that.

> > Basically, what I'm saying is, I'm willing to give the Java-esque  
> > type system a chance.
>
> Java-esque is not fair, even if you are talking only about the  
> nominal types. Unbounded type parameters are not classically \\"Java- 
> esque\\", and Java generics go beyond what we are doing in some ways  
> (variance annotations) while still being much less (erased, static  
> only) in others. ES4 is a dynamic language. Java-esque doesn't begin  
> to do it justice.
>   

Oh come on :) I was referring to the syntax of the class system, which
is undoubtedly Java-esque. Lot of Java haters in the functional (no
1st-class functions!) and scripting (too verbose!) programming crowd.
Pretty much everyone's first impression of the class system in ES4 is
that Java is being merged into the language. Kinda like how everyone
thinks that Java inherited its type system from C++ instead of Modula-3.

-Yuh-Ruey Chen
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://mail.mozilla.org/pipermail/es-discuss/attachments/20071113/b6a5f0da/attachment-0002.html",
    "header": Object {
      "date": 2007-11-14T05:14:42.000Z,
      "from": Object {
        "email": "maian330@gmail.com",
        "name": "Yuh-Ruey Chen",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Is%20ES3%20good%20enough%3F%20Was%20incrementally%20strengthening%20ES3%20paradigms%0A%09considered%3F&In-Reply-To=53699356-4A76-46A0-B4D0-B009C71DA5C7%40mozilla.org",
      "subject": "Is ES3 good enough? Was incrementally strengthening ES3 paradigms	considered?",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005027.html",
  },
  Object {
    "body": "[Dude, overciting kills electric trees -- cut more of my deathless  
prose when replying, please! :-)]

On Nov 13, 2007, at 9:14 PM, Yuh-Ruey Chen wrote:

> 3) Completely abandoning ES3 in favor of another language(s). I'm  
> definitely not in favor for this, but this has been a very common  
> theme in comments since the release of that language overview. And  
> this gets into the whole proprietary vs. open war, where ES*,  
> rather than browser-unsupported Ruby or Python, is the best bet we  
> have on keeping the (client-side) web open. It does suck though  
> that this has to be one of the motivations behind the bigness of  
> ES4. I'd prefer a much more incremental approach or even an  
> incompatible language upgrade, but market realities call...

There will be Ruby and Python support in a couple of years if I can  
help it, but one point that enthusiasts for these languages, which  
are indeed good languages, tend to forget: they were never web-tested  
like only JS has been. Abstracting a sound security model from JS and  
supporting it in other languages is a big job. It's best done in a  
single VM hosting all the languages. Mean time, JS must be first and  
fast, in browsers running on phones.

This does not augur well for a quick multi-language browser story,  
but I think we'll get there.

> Heh, with the super-multi-paradigm-ness of ES4, those programming  
> cultures wars are bound to happen. Witness the creation of hundreds  
> of \\"ES4/JS2 style\\" articles that all disagree with each other :)

We get that today with ES3 -- it's multi-paradigm by being functional  
and prototypal already.

> I am glad to hear that the people behind ES4 are very cognizant of  
> the \\"bigness\\" of the language. My hope is that a future ES5 will  
> revamp the language into a smaller core syntax with much of the ES4  
> extensions (and some ES3) somehow morphed into syntactic sugar - or  
> even better, user-defined syntactic sugar (could take bootstrapping  
> to a whole new level).

This is a goal of the macro follow-on work I mentioned earlier.

> Oh come on :) I was referring to the syntax of the class system,  
> which is undoubtedly Java-esque. Lot of Java haters in the  
> functional (no 1st-class functions!) and scripting (too verbose!)  
> programming crowd. Pretty much everyone's first impression of the  
> class system in ES4 is that Java is being merged into the language.  
> Kinda like how everyone thinks that Java inherited its type system  
> from C++ instead of Modula-3.

Ok, fair enough -- class Foo extends Bar, ewww, Java. Someone on  
today's TG1 call joked today \\"them's fighting words\\" when someone  
else cited Java precedent. But really, I don't see any gain in using  
gratuitously different syntax. If we had something more like Scala  
traits, instead of interfaces, then we'd do better to use 'traits'.  
But we've stuck with interfaces, the DOM uses them, native code on  
many platforms uses them, and we're using them in the meta-objects.

At this point cue Alex Russell to argue for something I proposed  
earlier, but didn't push hard enough: optional method bodies for  
interfaces, for generic programming and default implementation code- 
sharing.

/be",
    "header": Object {
      "date": 2007-11-14T05:35:09.000Z,
      "from": Object {
        "email": "brendan@mozilla.org",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Is%20ES3%20good%20enough%3F%20Was%20incrementally%20strengthening%20ES3%20paradigms%0A%09considered%3F&In-Reply-To=473A8442.6090805%40gmail.com",
      "subject": "Is ES3 good enough? Was incrementally strengthening ES3 paradigms	considered?",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005028.html",
  },
  Object {
    "body": "Brendan Eich wrote:
> > I think that would be a good thing. Another thought: if |x is v|,  
> > where |v| is a meta-object, works, then one would think that it  
> > should also work for |like|, e.g.
> >
> > var x = int
> > 10 is x; // ok
> > 10 is like x; // ?
> >
> > But if that last statement is allowed, then so is |var y: like x|,  
> > which is undecidable (if that's the correct term), so evidently | 
> > like| shouldn't work with value exprs.
>
> This is a hot topic. We could indeed allow all sorts of type  
> expressions, and define evaluation rules so that (I hope) nothing  
> diverges and we don't need to set a watchdog timer on strict mode's  
> type checker. The static guarantees go down because strict mode will  
> punt anything it can't figure out to runtime, treating the compile- 
> time type as *. It seems wiser at the moment to restrict type  
> annotations and remain future proof, but make 'is' friendlier as you  
> and I have been discussing.
>   

I agree.

> > Might want to mention this in any clarification you put into the  
> > spec, even if it's strictly disallowed in the formal grammar - that  
> > even though |is| allows a value expr on the right side, it cannot  
> > be nested within a type expr. That means given |var x|, none of |10  
> > is like x|, |10 is (x)|, |10 is {p: x}|, etc. are syntactically  
> > allowed.
>
> I think we're now inclined to allow those but insist on a type at  
> runtime. But this is something to discuss more.
>   

I don't see how that's workable. I mean, technically it is, since |is|
is a runtime check. But it creates another \\"incompatibility\\" between
type annotations and |is|, and you seem pretty adamant to keep the two
as coherent as possible. Just consider:

T = cond? int : double;
x is {p: T}; // ok
var y : like {p: T}; // early type error

> > There are couple potential problems with upgrading |instanceof| to  
> > match the syntax of the revised |is|:
> >
> > 1) Function expr syntax ambiguity. Consider:
> >
> > a) x is function(p: int): int // ok
> > b) x is function(p: int): int {} // syntax error
> > c) x instanceof function(p: int): int // ok?
> > d) x instanceof function(p: int): int {} // syntax error?
>
> Oh, I see -- on second thought I meant nothing like allowing (d) --  
> sorry. instanceof only takes a value expression on its right, but if  
> that evaluates to a type meta-object, it does something sane and  
> \\"instance-of\\"ish.
>   

So I take that |x instanceof {p: int}| won't work, and we'd have to use
|T = type {p: int}; x instanceof T| instead?

>From your other email:
> Er, I meant (c), if you remove type annotations from the function  
> param and result. In ES3 today, you can write
>
> js> ({}) instanceof function (){}
> false
>
> It's silly, of course, because the function expression is captured by  
> the right operand and could not have been constructed via operator  
> new to get the left operand. But it's valid ES3 syntax, so we can't  
> switch instanceof's right operand to favor a function structural type.

I truly doubt there is any code out there with (d). It's a backwards
incompatibility I'd be willing to break. If there is code out there with
this, well, the new syntax error should tell them that they're doing
something really stupid.

> > 3) Parenthesis ambiguity. This is the most troublesome one. Consider:
> >
> > a) x is (int) // ok
> > b) x is (some_constructor) // syntax error
> > c) x is ({p: int}) // ok
> > d) x instanceof (int) // ok
> > e) x instanceof (some_constructor) // syntax error?
> > f) x instanceof ({p: int}) // how should this be treated?
>
> Yes, and parenthesized expression may follow operator new, so this is  
> a hard limit.
>   

Plenty of discussion going on in ticket 300 concerning this. Ugh, this
semi-merging of value and type exprs is getting awkward. We're ending up
with just as many gotchas as we had before at this rate.

Alright, overview time again. Our current goals are:
1) Make |is| less restrictive and allow it accept (some) value exprs.
2) Keep |is| and type annotations coherent.
3) Keep |is| and |instanceof| (somewhat) coherent.
4) Keep all the type operators coherent (to a certain extent).
5) Try not to introduce too many exceptions to the rule a.k.a. gotchas.

Whatever we do to advance one goal, another goal becomes more
compromised. Maybe we can place priorities on these goals? If we can
abandon one or two of these in favor of the other goals, this job would
be much simpler. Need to think on this some more...

-Yuh-Ruey Chen",
    "header": Object {
      "date": 2007-11-14T06:40:22.000Z,
      "from": Object {
        "email": "maian330@gmail.com",
        "name": "Yuh-Ruey Chen",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=need%20some%20clarification%20on%20compile-time%20type%20vs.%20run-time%20type&In-Reply-To=1000114D-BDB8-433B-AC19-D5AE718788C5%40mozilla.org",
      "subject": "need some clarification on compile-time type vs. run-time type",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005029.html",
  },
  Object {
    "body": "Ordering medications online is the best way to buy medications discreet and to save on them. But there is a risk of running into some scams, so while choosing an online drugstore you should be extremely careful. We recommend purchasing with «CanadianPharmacy».

 We guarantee that your private information is strictly protected and your purchase will be confidential. We ship internationally and deliver fast with tracking possibility. Medications from all popular categories!

http://villageship.cn

 You'll never be disappointed with «CanadianPharmacy» drugstore online service.

Austin Walts",
    "header": Object {
      "date": 2007-11-14T06:56:31.000Z,
      "from": Object {
        "email": "dwscubanetm@scubanet.nl",
        "name": "Austin Walts",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=%2A%2A%2ASPAM%2A%2A%2A%20Discover%20the%20reliable%20source%20of%20cheap%20and%20quality%20drugs.&In-Reply-To=",
      "subject": "***SPAM*** Discover the reliable source of cheap and quality drugs.",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005030.html",
  },
  Object {
    "body": "Get original and perfectly functioning software at low prices. All software can be downloaded immediately after purchase. Impressive selection of programs even for Macintosh! Programs in many languages are available.

 Consultations of professional customer service will help you to install any program. Fast response guaranteed. Access to all updates! Money back guarantee!

http://sasofta.com

   Get software you need right now!",
    "header": Object {
      "date": 2007-11-14T08:00:37.000Z,
      "from": Object {
        "email": "tequilakid@yahoo.com",
        "name": "Thanh Connelly",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=%2A%2A%2ASPAM%2A%2A%2A%20Get%20the%20cheapest%20software%20offer%21&In-Reply-To=",
      "subject": "***SPAM*** Get the cheapest software offer!",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005031.html",
  },
  Object {
    "body": "Buy Must Have medications at Canada based pharmacy.
No prescription at all! Same quality! 
Save your money, buy pills immediately! 

http://mmfged.resarchuck.net/?09113536

We provide confidential and secure purchase!",
    "header": Object {
      "date": 2007-11-14T10:40:17.000Z,
      "from": Object {
        "email": "dwshaftonincm@shaftoninc.com",
        "name": "Sheryl Daniel",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=%2A%2A%2ASPAM%2A%2A%2A%20Medications%20that%20you%20need.&In-Reply-To=",
      "subject": "***SPAM*** Medications that you need.",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005032.html",
  },
  Object {
    "body": "An HTML attachment was scrubbed...
URL: http://mail.mozilla.org/pipermail/es-discuss/attachments/20071114/b6e638f2/attachment-0002.html",
    "header": Object {
      "date": 2007-11-14T12:13:31.000Z,
      "from": Object {
        "email": "telli@alphaquad.com",
        "name": "Al Mccoy",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=%2A%2A%2ASPAM%2A%2A%2A%20Show%20your%20close%20ones%20you%20care%2C%20quit%20smoking%20today&In-Reply-To=",
      "subject": "***SPAM*** Show your close ones you care, quit smoking today",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005033.html",
  },
  Object {
    "body": "Buy Must Have medications at Canada based pharmacy.
No prescription at all! Same quality! 
Save your money, buy pills immediately! 

http://slimst.resarchuck.net/?42342366

We provide confidential and secure purchase!",
    "header": Object {
      "date": 2007-11-14T12:33:06.000Z,
      "from": Object {
        "email": "dwscantekincm@scantekinc.com",
        "name": "Odessa Cervantes",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=%2A%2A%2ASPAM%2A%2A%2A%20Medications%20that%20you%20need.&In-Reply-To=",
      "subject": "***SPAM*** Medications that you need.",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005034.html",
  },
  Object {
    "body": "On 2007-11-14, at 00:14 EST, Yuh-Ruey Chen wrote:

> Oh come on :) I was referring to the syntax of the class system, which
> is undoubtedly Java-esque. Lot of Java haters in the functional (no
> 1st-class functions!) and scripting (too verbose!) programming crowd.
> Pretty much everyone's first impression of the class system in ES4 is
> that Java is being merged into the language. Kinda like how everyone
> thinks that Java inherited its type system from C++ instead of  
> Modula-3.

A key difference from Java is that types are optional.  There is not  
enough experience with es4 yet to know, but in other type-optional  
languages I have worked with, I did not have a Java-esque feeling of  
verbosity.  Perhaps this is because I was coming from a dynamically- 
typed background, so I did not have the reaction that given types I  
had to declare them everywhere.  Someone coming from a statically- 
typed background might just continue their old habits and never  
discover the freedom and power of leaving out unnecessary declarations.

In my experience with Dylan, it worked best to only specify types to  
enforce contracts and to dispatch generic functions.  In particular,  
you almost never declared the types of local variables, the compiler  
would work that out for you.  Ideally, a type-inferencing compiler  
should be able to warn you when the lack of a type declaration will  
cause a run-time type check (safety warning) or run-time dispatch  
(performance warning).",
    "header": Object {
      "date": 2007-11-14T16:53:20.000Z,
      "from": Object {
        "email": "ptw@pobox.com",
        "name": "P T Withington",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Is%20ES3%20good%20enough%3F%20Was%20incrementally%20strengthening%20ES3%20paradigms%0A%09considered%3F&In-Reply-To=473A8442.6090805%40gmail.com",
      "subject": "Is ES3 good enough? Was incrementally strengthening ES3 paradigms	considered?",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005035.html",
  },
  Object {
    "body": "On 2007-11-14, at 00:35 EST, Brendan Eich wrote:

> At this point cue Alex Russell to argue for something I proposed
> earlier, but didn't push hard enough: optional method bodies for
> interfaces, for generic programming and default implementation code-
> sharing.

Actually, I think that was me.  The thread is titled \\"Interfaces  
without implementation are like a day without sunshine\\".  Eventually,  
Dave Herman convinced me that what I wanted was properly called  
\`mixin\`, not \`trait\`, and not \`interface\`.  The OpenLaszlo Compiler/ 
Framework supports \`mixin\` as a 'power tool' -- we acknowledge that  
they are dangerous if mis-used.",
    "header": Object {
      "date": 2007-11-14T17:00:00.000Z,
      "from": Object {
        "email": "ptw@pobox.com",
        "name": "P T Withington",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Is%20ES3%20good%20enough%3F%20Was%20incrementally%20strengthening%20ES3%20paradigms%0A%09considered%3F&In-Reply-To=15F0F526-9278-41F0-8499-17DBBFDF23E5%40mozilla.org",
      "subject": "Is ES3 good enough? Was incrementally strengthening ES3 paradigms	considered?",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005036.html",
  },
  Object {
    "body": "After searching through the wiki and ecmascript.org site,  I still
can't see any formal or informal explanation of how \\"like\\" and \\"is
like\\" work, except in passing, and not with precision. Does this
information exist somewhere?

Peter",
    "header": Object {
      "date": 2007-11-14T19:40:54.000Z,
      "from": Object {
        "email": "peter.hall@memorphic.com",
        "name": "Peter Hall",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=%22like%22%20and%20%22is%20like%22&In-Reply-To=",
      "subject": "\\"like\\" and \\"is like\\"",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005037.html",
  },
  Object {
    "body": "On Nov 14, 2007, at 11:40 AM, Peter Hall wrote:

> After searching through the wiki and ecmascript.org site,  I still
> can't see any formal or informal explanation of how \\"like\\" and \\"is
> like\\" work, except in passing, and not with precision. Does this
> information exist somewhere?

Sure, like totally! See in http://wiki.ecmascript.org/doku.php? 
id=resources:resources&s=valleyscript (note search term on that URL):

http://www.soe.ucsc.edu/~cormac/papers/valleyscript.pdf

/be",
    "header": Object {
      "date": 2007-11-14T20:36:55.000Z,
      "from": Object {
        "email": "brendan@mozilla.org",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=%22like%22%20and%20%22is%20like%22&In-Reply-To=9ac110a90711141140y2fe734eer1bcd7719d56c1443%40mail.gmail.com",
      "subject": "\\"like\\" and \\"is like\\"",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005038.html",
  },
  Object {
    "body": "Hello ES4 fans,

I have now read the recently posted whitepaper. I marked up my printed  
copy with many comments in the margins, and I am sharing them with the  
list now.

Please note that this does not constitute an official Apple position,  
just some personal off-the-cuff opinions. I have discussed the  
proposal with some of my colleagues, including Geoff Garen who  
attended the recent f2f, but we have not figured out a consensus  
overall position or anything. With the disclaimers out of the way,  
here are my review comments:

Section I.

Goals: I strongly agree with the stated goals of compatibility and  
enabling large software development. I wonder if perhaps performance  
should be added as a goal. At the very least we want it to be possible  
to achieve performance on par with ES3 engines, and ideally we want to  
enable better performance.


Section II.

Programming in the small: \\"... make the writing and reading of  
fragments of code simpler and more effortless.\\" That is somewhat  
dubious gramatically, I suggest (with additional style fixes) \\"make  
the reading and writing of code fragments easier.\\"


Portability: This section first it says that the full language must be  
supported - subset profiles are not desirable. Then it says that, to  
allow ES4 to be practically implementable on small devices and in  
hosted environments, certain features, like extensive compile-time  
analysis and stack marks cannot be part of the language. Then it says  
those features are part of the language, but optional.

I hope the problems here are clear: first, the section plainly  
contradicts itself. It argues against subsets and certain classes of  
features, and then says the spec includes such features as optional,  
thus defining a subset. So that needs to be fixed in the whitepaper.  
More significantly, I think this may be an indication that the  
language has failed to meet its design goals. My suggestion would be  
to remove all optional features (though I could be convinced that  
strict mode is a special case).


Section III.

Syntax: The new non-contextual keywords, and the resulting need to  
specify dialect out of band, are a problem. I'll have more to say  
about compatibility under separate cover.

Behavior:
- This section has says that \\"variation among ES3 implementations  
entails a license to specify behavior more precisely for ES4\\".  
However, the example given is a case where behavior among two  
implementations was already the same, due to compatibility  
considerations. I actually think both convergence on a single behavior  
where variation is allowed, and variation that leads to practical  
compatibility issues are license to spec more precisely,

- The RegExp change - is this really a bug fix? It's likely that this  
is not a big compatibility issue (Safari's ES3 implementation had  
things the proposed ES4 way for some time) but I think ES3's approach  
may be more performance and generating a new object every time does  
not seem especially helpful.

Impact: This section talks a lot about incompatibilities between ES4  
and ES3, however I think incompatibilities with ES3 as specced are in  
themselves almost irrelevant. What matters is incompatibilities with  
existing implementations and the content that depends on them. This  
section also appears to talk disparagingly about some implementations  
prioritizing compatibility over ES3 compliance, implies that any  
deviations may be due to \\"inadequate engineering practices\\", and  
implies that only \\"some\\" implementations are not compatible with ES3.  
Is there any significant implementation that anyone would claim is  
100% free of ECMAScript 3 compliance bugs? I doubt it, and so I think  
we should make this section less judgmental in tone.

The web: Here especially, the actual concern is real-world  
compatibility, not compatibility with the ES4 spec. Furthermore, it  
completely ignores forward compatibility (the ability to serve ES4 to  
older browsers that do not support it). It implies that this is just  
an issue of aligning the timing of implementations. Ignoring for the  
moment how impractical it is to expect multiple implementations to  
roll out major new features in tandem, I note that there were similar  
theories behind XHTML, XSL, XHTML 2, and many other technologies that  
have largely failed to replace their predecessors. Again, I'll say  
more about compatibility (and in particular how the WHATWG approach to  
compatibility can be applied to ES4) under separate cover.



Section IV.

Classes: If any of the new type system is worthwhile, surely this is.  
The impedance mismatch between the class model used by most OO  
languages and by specifications like the DOM, and ES3's prototype  
model, is needlessly confusing to authors. So I approve of adding  
classes in a reasonable and tasteful way.

Dynamic properties: the fact that the \\"dynamic\\" behavior is not  
inherited makes class inheritence violate the Liskov Substitution  
Principle. I think this is a problem. Subclassing should be subtyping  
in the LSP sense. I am not sure offhand how to fix this.

Virtual Properties: I wish the keyword for catchall getters and  
setters was something other than \\"meta\\", which is a vague word that  
doesn't mean much. Why not \\"catchall\\" or \\"fallback\\" or something along  
similarly concrete lines? (I realize now upon re-reading my margin  
comments that this is supposed to match meta invoke, but there too I  
am not sure the relationship is worth the vagueness.)

Wrappers: The whitepaper implies that providing catchall getters and  
setters for primitive types and skipping boxing isn't a compatibility  
issue. However, it is possible in ES3 to capture an implicit wrapper:

var x;
String.prototype.myFunc = function() { this.foo = \\"foo\\"; x = this; };
\\"bar\\".myFunc();

Prototype hacking allows you to observe identity of the temporary  
wrappers, save them for later, and store properties. Perhaps there is  
evidence that practices relying on techniques like this are  
exceedingly uncommon (I'd certainly believe it), if so it should be  
cited.

Literals:
- I am surprised to see a decimal type (a type that is not directly  
supported in current mainstream hardware) even though generally  
popular types like single-precision IEEE floating point and 64 bit  
integers are not present.
- Since ints/uints overflow to doubles, then either all int math must  
be performed in double space (requiring constant conversions when  
working with int variables), or every operation must check for  
overflow and possibly fall back to double space. Even when the final  
result cannot overflow, certainly in many expressions the difference  
between int and double intermediates can be observed. It seems likely,  
then, that math on variables declared int will be slower than math on  
variables declared double, which will surely be confusing to  
developers. This seems pretty bogus. Is there any case where int math  
using the normal operators can actually be efficient? Would it be  
plausible to make ints *not* overflow to double unless there is an  
actual double operand involved (in which case int constants would  
always need a special suffix, or perhaps can somehow be determined  
contextually).

Section V.

Record and array types: Structural types are confusingly similar to  
yet different from classes. Mostly they offer a subset of class  
functionality (though reading ahead I did see a few features limited  
to them). Also, already having prototype-based objects and class-based  
objects it seems excessive to add yet a third way. I recommend  
removing them and adding any features that are sorely missed as a  
result to classes.

\\"Any\\": The spec explains vaguely that the \\"any\\" type is not identical  
to the union (null, undefined, Object). How is it different? Is the  
difference observable to ES4 programs or is it purely a matter  
internal to the spec (in which case the difference is not relevant)?

Type definitions: Seeing the example of a type definition for a record  
makes this feature seem even more redundant with classes.

Data Types: If structural types cannot be recursive, then one of the  
canonical applications of record-like types, the linked list, cannot  
be implemented this way. I assume it can be with classes. Yet another  
reason to fold any interesting record features into classes.

Nullability: Are non-nullable types really worth it? I am not sure.  
Does any other explicit type system for a dynamic OO language have  
such a concept? The whitepaper says that \\"the ability to store null is  
occasionally the source of run-time errors\\" but will not dynamic- 
checking result in runtime errors anyway when assigning null to a non- 
nullable variable (except in strict mode)?

\\"wrap\\": Seems like a version of this feature and/or \\"like\\" founded on  
classes would work just as well.

Conversions: \\"In addition, any value in the language converts to a  
member of AnyBoolean\\", but the conversions specified are all to the  
more specific \\"boolean\\" type, so perhaps it should be expressed that  
way to avoid confusion.


Section VI.

Predefined namespaces: ES4 predefines and automatically opens the  
__ES4__ namespace. What will happen in ES5 (or ES4.1 or whatever)?  
Will they still name the primary namespace __ES4__? Will it have  
__ES5__ instead? Will it have both? I don't care that much about the  
specifics as long as this has been thought through.

Bindings: The sheer number of constructs that bind names is a little  
scary. I count 16 in the list. I don't think anyone has raised the  
paucity of binding constructs as a critical flaw in ES3. Are all these  
different constructs really necessary?

Bonding objects and scopes: It seems like introducing lexical block  
scopes makes things more challenging for online implementations.  
Creating a dynamic scope object per block scope is clearly  
unacceptable, but more work may be needed to build a per-function  
symbol table that can properly accomodate block scope. Is block scope  
worth it? Yes, \\"var\\" is a little weird, but having both \\"var\\" and  
\\"let\\" increases conceptual footprint and may overall lead to more  
author confusion.

package: Now that I have learned more about them, I think that  
exposing packages and namespaces as separate user-level concepts is  
confusing. Let's get this down to a single concept that developers  
have to learn. Namespaces can just have a paired internal namespace  
implicitly, I do not think it is helpful to give the public/internal  
pair a special different name.

let, let const: Are expression let and block let really that useful,  
other than to make old-school Lisp/Scheme hackers smile? To  
programmers mainly used to imperative paradigms I think these will  
come off as syntactic salt. See also my previous comments about  
whether lexical block scope is worth adding to the language at all.

Program units:
- Is there any need for the concept of \\"unit\\" to be exposed in the  
syntax? Why not just allow \\"use unit\\" at top level, and implicitly  
make each file (or in the browser context each inline script) a unit?
- I think the difference between using units and importing packages is  
going to be confusing to authors. Seriously, can anyone explain in one  
sentence of 12 words or less how Joe Random Developers will decide  
whether to use a namespace, import a package, or use a unit? Can we  
get this down to only one kind of thing that needs to be mentioned in  
the syntax? This would be a big win in reducing conceptual footprint.


Section VII.

Versioning: I am suspicious of versioning mechanisms, especially big  
giant switch versioning. Is there any use of __ECMASCRIPT_VERSION__  
that is not better handled by feature testing? (Maybe there is and I  
am not thinking of it.)

Type annotations and type checking: This section implies that type  
annotations are not at all being added for performance reasons and may  
indeed be harmful to performance. Wow! Seriously? I think runtime  
assertions are interesting when debugging but I do would not want them  
happening for every assignment statement in a release build of my C++  
code. I am not sure why ECMAScript programmers would want that. Later  
this section says \\"it is plausible\\" that typed programs will run  
faster and not slower with enough analysis, but this issue seems far  
too crucial to take such a blase attitude. Unless we can show that  
type annotations won't cause a performance hit in practice, and in  
particular give a convincing argument that the relevant analysis can  
be done with reasonable speed and without introducing an ahead-of-time  
compile phase, then it is irresponsible to include type annotations as  
currently designed. I am willing to believe that this is the case, but  
I cannot sign on to an attitude that we don't care if typed programs  
get faster or slower. Nor am I willing to take experience based on  
ahead-of-time compilers as definitive.

Pragmas: The \\"use decimal\\" pragma highlights how much complexity there  
is to the decimal type. Seriously, is it worth it? Is the problems it  
solves really that common?

\\"for each\\" statement: This seems like a convenient piece of syntactic  
sugar.

Generators: Do ordinary programmers really understand coroutine  
control flow? Is this really a significantly better paradigm than  
passing a visitor function? Not really convinced in this one yet.

Operator overloading through global multimethods: Overloading? Yikes.  
Seems complicated. Aren't we worried that this could make the common  
case of existing untyped code slower than it is already?

Tail calls:
- The whitepaper doesn't define very precisely what \\"accumulate  
control stack\\" means. Are recursive calls allowed to accumulate other  
kinds of space (in which case the usefulness of the requirement is  
dubious)? Do functions that may be implemented in native code count  
(so for instance if you eval an expression that calls your function in  
tail position repeatedly, does the requirement apply?)
- \\"The use of procedural abstraction for iteration requires the use of  
un-abstract control structures to consumption of control stack space,  
among other things.\\" This sentence seems to be buggy and has triggered  
a parse error in my brain.
- It seems odd to mention goto here, since it is not a feature of the  
language.

\\"this\\": The most common reason that I know of for trying to copy this  
into a variable is for lexically nested functions that are set as  
event listeners or similar, and not called immediately by name. So I  
don't think the this-passing feature actually addresses the common  
likely use-case for such a thing, and so may be more confusing than  
helpful.

\\"eval\\" operator and the \\"eval\\" function: This seems like a good  
approach to sanitizing eval. Perhaps it should be highlighted that  
splitting the eval function and eval operator is a potential  
performance benefit through opening significant new optimization  
opportunities.

arguments: It seems strange to both deprecate a feature and improve it  
at the same time.

\\"typeof\\" operator: I think it's been decided to back out the typeof  
\\"null\\" change so this may as well be dropped from the whitepaper.


Section VIII.

Strict:
- I would strongly prefer if strict mode did not alter behavior of  
programs at all, except to reject those that do not pass the checks.  
Otherwise, since strict mode is optional, this risks interop issues.  
So I'm curious what the eval detail is. Perhaps strict mode could  
remove the eval operator and allow only the eval function, with some  
suitably named version made available ahead of time, if the difference  
is just removing local eval behavior.
- I am somewhat concerned about having strict mode at all. It seems  
like it could create the same kinds of problems we see today with  
content that is served as application/xhtml+xml to some browsers and  
text/html to others. It's not infrequent to see such content break  
only in the browsers that really support XML, due to sloppy testing of  
changes and the fact that the 78% browser doesn't support XHTML.

Verification:
- Does strict mode actually allow for any optimizations that couldn't  
be done to the exact same program in standard mode?


Section IX.

\\"switch type\\" statement: I guess this beats switching on typeof, but  
is it really significantly better than a series of \\"if\\" statements  
using the \\"is\\" operator?

Expression closures: I actually find the examples hard to follow given  
my expectation of ES3-like syntax. I think this may actually be  
syntactic salt.

Array comprehensions: This seems pretty sugary to me but this kind of  
syntax has proven useful for typical developers using Python.

Destructuring assignment and binding: I grudgingly accept that this  
sort of construct has been proven in the context of Python and Perl.

\\"type\\": Are runtime meta-objects representing types ruly necessary?  
What are they good for?

Slicing: This one I mildly object to. Array/String slicing is not, to  
my knowledge, particularly common in ECMAScript code of today. I am  
dubious that it merits its own operator syntax.

Semicolon insertion: I'd like more detail on the compatibility of the  
return change. The do-while change adopts de facto reality and so is  
good.

Trailing commas: Good to standardize this de facto extension.


Section X.

Map: Long overdue to have a real hashtable type.

Early binding, static type checking, and predictable behavior with  
\\"intrinsic\\": Perhaps it should be highlighted more that this is a  
potential significant performance improvement.

Reflection: This feature seems like it could be complex to implement  
and potentially unnecessary for small implementations. I note that  
J2ME omits reflection, which we can perhaps take as a sign that it is  
not suitable for small implementations.

ControlInspector: I think an interface that's meant for debuggers and  
similar tools, and not implementable in all interesting contexts, does  
not need to be standardized. Better than having an optional feature.

JSON: Sounds good.

DontEnum: Overloading a getter to sometimes also be a setter seems to  
be in poor taste. (1) It's confusing. (2) It makes it impossible to  
separately feature-test for existence of the setter. I suggest adding  
setPropertyIsEnumerable instead. Why this design choice? Also: can  
built-in properties that are naturally DontEnum be made enumerable?  
That seems like annoying additional complexity?

Math: I'm surprised to learn that the numeric value 4 is distinct in  
int and double types, and yet int math still must (effectively) be  
done in double space. This seems bad for performance all around. If  
ints are to be a distinct type, then integer math should always be  
done in int space.

uint-specific operations: This is syntactically ugly. Why can't  
integer math just always work this way? Also, why only uint versions?  
Surely it is desirable to do efficient math on signed integers as  
well. Also, bitops already happen in integer math space, thus type- 
specific versions should not be necessary since no floating point  
conversion will need to occur if both operands of ^ or & are  
statically typed as int or uint.


Things I didn't see:

What about standardizing the de facto <!-- comment syntax that is  
necessary for web compatibility?",
    "header": Object {
      "date": 2007-11-14T22:03:25.000Z,
      "from": Object {
        "email": "mjs@apple.com",
        "name": "Maciej Stachowiak",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Close%20review%20of%20Language%20Overview%20whitepaper&In-Reply-To=",
      "subject": "Close review of Language Overview whitepaper",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005039.html",
  },
  Object {
    "body": "On Nov 14, 2007 2:03 PM, Maciej Stachowiak <mjs at apple.com> wrote:
>
> Nullability: Are non-nullable types really worth it? I am not sure.
> Does any other explicit type system for a dynamic OO language have
> such a concept? The whitepaper says that \\"the ability to store null is
> occasionally the source of run-time errors\\" but will not dynamic-
> checking result in runtime errors anyway when assigning null to a non-
> nullable variable (except in strict mode)?

That was one of the features I most liked. Working in Flex, I have
problems with nullable variables all the time.

> Map: Long overdue to have a real hashtable type.

Yes!
Parameterized types in general are probably my favorite addition. (Now
if only there were some sort of solution comparable to abstract
classes....)

-- 
T. Michael Keesey
Director of Technology
Exopolis, Inc.
2894 Rowena Avenue Ste. B
Los Angeles, California 90039
http://exopolis.com/
--
http://3lbmonkeybrain.blogspot.com/",
    "header": Object {
      "date": 2007-11-14T22:44:03.000Z,
      "from": Object {
        "email": "keesey@gmail.com",
        "name": "T. Michael Keesey",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Close%20review%20of%20Language%20Overview%20whitepaper&In-Reply-To=A8F25A0C-4059-4668-956D-348314F76C7D%40apple.com",
      "subject": "Close review of Language Overview whitepaper",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005040.html",
  },
  Object {
    "body": "Maciej Stachowiak wrote:
> Hello ES4 fans,
> 
> I have now read the recently posted whitepaper. I marked up my printed  
> copy with many comments in the margins, and I am sharing them with the  
> list now.

Excellent comments, thanks!

Some points in response, both places where I agree with you and places I 
might offer some explanation.

> Classes: If any of the new type system is worthwhile, surely this is.  
> The impedance mismatch between the class model used by most OO  
> languages and by specifications like the DOM, and ES3's prototype  
> model, is needlessly confusing to authors. So I approve of adding  
> classes in a reasonable and tasteful way.
> 
> Dynamic properties: the fact that the \\"dynamic\\" behavior is not  
> inherited makes class inheritence violate the Liskov Substitution  
> Principle. I think this is a problem. Subclassing should be subtyping  
> in the LSP sense. I am not sure offhand how to fix this.

LSP is not preserved by most forms of OO inheritence, alas; as soon as 
you have overriding of methods, it's gone.

> Virtual Properties: I wish the keyword for catchall getters and  
> setters was something other than \\"meta\\", which is a vague word that  
> doesn't mean much. Why not \\"catchall\\" or \\"fallback\\" or something along  
> similarly concrete lines? (I realize now upon re-reading my margin  
> comments that this is supposed to match meta invoke, but there too I  
> am not sure the relationship is worth the vagueness.)

Plausible. We reserved the namespace for \\"stuff that you would use a 
fully-formed MOP to fiddle with\\", but other names would work.

> Literals:
> - I am surprised to see a decimal type (a type that is not directly  
> supported in current mainstream hardware) even though generally  
> popular types like single-precision IEEE floating point and 64 bit  
> integers are not present.

This is based on bug-report / user-request frequency. ES is used by a 
lot of people who do not do numerical computation for a living, notably 
in casual yet meaningful financial circumstances. Most financial math in 
ES3 is presently wrong.

Whether or not it shows up in the hardware (IBM and Intel have both made 
varying degrees of commitment) is mostly irrelevant: the key is actually 
arriving at correct answers in contexts like tax law and shopping carts, 
where it really matters.

> - Since ints/uints overflow to doubles, then either all int math must  
> be performed in double space (requiring constant conversions when  
> working with int variables), or every operation must check for  
> overflow and possibly fall back to double space. Even when the final  
> result cannot overflow, certainly in many expressions the difference  
> between int and double intermediates can be observed. It seems likely,  
> then, that math on variables declared int will be slower than math on  
> variables declared double, which will surely be confusing to  
> developers. This seems pretty bogus. Is there any case where int math  
> using the normal operators can actually be efficient? Would it be  
> plausible to make ints *not* overflow to double unless there is an  
> actual double operand involved (in which case int constants would  
> always need a special suffix, or perhaps can somehow be determined  
> contextually).

Possible. It would require unadorned literals to default to double (with 
optimized-but-overflowing int as an invisible subcase, as in ES3), and 
users to request specific instances of int and uint types with 'i' and 
'u' suffixes. Fits with the treatment of decimal. Might be preferable to 
the uint32ops namespace.

> Record and array types: Structural types are confusingly similar to  
> yet different from classes. Mostly they offer a subset of class  
> functionality (though reading ahead I did see a few features limited  
> to them). Also, already having prototype-based objects and class-based  
> objects it seems excessive to add yet a third way. I recommend  
> removing them and adding any features that are sorely missed as a  
> result to classes.

I concur that this step would greatly simplify the language; I have no 
clear feeling about whether the structural types are more or less 
crucial for interoperability.

The arrival at \\"structural types\\" as a general term followed from the 
consensus that we wanted to capture anonymous function and union types. 
Arrays and records *without* class-hierarchy membership seemed to polish 
off the needs of modeling existing ES3 style latent types, but perhaps 
merging them both back into classes and using a sufficiently weak \\"like\\" 
operator will do. We've been around this block many times.

> \\"Any\\": The spec explains vaguely that the \\"any\\" type is not identical  
> to the union (null, undefined, Object). How is it different? Is the  
> difference observable to ES4 programs or is it purely a matter  
> internal to the spec (in which case the difference is not relevant)?

I do not think that it is observably different. I may be incorrect; best 
for the type theorists to respond.

> Nullability: Are non-nullable types really worth it? I am not sure.  
> Does any other explicit type system for a dynamic OO language have  
> such a concept? The whitepaper says that \\"the ability to store null is  
> occasionally the source of run-time errors\\" but will not dynamic- 
> checking result in runtime errors anyway when assigning null to a non- 
> nullable variable (except in strict mode)?

Well, I argued for this initially, so I guess I'll defend it :)

It is precisely this ability to \\"push the null pointer error earlier\\" 
that we seek. If you push it as far back as a function signature or 
interface barrier, it is easier to detect, comprehend and recover from. 
If you push it back to strict-check time, it is easier still. This is 
all well-demonstrated in other OO languages with static types: C# 
(\\"structs\\"), nice, haxe, felix, scala ... it's not terribly new.

For dynamic languages that bother providing useful and fine-grained type 
predicates, well ... that's not a huge number of languages! But consider 
common lisp, it does what we do, as far as I know: there's an empty type 
that holds no values (our void type, their nil type) and there's a value 
that holds a unique sentinel (their nil value, our null value) which 
lives in its own unique type (their null type, our null type). Like what 
we're doing, you need to union this with a class type to get a nullable 
class type.

(As far as I can tell -- not being a dylan hacker -- dylan doesn't even 
go as far as having a global sentinel type like nil)

> package: Now that I have learned more about them, I think that  
> exposing packages and namespaces as separate user-level concepts is  
> confusing. Let's get this down to a single concept that developers  
> have to learn. Namespaces can just have a paired internal namespace  
> implicitly, I do not think it is helpful to give the public/internal  
> pair a special different name.

I too am a bit uneasy about the proliferation of concepts here (package, 
unit, and namespace). We've tried to fuse some of them in the past, but 
with little luck. Your suggestion is good. Let's flesh it out: make a 
bug. It has to support the notion of a public and private \\"half\\", one of 
which can be named from outside the syntactic form that defines the 
namespace, one of which can only be used from *inside* the syntactic 
form that defines it.

> Program units:
> - Is there any need for the concept of \\"unit\\" to be exposed in the  
> syntax? Why not just allow \\"use unit\\" at top level, and implicitly  
> make each file (or in the browser context each inline script) a unit?

We've heard input that a server-side / ahead-of-time transformation of 
inlining nested units is desirable, in the sense that it makes for a 
single chunk of text you can send in a single HTTP response. The 
syntactic form was designed to permit this possibility: you can replace 
a use with its definition textually, without altering the meaning.

> - I think the difference between using units and importing packages is  
> going to be confusing to authors. Seriously, can anyone explain in one  
> sentence of 12 words or less how Joe Random Developers will decide  
> whether to use a namespace, import a package, or use a unit? Can we  
> get this down to only one kind of thing that needs to be mentioned in  
> the syntax? This would be a big win in reducing conceptual footprint.

True, though I suspect at least 2 of them need to remain. Namespaces are 
quite disjoint from loading and definition order. My eye is on packages.

> Type annotations and type checking: This section implies that type  
> annotations are not at all being added for performance reasons and may  
> indeed be harmful to performance. Wow! Seriously? I think runtime  
> assertions are interesting when debugging but I do would not want them  
> happening for every assignment statement in a release build of my C++  
> code. 

You may not be the sole voice of opinion on that matter :)

Types are the meeting point between two different -- and equally 
important! -- pressures felt throughout programming: correctness and 
speed. It is fair to discuss both; you're right that it is unfair to 
deny the motivation of one. Typed ES4 programs *may* run faster due to a 
variety of optimizations enabled by types. Whether those are performed 
is up to implementations. Specifically:

   - Dense allocation of the fixed portion of an object
   - Early-binding of fixture references to fixed properties
   - Inlining after early binding
   - Specialized selection of primitive operators

However, note that an implementation of ES4 clever enough to perform a 
large set of these optimizations may not be terribly different from an 
implementation of *ES3* clever enough to synthesize types optimistically 
on the fly and check its guesses against runtime facts, correcting any 
that rest on violated assumptions. These sorts of clever runtimes may 
actually notice no speed difference whatsoever.

What a clever runtime *cannot* do is synthesize the programmer's 
intentions wrt. type-based correctness conditions of their code. The 
programmer needs to say \\"this variable being an int is part of what it 
means to be correct\\". That is why there is a focus on the correctness 
motivation of types here, not the speed motivation.

> Pragmas: The \\"use decimal\\" pragma highlights how much complexity there  
> is to the decimal type. Seriously, is it worth it? Is the problems it  
> solves really that common?

Yes. Users have been reporting their displeasure with binary floating 
point arithmetic on the web since way back in the 20th century.

See also: http://www2.hursley.ibm.com/decimal/decifaq1.html#dbstats

> Generators: Do ordinary programmers really understand coroutine  
> control flow? Is this really a significantly better paradigm than  
> passing a visitor function? Not really convinced in this one yet.

The key purpose is to make for loops look like for loops. Agreed that it 
might be a heavy way of achieving it, but it divides the labor 
asymmetrically: the library author does the hard work, the users don't. 
With visitor functions, the users all have to get cozy with higher order 
functions.

> \\"switch type\\" statement: I guess this beats switching on typeof, but  
> is it really significantly better than a series of \\"if\\" statements  
> using the \\"is\\" operator?

It is better from a static-type perspective, in an implementation that 
wants to optimize union type representations. Maybe this is not 
sufficiently compelling. I suggested it, and I concur that it's trimmable.

> Expression closures: I actually find the examples hard to follow given  
> my expectation of ES3-like syntax. I think this may actually be  
> syntactic salt.

No opinion. I know how to write either way.

> \\"type\\": Are runtime meta-objects representing types ruly necessary?  
> What are they good for?

Tooling, runtime code synthesis and analysis, runtime adaptation to code 
added at a later date, etc. Completeness of the dynamic nature of the 
language ... ask a smalltalk or lisp person :)

> Slicing: This one I mildly object to. Array/String slicing is not, to  
> my knowledge, particularly common in ECMAScript code of today. I am  
> dubious that it merits its own operator syntax.

No opinion. Similar to expression closures: willing to trim.

> Early binding, static type checking, and predictable behavior with  
> \\"intrinsic\\": Perhaps it should be highlighted more that this is a  
> potential significant performance improvement.

Agreed! If it took until this late in the document to understand that 
angle, it ought to move up.

> Reflection: This feature seems like it could be complex to implement  
> and potentially unnecessary for small implementations. I note that  
> J2ME omits reflection, which we can perhaps take as a sign that it is  
> not suitable for small implementations.

Not clear. The language has to keep quite a lot of machinery around for 
its dynamic aspects anyways; the idea is to given an interface through 
which the runtime can be asked to lazily manufacture reflective bits 
that cover only the things it already has to carry. If you see things 
that you think could be optimized away while still executing the rest of 
the language, by all means suggest cutting.

> ControlInspector: I think an interface that's meant for debuggers and  
> similar tools, and not implementable in all interesting contexts, does  
> not need to be standardized. Better than having an optional feature.

Not clear. Debuggers are one perspective, sure; but general dynamic 
scope is a useful (if sharp and dangerous) feature for advanced library 
authors (security contexts, continuations, dynamically-scoped 
resources), and they can't get it otherwise without interposing wrapper 
functions everywhere, and  that defeats tail calls.

> uint-specific operations: This is syntactically ugly. Why can't  
> integer math just always work this way? Also, why only uint versions?  
> Surely it is desirable to do efficient math on signed integers as  
> well. Also, bitops already happen in integer math space, thus type- 
> specific versions should not be necessary since no floating point  
> conversion will need to occur if both operands of ^ or & are  
> statically typed as int or uint.

As said above, your ideas about how better to reform int/uint/double 
arithmetic and promotion are compelling. Can we move it to a bug and 
hash it out there? I don't want to lose it.

Again, thanks *so much* for giving it the fine-tooth comb treatment. 
This is valuable feedback.

-Graydon",
    "header": Object {
      "date": 2007-11-15T00:22:47.000Z,
      "from": Object {
        "email": "graydon@mozilla.com",
        "name": "Graydon Hoare",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Close%20review%20of%20Language%20Overview%20whitepaper&In-Reply-To=A8F25A0C-4059-4668-956D-348314F76C7D%40apple.com",
      "subject": "Close review of Language Overview whitepaper",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005041.html",
  },
  Object {
    "body": "By \\"fixed\\", do you mean an RI bug or a spec issue? If it's just an RI
bug, can you tell me what those exprs are supposed to evaluate to?

-Yuh-Ruey Chen

Lars T Hansen wrote:
> At present, generic functions do not discriminate on structural types.
>  This probably needs to be fixed, but I've not looked into it.
>
> --lars
>
> On 11/12/07, Yuh-Ruey Chen <maian330 at gmail.com> wrote:
> > Given the following definitions:
> >
> > class C {var p: int};
> > type S1 = {p: int};
> > type S2 = {p: int, p2: double};
> > generic function foo(x);
> > generic function foo(x: *) 0
> > generic function foo(x: C) 1
> > generic function foo(x: S1) 2
> > generic function foo(x: S2) 3
> > generic function foo(x: like S1) 4
> > generic function foo(x: like S2) 5
> > var o1: C = new C();
> > var o2: S1 = {p: 10};
> > var o3: S2 = {p: 10, p2: 3.14};
> > var o4 = {p: 10};
> > var o5 = {p: 10, p2: 3.14};
> > var o6 = {p: 10, p2: 3.14, p3: \\"hi\\"};
> >
> > What do the following exprs evaluate to?
> > foo(o1);
> > foo(o2);
> > foo(o3);
> > foo(o4);
> > foo(o5);
> > foo(o6);
> >
> > Also, I know that S1 <: Object, but is S2 <: S1? I've looked at
> > http://wiki.ecmascript.org/doku.php?id=clarification:type_system and
> > it's not clear to me. Is it still true that C <: S1?
> >
> > -Yuh-Ruey Chen
> > _______________________________________________
> > Es4-discuss mailing list
> > Es4-discuss at mozilla.org
> > https://mail.mozilla.org/listinfo/es4-discuss
> >
>
>",
    "header": Object {
      "date": 2007-11-15T00:52:41.000Z,
      "from": Object {
        "email": "maian330@gmail.com",
        "name": "Yuh-Ruey Chen",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=generic%20function%20with%20structural%20types%20questions&In-Reply-To=12c6978a0711120247tc9c17c9v4a5411f818d739f2%40mail.gmail.com",
      "subject": "generic function with structural types questions",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005042.html",
  },
  Object {
    "body": "Hey All -

So I've been trying to understand generic functions (and their presumed use for Multimethods). Reading through the white paper and the wiki I can surmise the following (and since the RI doesn't include them yet, these are just assumptions):

Generic functions are used like this:

generic function a(b);
generic function a(b:int){}
generic function a(b:string){}

Generics offer a point upon which future functions can be bound, like for operator overloading:

class Foo!{}

generic intrinsic function +(a:string, b:Foo){}
generic intrinsic function +(a:Foo, b:string){}
generic intrinsic function +(a:Foo, b:Foo){}

So that's all well-and-good. Now, where I making an assumption is that it's not possible to do the following:

generic function a(b);
generic function a(b:int){}
generic function a(b:string){}

generic function a(b,c);
generic function a(b:string, c:int){}

also, it's not clear if you can use generics for constructors - so I'm assuming that that's also not possible:

class Foo {
  generic function Foo(b);
  generic function Foo(b:int){}
  generic function Foo(b:string){}
}

Ok - with all of that assumed, I am seriously struggling to think of a real-world use case for generics beyond the compelling operator overloading example.

Assuming that I wanted to continue to try to do method overloading, it sounds like the de-facto solution is to just use the rest arguments to figure out what I want. This is not an acceptable solution. I lose virtually all of the benefits that I had of doing type annotations in the first place if I can't actually use them on \\"overloaded\\" functions.

For example, I've been pouring through my JavaScript library (jQuery) looking for ways in which ES4 could be of benefit. I immediately looked to using (what I thought was) method overloading to ease some of the severe complexity of the library. We do overloading on virtually every single method: Thus, if there was no form of method overloading included in ES4, then jQuery would receive significantly less, tangible, benefit from these updates.

To give a couple, crude, examples:

function attr(name : string) : string {
  // get attribute value
}

function attr(name : string, value : (string,int)) : jQuery {
  // set an attribute value, return a jQuery object
}

function removeEvent() : jQuery {
  // Remove all events
  for each ( var type in types )
    removeEvent( type );
}

function removeEvent(type : string) : jQuery {
  // Remove all events of a specific type
  for each ( var fn in events[type] )
    removeEvent( type, fn );
}

function removeEvent(type : string, fn: Callable) : jQuery {
  // Remove the event handler bound to a type
}

Additionally, I've been working on building a DOM implementation to sit on top of the ES4 RI, but have hit some walls, especially with constructors. Thankfully, private/protected/etc. constructors will be implemented at some point (I'm looking forward to it) but I was kind of expecting the ability to do multiple constructors - and even the ability to mix private/protected/public constructors, for example:

class Foo {
  private function Foo(){
    // Do initialization stuff
  }
  function Foo(name : string) {
    this();
    this.name = name;
  }
}

I'm simply most concerned about getting a useful version of method overloading and constructor overloading. I'd love to find out that I could use generics to achieve this, but I just don't have a way of determining that right now.

--John",
    "header": Object {
      "date": 2007-11-15T01:26:37.000Z,
      "from": Object {
        "email": "jresig@mozilla.com",
        "name": "John Resig",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Understanding%20Generic%20Functions&In-Reply-To=",
      "subject": "Understanding Generic Functions",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005043.html",
  },
  Object {
    "body": "Hey Maciej, thanks for the detailed comments. As many detailed  
responses as I can muster below -- all opinions mine unless noted  
(e.g. where I cite a group opinion).

On Nov 14, 2007, at 2:03 PM, Maciej Stachowiak wrote:

> Goals: I strongly agree with the stated goals of compatibility and
> enabling large software development. I wonder if perhaps performance
> should be added as a goal. At the very least we want it to be possible
> to achieve performance on par with ES3 engines, and ideally we want to
> enable better performance.

I know of proofs that much better performance (order of magnitude  
over latest interpreters) is coming to JS1 implementations, so I  
think this is a red herring. It would be good to avoid anti- 
performance mandatory changes, of course -- that might not be obvious.

> Programming in the small: \\"... make the writing and reading of
> fragments of code simpler and more effortless.\\" That is somewhat
> dubious gramatically,

English crit, watch out! ;-) I did not write this, but I'll leap to  
the author's defense. The grammar's fine and usage manuals  
(Partridge, Fowler -- if memory serves) allow \\"more effortless\\". See  
also

http://www.google.com/search?hl=en&client=firefox-a&rls=org.mozilla% 
3Aen-US%3Aofficial&hs=CGS&q=%22more+effortless%22+English 
+usage&btnG=Search

First hit:

http://www.bartleby.com/227/0206.html

> I suggest (with additional style fixes) \\"make
> the reading and writing of code fragments easier.\\"

I like your suggestion, though.

> Portability: This section first it says that the full language must be
> supported - subset profiles are not desirable. Then it says that, to
> allow ES4 to be practically implementable on small devices and in
> hosted environments, certain features, like extensive compile-time
> analysis and stack marks cannot be part of the language. Then it says
> those features are part of the language, but optional.

Clearly the overview should distinguish between mandatory standard  
mode features and optional strict mode and reflection features.

But you have a point about optional reflection features being useless  
on the web, so what's the point? One answer is to have a normative  
spec, so where support exists, the implementations can interoperate.  
This may not be enough for reflection -- it depends on likely uptake.  
We think it is enough to justify strict mode. More below.

> Syntax: The new non-contextual keywords, and the resulting need to
> specify dialect out of band, are a problem. I'll have more to say
> about compatibility under separate cover.

We've talked about this before, and I'm looking forward to your  
thoughts.

I would hope we can avoid having to do what we believe should be post- 
ES4 standardized AST, reader, and even macro work, just to allay  
concerns about ES4->ES5. We can't do all that work before ES4, but of  
course we want to make next time better. I noted on IRC that adding  
the 'x' flag to regexps, and codifying how IE handles / in a  
character class in a regexp (which browsers have had to follow), both  
break by-the-book ES3 scanners.

> Behavior:
> - This section has says that \\"variation among ES3 implementations
> entails a license to specify behavior more precisely for ES4\\".
> However, the example given is a case where behavior among two
> implementations was already the same, due to compatibility
> considerations. I actually think both convergence on a single behavior
> where variation is allowed, and variation that leads to practical
> compatibility issues are license to spec more precisely,

We do not want to overspecify, however. The majority of those who've  
expressed an opinion in TG1 do not want, e.g., to specify Date.parse  
as it is implemented in any given browser, never mind finding the  
intersection among all browsers.

> - The RegExp change - is this really a bug fix? It's likely that this
> is not a big compatibility issue (Safari's ES3 implementation had
> things the proposed ES4 way for some time) but I think ES3's approach
> may be more performance and generating a new object every time does
> not seem especially helpful.

This bug is the second most duplicated among bugs filed with  
mozilla.org's bug system since 1998:

http://bugzilla.mozilla.org/show_bug.cgi?id=98409

Full dup-count available at

https://bugzilla.mozilla.org/duplicates.cgi? 
sortby=component&maxrows=1000&changedsince=3600&product=Core

sort by Component for best results.

This singleton pigeon-hole problem hurts users all the time (I get  
mail from individual developers confused by it, at least once a year).

The performance worry for the proposed ES4 fix of evaluating a regexp  
literal to a new object, just as is done for other mutable objects  
expressed literally, is not an issue in our experience. Just as the  
compiler precomputes invariant parts of function objects, so it can  
memoize regexp constant parts, and wrap a mutable object around the  
shared immutable innards on each evaluation.

Quality implementations do this for function objects already, and  
some do it for regexps too, in order to support executing a  
precompiled script in several execution contexts (possibly  
concurrently).

> Is there any significant implementation that anyone would claim is
> 100% free of ECMAScript 3 compliance bugs?

No, and that's a good thing!

> I doubt it, and so I think
> we should make this section less judgmental in tone.

Agreed, thanks for pointing this out. I certainly missed it (everyone  
has bugs; some bugs are just problems in an implementation to fix,  
and we need not ascribe them to inadequate engineering practices, or  
blame darker motives for that matter :-/).

> Wrappers: The whitepaper implies that providing catchall getters and
> setters for primitive types and skipping boxing isn't a compatibility
> issue. However, it is possible in ES3 to capture an implicit wrapper:
>
> var x;
> String.prototype.myFunc = function() { this.foo = \\"foo\\"; x = this; };
> \\"bar\\".myFunc();
>
> Prototype hacking allows you to observe identity of the temporary
> wrappers, save them for later, and store properties. Perhaps there is
> evidence that practices relying on techniques like this are
> exceedingly uncommon (I'd certainly believe it), if so it should be
> cited.

This was a bug to fix, which I brought up too late to be included in  
the overview. See

http://bugs.ecmascript.org/ticket/281

We believe this is fixed now, but please comment there if you see a  
problem still.

> Literals:
> - I am surprised to see a decimal type (a type that is not directly
> supported in current mainstream hardware) even though generally
> popular types like single-precision IEEE floating point and 64 bit
> integers are not present.

See the third most duplicated bug in bugzilla.mozilla.org:

https://bugzilla.mozilla.org/show_bug.cgi?id=5856

See also the \\"Apple Flunks First Grade Math\\" blog post, I kid you  
not, here:

http://www.mikeindustries.com/blog/archive/2004/08/apple-calculator

I am sure on this basis you will agree with our inclusion of decimal  
in ES4 :-].

> Even when the final
> result cannot overflow, certainly in many expressions the difference
> between int and double intermediates can be observed. It seems likely,
> then, that math on variables declared int will be slower than math on
> variables declared double, which will surely be confusing to
> developers.

Are you sure integer ops with well-predicted overflow guards are  
slower than FP ops? I have contrary evidence and know of some papers  
in submission on this that suggest it is not a problem. But some of  
these papers also show the advice in favor of annotating :int to  
\\"improve performance\\" to be bad advice.

In other words, I'm disputing your contention that it's likely let  
i:int loop control variables will be slower than let i:double -- but  
I'm also saying that I think let i may be as fast as the faster of  
the annotated forms in ES4-as-proposed, on some of the forthcoming JS  
VMs. Performance is a red herring, again. To be demonstrated!

> Record and array types: Structural types are confusingly similar to
> yet different from classes. Mostly they offer a subset of class
> functionality (though reading ahead I did see a few features limited
> to them). Also, already having prototype-based objects and class-based
> objects it seems excessive to add yet a third way. I recommend
> removing them and adding any features that are sorely missed as a
> result to classes.

You miss the main difference: structural types are not equated by  
name, so they avoid the inheritance trap of classes, which consists  
of building hierarchies deriving from non-final nominal types  
(classes and interfaces) that constrain the evolution of the base  
types; or else slapping final too much on base classes (especially in  
the standard library).

Structural types formalize the \\"duck typing\\" done in ES3 code on the  
web. Most such code will never be retrofitted to use nominal types,  
but with structural types for API parameters, along with 'like' and  
'wrap', duck-typed data from such code can flow into typesafe libraries.

This is a crucial use-case, and perhaps the overview needs to spend  
more time on it. It's not something I (at least; also the majority of  
the group working on ES4, I think) will give up easily.

> \\"Any\\": The spec explains vaguely that the \\"any\\" type is not identical
> to the union (null, undefined, Object). How is it different? Is the
> difference observable to ES4 programs or is it purely a matter
> internal to the spec (in which case the difference is not relevant)?

Did you see footnote 17? It's a formality, perhaps not worth  
burdening the overview reader with, though.

> \\"wrap\\": Seems like a version of this feature and/or \\"like\\" founded on
> classes would work just as well.

Not so -- consider retrofitting existing code that passes objects and  
arrays, in JSON-like trees, to Ajax library APIs. We do not want to  
require all the library-client code to be rewritten to use nominal  
types. We should not prefer nominal types anyway, since they do not  
scale to the web due to the base-class pigeon hole problem I  
mentioned above, which leads to overconstrained class hierarchies  
over time, or else the final keyword prohibiting derived classes in  
the first place.

> Conversions: \\"In addition, any value in the language converts to a
> member of AnyBoolean\\", but the conversions specified are all to the
> more specific \\"boolean\\" type, so perhaps it should be expressed that
> way to avoid confusion.

I thought this too, when reviewing this section. I think this is an  
open issue, but I can't find a ticket for it. I'll follow up.

> Binding objects and scopes: It seems like introducing lexical block
> scopes makes things more challenging for online implementations.
> Creating a dynamic scope object per block scope is clearly
> unacceptable, but more work may be needed to build a per-function
> symbol table that can properly accomodate block scope.

Shipped in Firefox 2. It was Not Hard ;-).

> Is block scope
> worth it? Yes, \\"var\\" is a little weird, but having both \\"var\\" and
> \\"let\\" increases conceptual footprint and may overall lead to more
> author confusion.

Block scope is important to those larger-scale programs you favored  
early on. We have experience from Firefox 2 on supporting this, as do  
others who've extended ES3.

> package: Now that I have learned more about them, I think that
> exposing packages and namespaces as separate user-level concepts is
> confusing. Let's get this down to a single concept that developers
> have to learn.

As I noted in a previous thread, I'm sympathetic...

> Namespaces can just have a paired internal namespace
> implicitly,

... but not to this proposal. A namespace should not be two  
namespaces in disguise. I'd rather defer packages altogether from ES4  
than double namespace costs and remove their primitive utility (which  
ES4 relies on heavily).

> I do not think it is helpful to give the public/internal
> pair a special different name.

It is definitely not helpful to double the cost of namespaces just to  
cover package's use-cases.

> Program units:
> - Is there any need for the concept of \\"unit\\" to be exposed in the
> syntax? Why not just allow \\"use unit\\" at top level, and implicitly
> make each file (or in the browser context each inline script) a unit?

See

http://wiki.ecmascript.org/doku.php?id=proposals:program_units

for examples including server-side expansion and client-side caching  
of units, independent of how they are stored in files or transported  
in HTTP responses.

> Versioning: I am suspicious of versioning mechanisms, especially big
> giant switch versioning. Is there any use of __ECMASCRIPT_VERSION__
> that is not better handled by feature testing? (Maybe there is and I
> am not thinking of it.)

Two points:

* Feature-testing in multi-version languages and libraries, in my  
experience at least, has produced more implicit version combinations  
against which to measure and support compatibility, than a total  
version order, ideally a number line.

* We expect users to write in the new language and transcode to the  
old using offline or just-in-time source-to-source translators. Such  
systems want whole-language versioning, not feature tests.

> arguments: It seems strange to both deprecate a feature and improve it
> at the same time.

Deprecation via strong language in specs is worth the paper it's  
printed on, IMHO. You need carrots as well as sticks. Rest params are  
the sweetest carrot, but arguments will endure, and already Opera (at  
least) makes arguments delegate to Array. People want it, and it is  
easy and free of downside. Give the people what they want here :-).

> Strict:
> - I would strongly prefer if strict mode did not alter behavior of
> programs at all, except to reject those that do not pass the checks.
> Otherwise, since strict mode is optional, this risks interop issues.

The interop issue would be that standard mode runs a program that  
would fail at runtime with strict mode's eval change. Such a program  
must therefore make bindings in eval's dynamic scope. We can't have a  
sound strict mode without this change, and there may be others --  
Mark Miller has me convinced that a short list of runtime semantic  
changes (restrictions, exception-throwing) made by Google Caja are  
all necessary. More on this in due course.

See two responses below for more on why it's probably helpful to  
interop to specify an optional strict mode, once for all  
implementations that choose to support 'use strict'.

>  So I'm curious what the eval detail is. Perhaps strict mode could
> remove the eval operator and allow only the eval function, with some
> suitably named version made available ahead of time, if the difference
> is just removing local eval behavior.

It's not that simple The problem is the contents of the eval  
argument, which are not visible to strict mode or the compiler.

> - I am somewhat concerned about having strict mode at all. It seems
> like it could create the same kinds of problems we see today with
> content that is served as application/xhtml+xml to some browsers and
> text/html to others. It's not infrequent to see such content break
> only in the browsers that really support XML, due to sloppy testing of
> changes and the fact that the 78% browser doesn't support XHTML.

We see this problem from the other side. There are numerous competing  
\\"lint-like\\" tools, and some optional type checkers in JS-derived  
languages. These will tend to produce interop bugs with greater  
frequency in the absence of a normative strict mode spec (optional at  
each implementation's discretion) than if there were such a spec for  
strict mode. So we are specifying. If an ES4 implementation supports  
'use strict', it must follow the spec.

> Verification:
> - Does strict mode actually allow for any optimizations that couldn't
> be done to the exact same program in standard mode?

IMHO strict mode has nothing to do with optimizations.

> Section IX.
>
> \\"switch type\\" statement: I guess this beats switching on typeof, but
> is it really significantly better than a series of \\"if\\" statements
> using the \\"is\\" operator?

And lexical bindings for the types cracked by the cases? Yes.  
Consider typed exception handling vs. a single catch clause with an  
if/else chain or switch (and the obligation to re-throw in the else  
or default -- which users forget).

You're right that switch type, like destructuring assignment, is  
sugar. We are providing sugar. It reduces code size, improves  
readability, and eliminates bug habitat. Its cost in practical JS  
parsers, based on Firefox 2 and other experience, is in the noise.

> Expression closures: I actually find the examples hard to follow given
> my expectation of ES3-like syntax. I think this may actually be
> syntactic salt.

Implemented in the RI, and in Firefox 3 beta. Based on the experience  
of people using these, it's sweet, sweet sugar -- but tastes vary. My  
only thought is to urge you to use expression closures in your own  
code, and give them a chance to grow on you, before rendering final  
judgment.

> Semicolon insertion: I'd like more detail on the compatibility of the
> return change.

The return change was withdrawn. See

http://bugs.ecmascript.org/ticket/263

> Reflection: This feature seems like it could be complex to implement
> and potentially unnecessary for small implementations. I note that
> J2ME omits reflection, which we can perhaps take as a sign that it is
> not suitable for small implementations.

Or blow bronx cheers. :-P Sorry, but citing J2ME is fighting words to  
me, and proof of nothing in particular.

> JSON: Sounds good.

This proposal is withdrawn and another API is being considered for  
reinclusion later. See http:;//json.org/json2.js.

> Things I didn't see:
>
> What about standardizing the de facto <!-- comment syntax that is
> necessary for web compatibility?

Please write the spec ;-). Don't forget the --> mess.

/be",
    "header": Object {
      "date": 2007-11-15T01:34:37.000Z,
      "from": Object {
        "email": "brendan@mozilla.org",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Close%20review%20of%20Language%20Overview%20whitepaper&In-Reply-To=A8F25A0C-4059-4668-956D-348314F76C7D%40apple.com",
      "subject": "Close review of Language Overview whitepaper",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005044.html",
  },
  Object {
    "body": "On Nov 13, 2007, at 10:40 PM, Yuh-Ruey Chen wrote:

> I don't see how that's workable. I mean, technically it is, since |is|
> is a runtime check. But it creates another \\"incompatibility\\" between
> type annotations and |is|, and you seem pretty adamant to keep the two
> as coherent as possible.

You're right, there are problems with unifying type and value  
expressions, giving type expressions priority. There may even be  
problems with just type expression syntax as proposed, see http:// 
bugs.ecmascript.org/ticket/309.

>>> d) x instanceof function(p: int): int {} // syntax error?
>>
>> Oh, I see -- on second thought I meant nothing like allowing (d) --
>> sorry. instanceof only takes a value expression on its right, but if
>> that evaluates to a type meta-object, it does something sane and
>> \\"instance-of\\"ish.
>
> So I take that |x instanceof {p: int}| won't work, and we'd have to  
> use
> |T = type {p: int}; x instanceof T| instead?

No, the restriction on instanceof comes from ES3, which introduced  
it, along with object initialisers. So x instanceof {p:int} (given a  
binding for 'int' of course) is perfectly valid ES3 and ES4. It  
throws an error in ES3 implementations that do not reserve  
'int' (e.g. SpiderMonkey):

js> int = function (){}
function () {
}
js> x = 42
42
js> x instanceof {p:int}
typein:3: TypeError: invalid 'instanceof' operand ({p:(function () {})})

> I truly doubt there is any code out there with (d). It's a backwards
> incompatibility I'd be willing to break. If there is code out there  
> with
> this, well, the new syntax error should tell them that they're doing
> something really stupid.

You're no doubt right, but why mess with instanceof to take a type  
expression on the right? We still have to work out type expression  
grammar as it intrudes into value expressions to everyone's  
satisfaction. I'd rather keep instanceof's right operand a value  
expression and fry other fish.

> Plenty of discussion going on in ticket 300 concerning this. Ugh, this
> semi-merging of value and type exprs is getting awkward. We're  
> ending up
> with just as many gotchas as we had before at this rate.

Yes, this merge attempt failed already -- it was doomed from the  
start. We need to get type expressions by themselves working. I'm  
pretty sure we can resolve all grammatical issues to-do with type  
expressions, and in that event, allowing a runtime name instead of  
insisting only on a fixed type name will be easy.

> Alright, overview time again. Our current goals are:
> 1) Make |is| less restrictive and allow it accept (some) value exprs.

At this point (some) means name expressions, not restricted to be  
fixed type names.

> 2) Keep |is| and type annotations coherent.

Check, but allowing arbitrary names in type annotations is out. Still  
coherent enough. Call it compromise, if you must -- I think 'is' the  
operator has to compromise because it has too many connotations, and  
different use-cases from type annotations.

> 3) Keep |is| and |instanceof| (somewhat) coherent.

We should define coherence more precisely:

* 'is' takes a type expression on the right, but allows runtime name  
in addition to fixed type name.
* instanceof takes a value expression per ES3 but if its result lacks  
a [[HasInstance]] internal method (new formalism for ES4 needed, I'm  
using ES3 meta-methods here), it checks for a meta-object result and  
does 'is' -- else it throws TypeError.

> 4) Keep all the type operators coherent (to a certain extent).

Let's see:

* 'cast' requires a fixed type expression on the right (no variable  
name)
* 'wrap' and 'like' require fixed type expressions.

> 5) Try not to introduce too many exceptions to the rule a.k.a.  
> gotchas.

Yup.

> Whatever we do to advance one goal, another goal becomes more
> compromised. Maybe we can place priorities on these goals? If we can
> abandon one or two of these in favor of the other goals, this job  
> would
> be much simpler. Need to think on this some more...

Let me know what you think of my interpretations and elaborations  
just above. Thanks,

/be",
    "header": Object {
      "date": 2007-11-15T02:15:42.000Z,
      "from": Object {
        "email": "brendan@mozilla.org",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=need%20some%20clarification%20on%20compile-time%20type%20vs.%20run-time%20type&In-Reply-To=473A9856.4070008%40gmail.com",
      "subject": "need some clarification on compile-time type vs. run-time type",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005045.html",
  },
  Object {
    "body": ">> JSON: Sounds good.
> This proposal is withdrawn and another API is being considered for 
> reinclusion later. See http:;//json.org/json2.js.
toJSONString and parseJSON are going away? I was actually wanting to write 
and suggest the removal of these, with Douglas's recent change in his JSON 
API. I am glad to see these will be going away. Will ES4 include the other 
API (JSON.parseJSON / JSON.stringify)?

>You miss the main difference: structural types are not equated by  name, so 
>they avoid the inheritance trap of classes, which consists
I would love to understand the purpose of structural types better. I don't 
understand how base class evolution is constrained in ways that super record 
types aren't.
I also don't understand how the goal of applying types to existing ES3 
objects can not be achieved with wrap operator and nominal types. I know 
there something I am missing here.
Thanks,
Kris",
    "header": Object {
      "date": 2007-11-15T05:51:37.000Z,
      "from": Object {
        "email": "kriszyp@xucia.com",
        "name": "Kris Zyp",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Close%20review%20of%20Language%20Overview%20whitepaper&In-Reply-To=",
      "subject": "Close review of Language Overview whitepaper",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005046.html",
  },
  Object {
    "body": "> On Nov 1, 2007 3:46 PM, Kris Zyp <kriszyp at xucia.com> wrote:
>> >> It's a sandbox, right? Should be safe. Not so fast:
>>
>> > last they gave up.  rexec was removed from the language.

With the complexity of creating and verifing a sandboxing eval that allows 
shared mutable objects with some degree of safety, is it conceivable that 
ES4 could alternately pursue sandboxed eval through a shared nothing 
construct? I remember that Brendan mentioned that Google Gears approach is a 
good model, but that it would be premature to standardize. I agree 
standardizing on the actual Gears API would be strange, however, wouldn't 
taking a shared nothing approach to sandboxing (using messaging) like gears 
(but with our own API) be a safer and easier to analyze approach to 
sandboxing and more reasonable in terms of time constraints for inclusion in 
ES4 than the scopable eval? Shared nothing techniques are hardly a new PL 
concept, albiet I am sure it is still not a trivial addition.
Just thinking about what it could look like:
mySandbox = new Environment(myScriptToSandbox);
onmessage=function(message : string) {...}
mySandbox.sendMessage(\\"start\\");
And of course, it seems hard to resist the temptation to entertain the hope 
that this could be a possible API for adventurous implementors to use for a 
concurrency construct (use the same API for ConcurrentEnvironment), which 
could advise ES5's work on concurrency.
Kris",
    "header": Object {
      "date": 2007-11-15T06:11:30.000Z,
      "from": Object {
        "email": "kriszyp@xucia.com",
        "name": "Kris Zyp",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Restricted%20Eval&In-Reply-To=",
      "subject": "Restricted Eval",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005047.html",
  },
  Object {
    "body": "It's a spec issue.  --lars 

> -----Original Message-----
> From: es4-discuss-bounces at mozilla.org 
> [mailto:es4-discuss-bounces at mozilla.org] On Behalf Of Yuh-Ruey Chen
> Sent: 15. november 2007 01:53
> To: Lars T Hansen
> Cc: es4-discuss
> Subject: Re: generic function with structural types questions
> 
> By \\"fixed\\", do you mean an RI bug or a spec issue? If it's 
> just an RI bug, can you tell me what those exprs are supposed 
> to evaluate to?
> 
> -Yuh-Ruey Chen
> 
> Lars T Hansen wrote:
> > At present, generic functions do not discriminate on 
> structural types.
> >  This probably needs to be fixed, but I've not looked into it.
> >
> > --lars
> >
> > On 11/12/07, Yuh-Ruey Chen <maian330 at gmail.com> wrote:
> > > Given the following definitions:
> > >
> > > class C {var p: int};
> > > type S1 = {p: int};
> > > type S2 = {p: int, p2: double};
> > > generic function foo(x);
> > > generic function foo(x: *) 0
> > > generic function foo(x: C) 1
> > > generic function foo(x: S1) 2
> > > generic function foo(x: S2) 3
> > > generic function foo(x: like S1) 4
> > > generic function foo(x: like S2) 5
> > > var o1: C = new C();
> > > var o2: S1 = {p: 10};
> > > var o3: S2 = {p: 10, p2: 3.14};
> > > var o4 = {p: 10};
> > > var o5 = {p: 10, p2: 3.14};
> > > var o6 = {p: 10, p2: 3.14, p3: \\"hi\\"};
> > >
> > > What do the following exprs evaluate to?
> > > foo(o1);
> > > foo(o2);
> > > foo(o3);
> > > foo(o4);
> > > foo(o5);
> > > foo(o6);
> > >
> > > Also, I know that S1 <: Object, but is S2 <: S1? I've looked at 
> > > 
> http://wiki.ecmascript.org/doku.php?id=clarification:type_system and 
> > > it's not clear to me. Is it still true that C <: S1?
> > >
> > > -Yuh-Ruey Chen
> > > _______________________________________________
> > > Es4-discuss mailing list
> > > Es4-discuss at mozilla.org
> > > https://mail.mozilla.org/listinfo/es4-discuss
> > >
> >
> >   
> _______________________________________________
> Es4-discuss mailing list
> Es4-discuss at mozilla.org
> https://mail.mozilla.org/listinfo/es4-discuss
>",
    "header": Object {
      "date": 2007-11-15T07:20:16.000Z,
      "from": Object {
        "email": "lhansen@adobe.com",
        "name": "Lars Hansen",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=generic%20function%20with%20structural%20types%20questions&In-Reply-To=473B9859.8050602%40gmail.com",
      "subject": "generic function with structural types questions",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005048.html",
  },
  Object {
    "body": "> -----Original Message-----
> From: es4-discuss-bounces at mozilla.org 
> [mailto:es4-discuss-bounces at mozilla.org] On Behalf Of John Resig
> Sent: 15. november 2007 02:27
> 
> Generic functions are used like this:
> 
> generic function a(b);
> generic function a(b:int){}
> generic function a(b:string){}

Yes.

> Generics offer a point upon which future functions can be 
> bound, like for operator overloading:
> 
> class Foo!{}
> 
> generic intrinsic function +(a:string, b:Foo){} 
> generic intrinsic function +(a:Foo, b:string){} 
> generic intrinsic function +(a:Foo, b:Foo){}

Yes.

> So that's all well-and-good. Now, where I making an 
> assumption is that it's not possible to do the following:
> 
> generic function a(b);
> generic function a(b:int){}
> generic function a(b:string){}
> 
> generic function a(b,c);
> generic function a(b:string, c:int){}

An early proposal had this.  It became complicated.  See below.

> also, it's not clear if you can use generics for constructors 
> - so I'm assuming that that's also not possible:
> 
> class Foo {
>   generic function Foo(b);
>   generic function Foo(b:int){}
>   generic function Foo(b:string){}
> }

At the moment that is true, but there's no reason I'm aware of why that
restriction can't be lifted, apart from issues of having to use the
\\"settings\\" (the initializer list preceding the body) for nullable
fields; allowances could presumably be made if the use cases were
strong.

> Ok - with all of that assumed, I am seriously struggling to 
> think of a real-world use case for generics beyond the 
> compelling operator overloading example.

Generic functions can be useful for adding type-dispatched functionality
after the fact without creating facades/wrappers.  The visitor pattern
is one example that's repeated in the literature.  I circulated a JSON
approach recently based on generic functions, along these lines:

generic function toJSON(x);

generic function toJSON(x:Object) { 
  for ( let n in obj )
    if (obj.hasOwnProperty(n))
      serialize(n, toJSON(obj[n]))
}

generic function toJSON(x:string) { 
  ... 
}

The key here is that the protocol for JSON conversion is defined outside
the object, not inside the object, which can be a real advantage if
you're hooking up to somebody else's code that you don't want to edit.

If you are happy in a class-based OO world and you control all your
source code, you'll probably have limited use for generic functions,
just like you'll have limited use for structural types.  These features
speak to different use cases having to do with evolutionary programming.
(I'm working on a tutorial, which will probably not be finished this
week).

> Assuming that I wanted to continue to try to do method 
> overloading, it sounds like the de-facto solution is to just 
> use the rest arguments to figure out what I want. This is not 
> an acceptable solution. I lose virtually all of the benefits 
> that I had of doing type annotations in the first place if I 
> can't actually use them on \\"overloaded\\" functions.

What you mean is, you want parameter lists of different lengths on the
generic methods.

> For example, I've been pouring through my JavaScript library 
> (jQuery) looking for ways in which ES4 could be of benefit. I 
> immediately looked to using (what I thought was) method 
> overloading to ease some of the severe complexity of the 
> library. We do overloading on virtually every single method: 
> Thus, if there was no form of method overloading included in 
> ES4, then jQuery would receive significantly less, tangible, 
> benefit from these updates.
> 
> To give a couple, crude, examples:
> 
> function attr(name : string) : string {
>   // get attribute value
> }
> 
> function attr(name : string, value : (string,int)) : jQuery {
>   // set an attribute value, return a jQuery object }
> 
> function removeEvent() : jQuery {
>   // Remove all events
>   for each ( var type in types )
>     removeEvent( type );
> }
> 
> function removeEvent(type : string) : jQuery {
>   // Remove all events of a specific type
>   for each ( var fn in events[type] )
>     removeEvent( type, fn );
> }
> 
> function removeEvent(type : string, fn: Callable) : jQuery {
>   // Remove the event handler bound to a type }
> 
> Additionally, I've been working on building a DOM 
> implementation to sit on top of the ES4 RI, but have hit some 
> walls, especially with constructors. Thankfully, 
> private/protected/etc. constructors will be implemented at 
> some point (I'm looking forward to it) but I was kind of 
> expecting the ability to do multiple constructors - and even 
> the ability to mix private/protected/public constructors, for example:
> 
> class Foo {
>   private function Foo(){
>     // Do initialization stuff
>   }
>   function Foo(name : string) {
>     this();
>     this.name = name;
>   }
> }
> 
> I'm simply most concerned about getting a useful version of 
> method overloading and constructor overloading. I'd love to 
> find out that I could use generics to achieve this, but I 
> just don't have a way of determining that right now.

As I wrote above, an early version of the generic function proposal
supported multiple parameter list lengths and allowed generic functions
to be instance methods.  The proposal was complicated; I don't know if
it was sound, and it probably would not have been accepted in that form.

If you don't care about extending a generic function outside the class
it's defined in (excluding also extensions in the subclass) because you
just want to implement overloaded functions then there are no problems
with having generic functions be instance methods.  There are also no
problems with having generic constructors or meta:: functions.

What you suggest above with private/public constructors isn't
expressible with generic functions, and I don't expect it ever will be.
(Your example is not a strong use case given that you call the private
constructor from the public one; the private constructor could just be a
private method.)

Parameter lists of various lengths... I understand the use cases, and if
there are no optional or rest arguments involved it's not actually all
that hard.  It's when you try to generalize that it becomes difficult.

IMO we have a couple of options:
  * remove generic functions from ES4 because they are too limited.
Operator overloading goes away, too.
  * accept them as they are, recognizing that they are future-proof and
that they can be extended in later editions of the language (as we've
done for type parameterization)
  * try to extend them with instance methods, constructor methods,
variable-length parameter lists without going over the complexity budget

--lars",
    "header": Object {
      "date": 2007-11-15T07:52:24.000Z,
      "from": Object {
        "email": "lhansen@adobe.com",
        "name": "Lars Hansen",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Understanding%20Generic%20Functions&In-Reply-To=5521564.72011195089997654.JavaMail.root%40cm-mail02.mozilla.org",
      "subject": "Understanding Generic Functions",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005049.html",
  },
  Object {
    "body": "On Nov 14, 2007, at 9:51 PM, Kris Zyp wrote:

>>> JSON: Sounds good.
>> This proposal is withdrawn and another API is being considered for
>> reinclusion later. See http:;//json.org/json2.js.
> toJSONString and parseJSON are going away? I was actually wanting  
> to write
> and suggest the removal of these, with Douglas's recent change in  
> his JSON
> API. I am glad to see these will be going away. Will ES4 include  
> the other
> API (JSON.parseJSON / JSON.stringify)?

(It's JSON.parse, not JSON.parseJSON.)

I thought I answered that above, sorry if I was unclear. We like  
Doug's new API and hope to include it in due course into ES4. JSON  
was already an accepted proposal, so it has a foot in the door.  
Various interested parties favored something like the json2.js API  
already, and I think everyone will rally round it and beat on it, to  
make sure it has the right usability and knobs. I'm hopeful.

>> You miss the main difference: structural types are not equated by   
>> name, so
>> they avoid the inheritance trap of classes, which consists
> I would love to understand the purpose of structural types better.  
> I don't
> understand how base class evolution is constrained in ways that  
> super record
> types aren't.

You can have an object {p: 42, q: \\"hi\\"} match an annotation of the  
form 'like {p:int, q:string}', but there is no class with which that  
object is compatible in any well-defined sense except for Object itself.

While you can make a subclass of Object, say class C {p:int,  
q:string}, be a structural subtype of a record type, say {p:int} or  
{q:string} or {p:int, q:string}, you cannot do the reverse. {p:int,  
q:string} is not a subtype of C.

Evolution is constrained when you want to inherit from two classes,  
which ES4 does not allow. Assume no name conflicts, since those can  
arise with nominal and structural types, and namespaces stand ready  
to help.

The problem in general is that Bob's classes and Alice's classes were  
written without anticipating Carol's combination of the two, but  
Carol cannot use MI. Nor can she provide objects that match  
structural types. She has to inherit from both Bob's and Alice's  
classes.

This inevitably means duplication, peered objects delegating to each  
other, even if Bob and Alice used interfaces well (interfaces help,  
but bring in other problems and can't be used everywhere).

This also means conflicts are hard to resolve without writing more  
(and more verbose) nominally typed code, instead of writing some  
untyped code that satisfies like-types or that can be wrapped with  
tolerable performance, or some structurally typed code (see below for  
an iterator example).

> I also don't understand how the goal of applying types to existing ES3
> objects can not be achieved with wrap operator and nominal types. I  
> know
> there something I am missing here.

You do not want to let any old object masquerade as a nominal type  
(class, in this case). Imagine if you had class C { var p:int,  
q:string ; final function must_not_override() {...} }. Would {p:42,  
q:\\"hi\\", must_not_override: function() \\"rm -rf /\\"} be safe to pass off  
as 'like C'? How about as 'wrap C'?

Remember, the users of C as a type annotation are not interested in  
the details of C's implementation (even if final; or if not final, of  
a subtype of C coming in as-a C). They care about behavior, in  
general. But at the limit, and in essence (i.e., what the type  
means), they really want a type *named* C, and nothing but that type  
(or of course a subtype, if C is not final).

Ok, ignore final classes and methods, say you are willing to special  
case (I'm kidding, but play along ;-). If you let untyped objects  
wrap into nominal types, you've killed another important use-case.  
Say you want to return instances of a type that no one can construct  
except your code. You don't want anyone wrapping some alien object.  
You really need your own instances and only those instances. Think of  
those capability objects created by private constructors that David  
Teller was asking about the other week (thread head).

There are other use-cases that want nominal types to have this  
\\"branded type\\" integrity property, e.g. hybrid information flow,  
which must see all the subtypes in the system in order to analyze all  
effects along implicit flows.

But just for the sake of argument, who cares? Let's say you are hell- 
bent on minimizing even if it undermines your system's security (not  
that this has ever happened before :-P). If you thus reduce the  
integrity of classes until they are named record types, and subtype  
judgments are record-width subtype judgments decoupled from the  
class's extends clause, then you've reinvented structural types. But  
look at the costs.

While like and wrap can be handy for dealing with untyped objects,  
and efficient when the actual value passing through the annotation is  
well-typed, if you want to avoid the potential costs of like (a deep  
shape-test) and wrap (a deep read and write barrier), you really do  
want to allow a type with C's structure, not C's name -- you want  
structural types for the actual arguments flowing in, not like or  
wrap types.

The IteratorType is an example. You don't have to extend a built-in  
class, or implement a built-in interface, to make an iterator. All  
you need is a next method of the right type:

type IteratorType.<T> = {
     next: function (): T
};

You can implement iterators using object initialisers. From the RI's  
builtins/Map.es (with a bug-fix not yet in the monotone source):

         helper function iterate.<T>(f: function(*,*,*):*) {
             let a = [] : [T];
             informative::allElements( tbl, limit, function (k,v) { f 
(a,k,v) } );
             let i = 0;
             return {
                 next: function () : T {
                     if (i === a.length)
                         throw iterator::StopIteration;
                     return a[i++];
                 }
             } : IteratorType.<T>;
         }

You don't need classes, nor should you. You can retrofit and migrate,  
starting with wrap (or like if in the same trust domain), and moving  
to annotate object initialisers over time.

To restate the problems above as tersely as possible:

1. Class integrity means that no one can forge an instance using an  
untyped object, even with wrap.
2. You shouldn't have to use wrap, it costs enough that it must be  
explicit, and not mandatory for all cases where untyped meets typed.
3. Other cases where untyped meets typed can use like.
4. Structurally typing untyped code is lightweight compared to  
subclassing and implementing nominal types.

Modula 3 had branding for making nominal types from structural types,  
but going the other way, \\"unbranding\\" a nominal type to get a  
structural type, has no precedent I know of, probably because it  
undermines the integrity property that motivates branding or nominal  
typing in the first place. A class C can mean many things, depending  
on its members, finality, etc. But its meaning is bound to its name,  
not its structure.

Does this clear things up?

/be
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://mail.mozilla.org/pipermail/es-discuss/attachments/20071114/cb56b1f4/attachment-0002.html",
    "header": Object {
      "date": 2007-11-15T07:56:29.000Z,
      "from": Object {
        "email": "brendan@mozilla.org",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Close%20review%20of%20Language%20Overview%20whitepaper&In-Reply-To=005d01c8274b%2497844e40%246401a8c0%40XUCIA01",
      "subject": "Close review of Language Overview whitepaper",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005050.html",
  },
  Object {
    "body": "¹©Ó¦£º¼ô°å»ú¡¢ÕÛÍä»ú¡¢¾í°å»ú¡¢³å´²¡¢Ð£Æ½»ú
°²»ÕÊ¡ÈýÁ¦»ú´²ÖÆÔìÓÐÏÞ¹«Ë¾£¬Êô°²»ÕÊ¡ÃûÅÆ¡¢Ãâ¼ì²úÆ·Éú²úÆóÒµ£¬°²»ÕÊ¡¸ßÐÂ¼¼ÊõÆóÒµ£¬Âí°°É½ÊÐ¡°×¨¡¢¾«¡¢ÌØ¡¢ÐÂ¡±ÆóÒµ£¬Âí°°É½ÊÐÏÂ¸ÚÊ§ÒµÖ°¹¤ÔÙ¾ÍÒµ»ùµØ£¬½éÓÚÄÏ¾©¡¢ÎßºþÖ®¼ä£¬×øÂäÔÚÖøÃûµÄ¸Ö³ÇÂí°°É½ÊÐ£¬·á¸»µÄ¸ÖÌú×ÊÔ´Îª¹«Ë¾µÄ·¢Õ¹Ìá¹©ÁËµÃÌì¶ÀºñµÄÓÅÊÆ¡£¹«Ë¾Õ¼µØÃæ»ý108000Æ½·½Ã×£¬Ö÷ÒªÉú²ú¡°´óÊ¢¡±ÅÆÏµÁÐ¼ô°å»ú¡¢ÕÛÍä»ú¡¢¾í°å»ú¡¢¿ìËÙÑ¹Á¦»ú¡¢³å´²¡¢¿ª¾íÐ£Æ½»ú¡¢ÐÍ²ÄÍäÇú»úµ¶Ä£¾ßµÈ²úÆ·£¬×¨ÒµÎªº½¿Õ¡¢Çá¹¤¡¢Ò±½ð¡¢»¯¹¤¡¢½¨ÖþÆû³µ¡¢µçÁ¦¡¢×°äêµÈÐÐÒµÌá¹©ËùÐèÒªµÄ×¨ÓÃ»úÐµºÍ³ÉÌ×Éè±¸£¬²úÆ·ÏúÍùÈ«¹ú¸÷µØºÍÅ·ÃË¼°¶«ÄÏÑÇµØÇø²¢Ô¶ÏúÄÏ·Ç¡£ ¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¹«Ë¾ÓÃÏÖ´úÆóÒµµÄ¹ÜÀí·½·¨¡¢Á¢×ãÓÚ²úÆ·¹ÜÀí£¬ÒÔÆäÓÅÐãµÄÆ·ÖÊ£¬ÐÂÓ±µÄÉè¼Æ£¬ºÏÀíµÄ¼Û¸ñ£¬ÍêÉÆµÄÊÛºó·þÎñÓ®µÃÁË¹ã´ó¿Í»§µÄÒ»ÖÂºÃÆÀ£¬±»ÆÀÎª°²»ÕÊ¡¡°ÖØºÏÍ¬¡¢ÊØÐÅÓÃÏÈ½øµ¥Î»¡±¡¢°²»ÕÊ¡¡°ÖøÃûÉÌ±ê¡±¡¢°²»ÕÊ¡¡°ÃûÅÆ²úÆ·¡±¡¢¡°ÆóÒµ½ø³ö¿Ú×Ê¸ñÖ¤¡±¡¢¡°CE¹ú¼ÊÈÏÖ¤¡±°²»ÕÊ¡Å©ÐÐ¡°AA+¼¶ÐÅÓÃÆóÒµ¡±¡¢°²»ÕÊ¡¡°ÓÅÐã³ÏÐÅÃñÓªÆóÒµ¡±¡¢°²»ÕÊ¡¡°³ÏÐÅµ¥Î»¡±¡¢¡°Âí°°É½ÊÐÏÈ½ø¼¯Ìå¡±¡¢¡°Âí°°É½ÊÐÓÅÐãË½ÓªÆóÒµ¡±¡¢¡°Âí°°É½ÊÐ³ÏÐÅÄÉË°ÈË¡±¡¢¡°Âí°°É½ÊÐÒøÐÐÐÅ´û³ÏÐÅÖÐÐ¡ÆóÒµ¡±¡¢¡°È«¹úÓÃ»§²úÆ·ÖÊÁ¿ÂúÒâ£¬ÊÛºó·þÎñÂúÒâÊ¾·¶µ¥Î»¡±¡¢¡°AAA¼¶ÖÊÁ¿³ÏÐÅ»áÔ±µ¥Î»¡±¡¢¡°ÖÐ¹úÖÊÁ¿¹ýÓ²·ÅÐÄÆ·ÅÆ¡±¡¢¡°ÖÐ¹úÊÐ³¡¹«ÈÏ³©ÏúÆ·ÅÆ¡±¡¢¡°È«¹ú»ú´²Ê®¼ÑÃûÓÅÆ·ÅÆ¡±µÈÈÙÓþ³ÆºÅ ¡¡¡¡È«ÌåÔ±¹¤ÒÔÏÈ½øµÄ¼¼ÊõºÍÏÖ´ú»¯µÄ¹ÜÀíÊÖ¶ÎÎª×·Çó²úÆ·µÄÍêÃÀ¶ø²»Ð¸Å¬Á¦¡£¹«Ë¾ÓÚ2001Äê10ÔÂÈ«ÃæÍ¨¹ýISO9001£º2000ÖÊÁ¿¹ÜÀíÌåÏµÈÏÖ¤£¬2003Äê8ÔÂÍ¨¹ýÁËÈý¼¶¼ÆÁ¿È·ÈÏ£¬ÓµÓÐ×ÔÓª½ø³ö¿ÚÈ¨£¬ÎªÌá¸ß²úÆ·¿Æ¼¼µÄº¬½ðÁ¿¼°²úÆ·ÐÔÄÜ£¬2003Äê12ÔÂ¹«Ë¾ÓëºÏ·Ê¹¤Òµ´óÑ§ºÏ×÷³ÉÁ¢ÁË¡°»ú´²¹¤³Ì¼¼ÊõÑÐ¾¿ÖÐÐÄ¡±¡£2004ÄêWF67KÊý¿Ø°åÁÏÕÛÍä»úÐÂÆ·Éú²úÏßÏîÄ¿±»È«Ê¡·¢Õ¹¸Ä¸ïÎ¯Ô±»áÅú×¼ÎªÊ¡¡°Èý¸ß¡±ÏîÄ¿£¬²¢±»ÁÐÈëÊ¡¡°861¡±¼Æ»®ÖØµã½¨ÉèÏîÄ¿¡£¹ú¼ÒÖÊÁ¿¼ìÑé¼ìÒß×Ü¾ÖÓÚ2006Äê9ÔÂ¶ÔÎÒ¹«Ë¾µÄQC12Y-4£ª3200ÒºÑ¹°ÚÊ½¼ô°å»ú½øÐÐÁË²úÆ·ÖÊÁ¿¹ú¼Ò¼à¶½³é²é¡£ÎÒ¹«Ë¾²úÆ·Ò»´ÎÐÔÍ¨¹ý¸÷ÏîÖ¸±ê¼ìÑé£¬³É¼¨È«²¿¸ñ£¨¼ìÑé±¨¸æ±àºÅ£ºDJ-1055-D01-Q£©¡£¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡ÈýÁ¦²úÆ·¾«ÒæÇó¾«£¬ÈýÁ¦ÈË½«²»¶Ï¿ªÍØ£¬²»¶Ï´´ÐÂ£¬²¢Õæ³ÏµØÔ¸Óë¸÷½çÅóÓÑÐ¯ÊÖ¹²½ø£¬¹²Í¬·¢Õ¹¡£
µ¥Î»£º°²»ÕÊ¡ÈýÁ¦»ú´²ÖÆÔìÓÐÏÞ¹«Ë¾
µç»°£º0555-6721249   ´«Õæ£º0555-6612848
www.cnjczz.com
sl at cnjczz.com

¡ª¡ª¡ª¡ª¡ª¡ª¡ª¡ª¡ª¡ª¡ª¡ª¡ª¡ª¡ª¡ª¡ª¡ª¡ª¡ª¡ª¡ª¡ª¡ª¡ª¡ª¡ª¡ª¡ª¡ª
¡¾×¢Òâ¡¿ÉÏÃæµÄÓÊ¼þÄÚÈÝÓëÒÔÏÂÎÄ×ÖÎÞ¹Ø¡£±¾Èí¼þ½öÏÞÓÚºÏ·¨ÓÃÍ¾!
¸ÃÓÊ¼þÓÉ¡¶VolleymailÓÊ¼þÈº·¢×¨¼Ò¡·Èí¼þ·¢ËÍ£»±»ÍøÓÑÆÀÎª×îÀ÷º¦
µÄÓÊ¼þÈº·¢Èí¼þ¶ø¶à´ÎÒªÇóÆÆ½â£¡ÏÖÃâ·ÑÏÂÔØ£¬ÎÞÏÞÊ±¼äÊ¹ÓÃ¡£
ÏêÇéÇë·ÃÎÊÎÒÃÇµÄÖ÷Ò³£ºhttp://www.cnysoft.com/",
    "header": Object {
      "date": 2007-11-15T08:23:11.000Z,
      "from": Object {
        "email": "sl@cnjczz.com",
        "name": "=?GB2312?B?sLK71cqhyP3Bprv6tLLWxtTs09DP3rmry74=?=",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=%2A%2A%2ASPAM%2A%2A%2A%0A%09%3D%3FGB2312%3FB%3FuanTpqO6vPSw5bv6oaLV283ku/qhor7tsOW7%2BqGis%2BW0sqGi0KPGvbv6%3F%3D&In-Reply-To=",
      "subject": "***SPAM***	=?GB2312?B?uanTpqO6vPSw5bv6oaLV283ku/qhor7tsOW7+qGis+W0sqGi0KPGvbv6?=",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005051.html",
  },
  Object {
    "body": "On 2007-11-15, at 02:52 EST, Lars Hansen wrote:

[...]

> Generic functions can be useful for adding type-dispatched  
> functionality
> after the fact without creating facades/wrappers.

My view is that generic functions recognize that any function with  
more than one class parameter can't logically belong to any particular  
class.  They allow behaviors between classes to be described  
logically, rather than being artificially attached to one of the  
classes of their parameters.

Hey, can I say something like:

generic function get a (this: Foo) ?

[...]

> IMO we have a couple of options:
>  * remove generic functions from ES4 because they are too limited.
> Operator overloading goes away, too.
>  * accept them as they are, recognizing that they are future-proof and
> that they can be extended in later editions of the language (as we've
> done for type parameterization)
>  * try to extend them with insta

Is my mail client broken, or did you hit send too soon?",
    "header": Object {
      "date": 2007-11-15T13:02:21.000Z,
      "from": Object {
        "email": "ptw@pobox.com",
        "name": "P T Withington",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Understanding%20Generic%20Functions&In-Reply-To=1421FCFA117AA044B447467FDE380715D752AE%40eurmail.eur.adobe.com",
      "subject": "Understanding Generic Functions",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005052.html",
  },
  Object {
    "body": "> -----Original Message-----
> From: P T Withington [mailto:ptwithy at gmail.com] On Behalf Of 
> P T Withington
> Sent: 15. november 2007 14:02
> To: Lars Hansen
> Cc: John Resig; es4-discuss
> Subject: Re: Understanding Generic Functions
> 
> On 2007-11-15, at 02:52 EST, Lars Hansen wrote:
> 
> [...]
> 
> > Generic functions can be useful for adding type-dispatched 
> > functionality after the fact without creating facades/wrappers.
> 
> My view is that generic functions recognize that any function 
> with more than one class parameter can't logically belong to 
> any particular class.  They allow behaviors between classes 
> to be described logically, rather than being artificially 
> attached to one of the classes of their parameters.

Right, the binary method problem (even for larger values of \\"binary\\").

> Hey, can I say something like:
> 
> generic function get a (this: Foo) ?

Not at the moment, but this came up briefly the other day, I forget if
it was on this list or elsewhere, that maybe there is a global generic
function meta::get (just like there is a global intrinsic::+), and if
property lookup fails in an object the dispatch would go through that
function.  No decision on that (not even a ticket).

This discussion highlights the fact that generic functions sometimes
feel a little bolted on, because there are already class protocols that
do part of what generic functions do.  We're really not trying to do a
MOP for ES4, it's just that once we have generic function it's so easy
to be tempted.  \\"Just a little tweak here.\\"

> [...]
> 
> > IMO we have a couple of options:
> >  * remove generic functions from ES4 because they are too limited.
> > Operator overloading goes away, too.
> >  * accept them as they are, recognizing that they are 
> future-proof and 
> > that they can be extended in later editions of the language 
> (as we've 
> > done for type parameterization)
> >  * try to extend them with insta
> 
> Is my mail client broken, or did you hit send too soon?

The former, probably.  The last bullet (and the end of the message) was:

* try to extend them with instance methods, constructor methods,
variable-length parameter lists without going over the complexity budget

(I'm adding this pointless sentence here in case the bug in your mail
reader has to do with signature removal being thrown off by the bullet
starting the line above, or something silly like that.)

--lars",
    "header": Object {
      "date": 2007-11-15T13:16:27.000Z,
      "from": Object {
        "email": "lhansen@adobe.com",
        "name": "Lars Hansen",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Understanding%20Generic%20Functions&In-Reply-To=1633E9E9-DB0C-423F-B725-ECC74874C250%40pobox.com",
      "subject": "Understanding Generic Functions",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005053.html",
  },
  Object {
    "body": "Thanks. A bit more formal than was expecting, but I think it contains
what I'm looking for.

Peter

On Nov 14, 2007 3:36 PM, Brendan Eich <brendan at mozilla.org> wrote:
>
> On Nov 14, 2007, at 11:40 AM, Peter Hall wrote:
>
> > After searching through the wiki and ecmascript.org site,  I still
> > can't see any formal or informal explanation of how \\"like\\" and \\"is
> > like\\" work, except in passing, and not with precision. Does this
> > information exist somewhere?
>
> Sure, like totally! See in http://wiki.ecmascript.org/doku.php?
> id=resources:resources&s=valleyscript (note search term on that URL):
>
> http://www.soe.ucsc.edu/~cormac/papers/valleyscript.pdf
>
> /be
> _______________________________________________
> Es4-discuss mailing list
> Es4-discuss at mozilla.org
> https://mail.mozilla.org/listinfo/es4-discuss
>",
    "header": Object {
      "date": 2007-11-15T15:08:29.000Z,
      "from": Object {
        "email": "peter.hall@memorphic.com",
        "name": "Peter Hall",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=%22like%22%20and%20%22is%20like%22&In-Reply-To=27636C2E-5CEE-4C6A-B6BD-A4C709C8EEC9%40mozilla.org",
      "subject": "\\"like\\" and \\"is like\\"",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005054.html",
  },
  Object {
    "body": ">
>   Various interested parties favored something like the json2.js API
> already, and I think everyone will rally round it and beat on it, to make
> sure it has the right usability and knobs. I'm hopeful.
>

+1 from me. One request: When a filter function is provided to JSON.parse, I
would like the filter to be called with |this| defined to be the root object
that is being created by the parsed JSON text. Having a reference to the
created root object can be useful for some forms of filters such as
reference resolvers.


>  The problem in general is that Bob's classes and Alice's classes were
> written without anticipating Carol's combination of the two, but Carol
> cannot use MI. Nor can she provide objects that match structural types. She
> has to inherit from both Bob's and Alice's classes.
>
Was multiple inheritance discussed for inclusion in ES4? I am aware of the
general arguments against it, but I was wondering if had been considered or
if there are technical aspects of ES4 that preclude it.


> Does this clear things up?


Yes, that certainly helps me to understand the rationale. Thanks for being
so willing to answer questions about ES4 issues.

Kris
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://mail.mozilla.org/pipermail/es-discuss/attachments/20071115/a840286b/attachment-0002.html",
    "header": Object {
      "date": 2007-11-15T17:17:25.000Z,
      "from": Object {
        "email": "kriszyp@xucia.com",
        "name": "Kris Zyp",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Close%20review%20of%20Language%20Overview%20whitepaper&In-Reply-To=592414BC-79F0-48ED-9A87-02B6DDB4ADBF%40mozilla.org",
      "subject": "Close review of Language Overview whitepaper",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005055.html",
  },
  Object {
    "body": "On Nov 14, 2007, at 5:34 PM, Brendan Eich wrote:

>> Things I didn't see:
>>
>> What about standardizing the de facto <!-- comment syntax that is
>> necessary for web compatibility?
>
> Please write the spec ;-). Don't forget the --> mess.

We did talk about this at some point. I'm not sure everyone is aware  
of this web compatibility constraint, so I'll describe it briefly and  
incompletely.

When I embedded JS in HTML in 1995, I had a backward compatibility  
problem: Netscape 1.x and every other browser would see the inline  
script tag's content, as marked up text. So I took advantage of a  
content model that HTML-as-it-is inherited from SGML, CDATA, and made  
the script tag's content model be CDATA. This means that < does not  
need to be spelled &lt; -- thank goodness -- but it also allows SGML  
comments (or the approximation of them supported by HTML browsers) to  
wrap the entire inline content of <script>:

<script>
<!-- hide from old browsers
for (i = 0; i < N; i++) do_stuff(i);
// -->
</script>

This two-way comment hiding hack works because JS in browsers (not  
necessarily in other embeddings, see below) treats <!-- as the  
starting delimiter of a comment till end of line. I required  
programmers to use a JS one-line comment to hide the closing -->.

Unfortunately, and I'm going from memory so this may be off slightly,  
IE at least does not require --> to be commented in JS. This is bad  
in general since --> looks like post-decrement immediately followed  
by greater-than. There's a heuristic that insists on only leading  
horizontal whitespace on the line before the -->, and (I may have  
this part wrong in particular) nothing after the --> but whitespace.

Postel's Law bites back, so of course by the Web's law of copy and  
paste programming (cut and paste, actually), you find <!-- in the  
middle of .js files included via <script src=\\"foo.js\\">. These must be  
treated by JS as comment to end of line initiators.

This ends my tale of woe, except that I think embeddings on DVDs and  
in firmware that do not see web script should not have to deal with  
this nonsense. So I'm not sure a spec for this de-facto web standard  
is appropriate in ES4 or any normative core language spec. Of course,  
the copy/paste argument applies across embedding domains, but not so  
much. What do you think?

/be",
    "header": Object {
      "date": 2007-11-15T17:48:31.000Z,
      "from": Object {
        "email": "brendan@mozilla.org",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Close%20review%20of%20Language%20Overview%20whitepaper&In-Reply-To=5C557769-899E-4D66-95A7-22518AA71A8C%40mozilla.org",
      "subject": "Close review of Language Overview whitepaper",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005056.html",
  },
  Object {
    "body": "On Nov 15, 2007, at 9:17 AM, Kris Zyp wrote:

> +1 from me. One request: When a filter function is provided to  
> JSON.parse, I would like the filter to be called with |this|  
> defined to be the root object that is being created by the parsed  
> JSON text. Having a reference to the created root object can be  
> useful for some forms of filters such as reference resolvers.

Interesting -- a short example would help sell this, I bet.

>
> The problem in general is that Bob's classes and Alice's classes  
> were written without anticipating Carol's combination of the two,  
> but Carol cannot use MI. Nor can she provide objects that match  
> structural types. She has to inherit from both Bob's and Alice's  
> classes.
> Was multiple inheritance discussed for inclusion in ES4? I am aware  
> of the general arguments against it, but I was wondering if had  
> been considered or if there are technical aspects of ES4 that  
> preclude it.

We passed over MI without any regrets, for the general reasons you  
give. Also, even with MI, classes are not as flexible as structural  
types, as I've pointed out. They're different beasts, with different  
as well as some overlapping use-cases from structural types.

>
> Does this clear things up?
>
> Yes, that certainly helps me to understand the rationale. Thanks  
> for being so willing to answer questions about ES4 issues.
>

No problem.

/be",
    "header": Object {
      "date": 2007-11-15T17:58:29.000Z,
      "from": Object {
        "email": "brendan@mozilla.org",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Close%20review%20of%20Language%20Overview%20whitepaper&In-Reply-To=a641e4910711150917h2db21941gf23054ce12836783%40mail.gmail.com",
      "subject": "Close review of Language Overview whitepaper",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005057.html",
  },
  Object {
    "body": "On Nov 14, 2007, at 11:56 PM, Brendan Eich wrote:

> Modula 3 had branding for making nominal types from structural  
> types, but going the other way, \\"unbranding\\" a nominal type to get  
> a structural type, has no precedent I know of,

Shaver pointed to generic metaprogramming using C++ templates, which  
is close -- but of course the C++ static type system must make sense  
of everything before runtime, and you can't forge an instance of a C+ 
+ class. Important safety tip!

/be",
    "header": Object {
      "date": 2007-11-15T18:00:30.000Z,
      "from": Object {
        "email": "brendan@mozilla.org",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Close%20review%20of%20Language%20Overview%20whitepaper&In-Reply-To=592414BC-79F0-48ED-9A87-02B6DDB4ADBF%40mozilla.org",
      "subject": "Close review of Language Overview whitepaper",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005058.html",
  },
  Object {
    "body": "On Nov 15, 2007 9:58 AM, Brendan Eich <brendan at mozilla.org> wrote:

> On Nov 15, 2007, at 9:17 AM, Kris Zyp wrote:
>
> > +1 from me. One request: When a filter function is provided to
> > JSON.parse, I would like the filter to be called with |this|
> > defined to be the root object that is being created by the parsed
> Interesting -- a short example would help sell this, I bet.
>
Example: one could write a reference resolving filter that could handle JSON
referencing schemes for circular references and such.
obj = JSON.parse('{child:{$ref:\\"this\\"}}',function(k,v) {
   return k=='$ref' ? eval(v) : v; // non-eval resolvers could be used, but
this is succint
});
obj.child==obj -> true
This is really not a very big deal, it is easy to walk the tree after parse
to accomplish the same thing, I just figured that when a filter is called,
|this| must be something, why not something of value?

My expanded ideas on JSON referencing (not really relevant to ES4, just
FYI):
http://www.json.com/2007/10/19/json-referencing-proposal-and-library/ although
there are plenty of other ways to do it.
Kris
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://mail.mozilla.org/pipermail/es-discuss/attachments/20071115/d16af469/attachment-0002.html",
    "header": Object {
      "date": 2007-11-15T18:24:37.000Z,
      "from": Object {
        "email": "kriszyp@xucia.com",
        "name": "Kris Zyp",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Close%20review%20of%20Language%20Overview%20whitepaper&In-Reply-To=B81DD3D0-5553-46EC-962D-70A00ABFD68C%40mozilla.org",
      "subject": "Close review of Language Overview whitepaper",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005059.html",
  },
  Object {
    "body": "On Nov 14, 2007, at 5:34 PM, Brendan Eich wrote:

> On Nov 14, 2007, at 2:03 PM, Maciej Stachowiak wrote:
>
>> Conversions: \\"In addition, any value in the language converts to a
>> member of AnyBoolean\\", but the conversions specified are all to the
>> more specific \\"boolean\\" type, so perhaps it should be expressed that
>> way to avoid confusion.
>
> I thought this too, when reviewing this section. I think this is an
> open issue, but I can't find a ticket for it.

Found thanks to Lars:

http://bugs.ecmascript.org/ticket/246

/be",
    "header": Object {
      "date": 2007-11-15T18:49:38.000Z,
      "from": Object {
        "email": "brendan@mozilla.org",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Close%20review%20of%20Language%20Overview%20whitepaper&In-Reply-To=5C557769-899E-4D66-95A7-22518AA71A8C%40mozilla.org",
      "subject": "Close review of Language Overview whitepaper",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005060.html",
  },
  Object {
    "body": "I asked this in a bug comment, but it is more appropriate here.

Dylan has a singleton type constructor so that you can make a type out  
of an instance.  This is an alternate way of expressing the \`eql\`  
specializers of CLOS generic functions.  Should es4 have a singleton  
type constructor?  Ex:

theoneandonlyfoo = new Foo;

generic function stringify (o: Foo) { return \\"Any old Foo\\"; }
generic function stringify (o: singleton(theoneandonlyfoo)) { return  
\\"The one and only foo\\"; }",
    "header": Object {
      "date": 2007-11-15T20:27:22.000Z,
      "from": Object {
        "email": "ptw@pobox.com",
        "name": "P T Withington",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=singleton%20type%20constructor%3F&In-Reply-To=",
      "subject": "singleton type constructor?",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005061.html",
  },
  Object {
    "body": "On 2007-11-14, at 19:22 EST, Graydon Hoare wrote:

> (As far as I can tell -- not being a dylan hacker -- dylan doesn't  
> even
> go as far as having a global sentinel type like nil)

The Dylan equivalent of a nullable type is a union of your type with a  
singleton that acts as the sentinel.  Most often a singleton of the  
boolean false value is used.  So there is a macro \`false-or(<type>)\`  
that expands to \`type-union(<type>, singleton(#f))\`.  This works for  
any type other than a nullable boolean.  Because any value other than  
#f coerces to true in a boolean context, #f is very similar to nil.   
I've never known anyone to need a nullable boolean.  (Although I have  
seen whacky es3 code that uses true/false/null as a sloppy 3-valued  
enumeration -- with attended bug reports when null is passed expecting  
it to behave like false.)

I must say, coming from Dylan, es3's undefined _and_ null seem like  
overkill... but we're stuck with them now!",
    "header": Object {
      "date": 2007-11-15T22:02:55.000Z,
      "from": Object {
        "email": "ptw@pobox.com",
        "name": "P T Withington",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Dylan%20%27nullable%27%20types%20%5BWas%3A%20Close%20review%20of%20Language%20Overview%0A%09whitepaper%5D&In-Reply-To=473B9157.5010706%40mozilla.com",
      "subject": "Dylan 'nullable' types [Was: Close review of Language Overview	whitepaper]",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005062.html",
  },
  Object {
    "body": "P T Withington wrote:

> I must say, coming from Dylan, es3's undefined _and_ null seem like  
> overkill... but we're stuck with them now!

I think they feel like overkill to everyone, but yeah. Backward 
compatibility!

-Graydon",
    "header": Object {
      "date": 2007-11-15T22:06:30.000Z,
      "from": Object {
        "email": "graydon@mozilla.com",
        "name": "Graydon Hoare",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Dylan%20%27nullable%27%20types%20%5BWas%3A%20Close%20review%20of%20Language%20Overview%0A%09whitepaper%5D&In-Reply-To=117551CF-604F-4FC9-960F-5F82F1D7DF9F%40pobox.com",
      "subject": "Dylan 'nullable' types [Was: Close review of Language Overview	whitepaper]",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005063.html",
  },
  Object {
    "body": "On 14/11/2007, Maciej Stachowiak <mjs at apple.com> wrote:
> Section III.
>
> Syntax: The new non-contextual keywords, and the resulting need to
> specify dialect out of band, are a problem. I'll have more to say
> about compatibility under separate cover.

The model with version and e4x arguments in the Content-Type for
changing JS parsing has been used by moz already. Can we hear their
experience with regard to this compatibility problem?

Generally I think opt-in versioning such as this is the best you can
get for compatibility. Perhaps it would be wise to have a method that
is not external to the script as well, though, but I fail to see how
that could work compatibly in current ES3 only implementations.

> - The RegExp change - is this really a bug fix? It's likely that this
> is not a big compatibility issue (Safari's ES3 implementation had
> things the proposed ES4 way for some time) but I think ES3's approach
> may be more performance and generating a new object every time does
> not seem especially helpful.

It's a SpiderMonkey+ES3 fix, as I recall. The main problem with the
ES3 spec is that developers don't expect lastIndex to persist when
they evaluate the literal a second time, but also other mutable
properties. Real world code breaks because of this.

> Is there any significant implementation that anyone would claim is
> 100% free of ECMAScript 3 compliance bugs?

I don't even think you would get 100% compliance if you counted all
engines taken together - I think there's issues where no engine really
\\"gets it right\\", or for that matter can afford to \\"get it right\\". At
least, no browser hosted engine.

> Section IV.
>
> Classes: If any of the new type system is worthwhile, surely this is.
> The impedance mismatch between the class model used by most OO
> languages and by specifications like the DOM, and ES3's prototype
> model, is needlessly confusing to authors. So I approve of adding
> classes in a reasonable and tasteful way.

<somewhat offtopic>
For compatibility reasons with the ES3 bindings for the DOM, I think
the train has already left with regards crafting the DOM bindings
fully into the ES4 model. The way the ES bindings work is incompatible
with both ES3 prototype object hierarchies and ES4 classes/interfaces.
In particular we have multiple parallel interfaces, each of which
developers expect to be an object inherited from using the prototype
scheme. The bindings are incompatible with regards to ES4 interfaces
and classes in that ES4 interfaces from what I understand don't carry
implementation, aren't runtime objects nor can they present prototype
objects (obviously, since they aren't runtime objects).

I can only see two ways to solve this problem:
- Add a multiple inheritance scheme to ES4 that works on the prototype
delegation system as well as the nominal type system, solving the
diamond problem*. --> Severely complicating the object system.
- Remove these multiple parallel interfaces being exposed as run time
objects from the ES bindings, allowing a single inheritance hierarchy
to be formed from implementing them using ES4 interfaces. --> Making a
conformant DOM.next implementation not be a conformant DOM.current
implementation.


* A good resolution mechanism solving the diamond problem can be found
in Python and was borrowed by Perl 6, IIRC.
</somewhat offtopic>

> Literals:
> - I am surprised to see a decimal type (a type that is not directly
> supported in current mainstream hardware) even though generally
> popular types like single-precision IEEE floating point and 64 bit
> integers are not present.

I guess it directly addresses one large real world problem - that
fifths are inexactly represented in doubles, and there is a large
demand for reliable number handling of decimal values for amongst
other things money and measurements. I doubt the demand for single
floats or 64-bit integers is even close to as large as the demand for
accurate handling of common real world values like money.

> Section V.
> Record and array types: Structural types are confusingly similar to
> yet different from classes. Mostly they offer a subset of class
> functionality (though reading ahead I did see a few features limited
> to them).

They do allow for orthogonal type ideas, and I think many ES3
developers will be more comfortable with structural types than with
classes and interfaces, because they can add contracts without
changing their coding style. Replacing code written for the ES3 system
of using closures for privacy and prototypes for inheritance with code
written for the ES4 classical inheritance system will require
considerably more rethinking one's implementation.

> Also, already having prototype-based objects and class-based
> objects it seems excessive to add yet a third way. I recommend
> removing them and adding any features that are sorely missed as a
> result to classes.

Well, structural types doesn't really affect the object types, do
they? AIUI structural types are part of the contract system, not the
inheritance model. The object is still just a plain object, it just
has the given constraints.

> Type definitions: Seeing the example of a type definition for a record
> makes this feature seem even more redundant with classes.
>
> Data Types: If structural types cannot be recursive, then one of the
> canonical applications of record-like types, the linked list, cannot
> be implemented this way. I assume it can be with classes. Yet another
> reason to fold any interesting record features into classes.

Again, the difference is one of contract versus implementation.
Structural types cannot provide implementation, they can only provide
constraints.

> Nullability: Are non-nullable types really worth it? I am not sure.
> Does any other explicit type system for a dynamic OO language have
> such a concept? The whitepaper says that \\"the ability to store null is
> occasionally the source of run-time errors\\" but will not dynamic-
> checking result in runtime errors anyway when assigning null to a non-
> nullable variable (except in strict mode)?

It's a very desired distinction for at least library writers. Getting
early detection of this is very good for both code correctness and due
to possible performance improvements if the engine optimises it.

> Section VII.
>
> Type annotations and type checking: This section implies that type
> annotations are not at all being added for performance reasons and may
> indeed be harmful to performance. Wow! Seriously? I think runtime
> assertions are interesting when debugging but I do would not want them
> happening for every assignment statement in a release build of my C++
> code. I am not sure why ECMAScript programmers would want that. Later
> this section says \\"it is plausible\\" that typed programs will run
> faster and not slower with enough analysis, but this issue seems far
> too crucial to take such a blase attitude. Unless we can show that
> type annotations won't cause a performance hit in practice, and in
> particular give a convincing argument that the relevant analysis can
> be done with reasonable speed and without introducing an ahead-of-time
> compile phase, then it is irresponsible to include type annotations as
> currently designed. I am willing to believe that this is the case, but
> I cannot sign on to an attitude that we don't care if typed programs
> get faster or slower. Nor am I willing to take experience based on
> ahead-of-time compilers as definitive.

Most of the benefit from type annotations and type checking can be
gotten through a good enough compiler even for ES3 code, so I think
the performance side of the issue, while still important, is not at
all as important as being able to put guarantees for correctness.

> Section IX.
>
> Expression closures: I actually find the examples hard to follow given
> my expectation of ES3-like syntax. I think this may actually be
> syntactic salt.

Mostly it's a question of the code being perceived as slightly off if
you're used to the ES3 function expression syntax only. I still think
the syntax is a bit heavy, but it's pretty neat to have if you're from
FP background.

> Destructuring assignment and binding: I grudgingly accept that this
> sort of construct has been proven in the context of Python and Perl.

It's sugar and honey to me:)

> Slicing: This one I mildly object to. Array/String slicing is not, to
> my knowledge, particularly common in ECMAScript code of today. I am
> dubious that it merits its own operator syntax.

Seems like an innocent enough extension to me, and for some of the
uses, it should definitely allow engine to perform it faster than if
the developers had to code the equivalent functionality using only
ES3.
-- 
David \\"liorean\\" Andersson",
    "header": Object {
      "date": 2007-11-16T02:19:51.000Z,
      "from": Object {
        "email": "liorean@gmail.com",
        "name": "liorean",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Close%20review%20of%20Language%20Overview%20whitepaper&In-Reply-To=A8F25A0C-4059-4668-956D-348314F76C7D%40apple.com",
      "subject": "Close review of Language Overview whitepaper",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005064.html",
  },
  Object {
    "body": "{PharmaCanadaAll-1}
 {PharmaCanadaAll-1}

 {PharmaCanadaAll-2}

http://iceevening.cn

 Why spend more? Purchase meds with «CanadianPharmacy»!

Michael Weaver",
    "header": Object {
      "date": 2007-11-16T06:59:18.000Z,
      "from": Object {
        "email": "lyxulaudw@bostonharborcruises.com",
        "name": "Michael Weaver",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=%2A%2A%2ASPAM%2A%2A%2A%20You%20have%20no%20need%20to%20look%20for%20a%20reliable%20online%20drugstore%0A%09anymore.&In-Reply-To=",
      "subject": "***SPAM*** You have no need to look for a reliable online drugstore	anymore.",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005065.html",
  },
  Object {
    "body": "-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://mail.mozilla.org/pipermail/es-discuss/attachments/20071116/52dbe57c/attachment-0002.html",
    "header": Object {
      "date": 2007-11-16T08:40:11.000Z,
      "from": Object {
        "email": "destek@kmkbilisim.com.tr",
        "name": "kmkbilisim",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=%2A%2A%2ASPAM%2A%2A%2A%20web%20tasarimi&In-Reply-To=",
      "subject": "***SPAM*** web tasarimi",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005066.html",
  },
  Object {
    "body": "Which is better?

var nodes : int;
var widgetMap = Widget.instances; // a map.
var it:Iterator<string> = widgetMap.getKeys();

 -- this: --

try {
  widgetMap.get(it.next()).hide();
}
catch(Exception e) {
  if(e instanceof StopIteration) {

  }
}


 -- or this: --

while(it.hasNext()) {
  widgetMap.get(it.next()).hide();;
}

It might be the case that there might be some error
I want to catch other than StopIteration. In that case, to be
backwards-compatible and work across implementations, the developer
must use conditional
checks inside 1 catch block.

A hasNext() would not prevent the developer from writing such code.
Omitting hasNext() forces developers to use exception handling for
non-exceptional condition.

How does using try/catch for normal termination of the loop look?

It looks like all exceptions are unchecked in ES4. correct?  (I cannot
verify this to be true because
I am unable to access the spec namespace on ecmascript.org.)",
    "header": Object {
      "date": 2007-11-17T01:30:01.000Z,
      "from": Object {
        "email": "dhtmlkitchen@gmail.com",
        "name": "Garrett Smith",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Exception%20handling%20vs.%20hasNext%28%29&In-Reply-To=",
      "subject": "Exception handling vs. hasNext()",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005067.html",
  },
  Object {
    "body": "One benefit of StopIteration is that code inside map/some/every etc
can just throw a StopIteration to stop the iteration.  The same thing
is harder to keep clean with a hasNext/next pattern.

On Nov 16, 2007 5:30 PM, Garrett Smith <dhtmlkitchen at gmail.com> wrote:
> Which is better?
>
> var nodes : int;
> var widgetMap = Widget.instances; // a map.
> var it:Iterator<string> = widgetMap.getKeys();
>
>  -- this: --
>
> try {
>   widgetMap.get(it.next()).hide();
> }
> catch(Exception e) {
>   if(e instanceof StopIteration) {
>
>   }
> }
>
>
>  -- or this: --
>
> while(it.hasNext()) {
>   widgetMap.get(it.next()).hide();;
> }
>
> It might be the case that there might be some error
> I want to catch other than StopIteration. In that case, to be
> backwards-compatible and work across implementations, the developer
> must use conditional
> checks inside 1 catch block.
>
> A hasNext() would not prevent the developer from writing such code.
> Omitting hasNext() forces developers to use exception handling for
> non-exceptional condition.
>
> How does using try/catch for normal termination of the loop look?
>
> It looks like all exceptions are unchecked in ES4. correct?  (I cannot
> verify this to be true because
> I am unable to access the spec namespace on ecmascript.org.)
> _______________________________________________
> Es4-discuss mailing list
> Es4-discuss at mozilla.org
> https://mail.mozilla.org/listinfo/es4-discuss
>



-- 
erik",
    "header": Object {
      "date": 2007-11-17T01:44:19.000Z,
      "from": Object {
        "email": "erik.arvidsson@gmail.com",
        "name": "Erik Arvidsson",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Exception%20handling%20vs.%20hasNext%28%29&In-Reply-To=c9e12660711161730i6c0011f0n8a2a15e6be6a3c59%40mail.gmail.com",
      "subject": "Exception handling vs. hasNext()",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005068.html",
  },
  Object {
    "body": "Hi Erik,

Can you explain a little better by showing a code example?

Thanks.


On Nov 16, 2007 5:44 PM, Erik Arvidsson <erik.arvidsson at gmail.com> wrote:
> One benefit of StopIteration is that code inside map/some/every etc
> can just throw a StopIteration to stop the iteration.  The same thing
> is harder to keep clean with a hasNext/next pattern.
>
>
> On Nov 16, 2007 5:30 PM, Garrett Smith <dhtmlkitchen at gmail.com> wrote:
> > Which is better?
> >
> > var nodes : int;
> > var widgetMap = Widget.instances; // a map.
> > var it:Iterator<string> = widgetMap.getKeys();
> >
> >  -- this: --
> >
> > try {
> >   widgetMap.get(it.next()).hide();
> > }
> > catch(Exception e) {
> >   if(e instanceof StopIteration) {
> >
> >   }
> > }
> >
> >
> >  -- or this: --
> >
> > while(it.hasNext()) {
> >   widgetMap.get(it.next()).hide();;
> > }
> >
> > It might be the case that there might be some error
> > I want to catch other than StopIteration. In that case, to be
> > backwards-compatible and work across implementations, the developer
> > must use conditional
> > checks inside 1 catch block.
> >
> > A hasNext() would not prevent the developer from writing such code.
> > Omitting hasNext() forces developers to use exception handling for
> > non-exceptional condition.
> >
> > How does using try/catch for normal termination of the loop look?
> >
> > It looks like all exceptions are unchecked in ES4. correct?  (I cannot
> > verify this to be true because
> > I am unable to access the spec namespace on ecmascript.org.)
> > _______________________________________________
> > Es4-discuss mailing list
> > Es4-discuss at mozilla.org
> > https://mail.mozilla.org/listinfo/es4-discuss
> >
>
>
>
> --
> erik
>



--
Programming is a collaborative art.



-- 
Programming is a collaborative art.",
    "header": Object {
      "date": 2007-11-17T02:03:48.000Z,
      "from": Object {
        "email": "dhtmlkitchen@gmail.com",
        "name": "Garrett Smith",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Exception%20handling%20vs.%20hasNext%28%29&In-Reply-To=c9e12660711161803m47e254b4ybb29634c2244433e%40mail.gmail.com",
      "subject": "Exception handling vs. hasNext()",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005069.html",
  },
  Object {
    "body": "Consider the iteration decorator pattern:

var i = 0;
var producer = {
   'next': function () {
       if (i < 10) {
           return i++;
       } else {
           throw new StopIteration();
       }
   }
};

var consumer = {
   'next': function () {
       return producer.next() * 2;
   },
};

while (true) {
   try {
       log(consumer.next();
   } catch (exception) {
       if (exception instanceof StopIteration) {
       } else {
           throw exception;
       }
   }
}

(or, hiding the details, conceptually the equivalent:)

var producer = range(10);
var consumer = new Iteration(function () {
   return producer.next() * 2;
});
consumer.forEach(log);

Both of these examples would log even numbers in the interval [0, 20).
 The consumer iteration does not have a terminal condition, but the
producer iteration's StopIteration exception passed up through the
decorator to the consumer.  This would work really well if you
recursively decorated or \\"pipelined\\" an iteration with a conenience
function like eachIter.

/* an indefinite iteration of the values in someArray that are at
indicies that are multiples of six */
var it = range(100).eachIter(function (n) n * 2).whereIter(function
(n) !(n % 3)).eachIter(function (i) someArray[i]).each(log)

In that particular example, the last each on the line would catch the
StopIteration thrown by Range.next when it reaches 100.  Naturally, no
100 item arrays are ever created.

Kris Kowal

On 11/16/07, Garrett Smith <dhtmlkitchen at gmail.com> wrote:
> Hi Erik,
>
> Can you explain a little better by showing a code example?
>
> Thanks.
>
>
> On Nov 16, 2007 5:44 PM, Erik Arvidsson <erik.arvidsson at gmail.com> wrote:
> > One benefit of StopIteration is that code inside map/some/every etc
> > can just throw a StopIteration to stop the iteration.  The same thing
> > is harder to keep clean with a hasNext/next pattern.
> >
> >
> > On Nov 16, 2007 5:30 PM, Garrett Smith <dhtmlkitchen at gmail.com> wrote:
> > > Which is better?
> > >
> > > var nodes : int;
> > > var widgetMap = Widget.instances; // a map.
> > > var it:Iterator<string> = widgetMap.getKeys();
> > >
> > >  -- this: --
> > >
> > > try {
> > >   widgetMap.get(it.next()).hide();
> > > }
> > > catch(Exception e) {
> > >   if(e instanceof StopIteration) {
> > >
> > >   }
> > > }
> > >
> > >
> > >  -- or this: --
> > >
> > > while(it.hasNext()) {
> > >   widgetMap.get(it.next()).hide();;
> > > }
> > >
> > > It might be the case that there might be some error
> > > I want to catch other than StopIteration. In that case, to be
> > > backwards-compatible and work across implementations, the developer
> > > must use conditional
> > > checks inside 1 catch block.
> > >
> > > A hasNext() would not prevent the developer from writing such code.
> > > Omitting hasNext() forces developers to use exception handling for
> > > non-exceptional condition.
> > >
> > > How does using try/catch for normal termination of the loop look?
> > >
> > > It looks like all exceptions are unchecked in ES4. correct?  (I cannot
> > > verify this to be true because
> > > I am unable to access the spec namespace on ecmascript.org.)
> > > _______________________________________________
> > > Es4-discuss mailing list
> > > Es4-discuss at mozilla.org
> > > https://mail.mozilla.org/listinfo/es4-discuss
> > >
> >
> >
> >
> > --
> > erik
> >
>
>
>
> --
> Programming is a collaborative art.
>
>
>
> --
> Programming is a collaborative art.
> _______________________________________________
> Es4-discuss mailing list
> Es4-discuss at mozilla.org
> https://mail.mozilla.org/listinfo/es4-discuss
>",
    "header": Object {
      "date": 2007-11-17T08:28:41.000Z,
      "from": Object {
        "email": "kris.kowal@gmail.com",
        "name": "Kris Kowal",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Exception%20handling%20vs.%20hasNext%28%29&In-Reply-To=c9e12660711161803g76ccc3f6u6ece2f91a51bf380%40mail.gmail.com",
      "subject": "Exception handling vs. hasNext()",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005070.html",
  },
  Object {
    "body": "> /* an indefinite iteration of the values in someArray that are at
> indicies that are multiples of six */
> var it = range(100).eachIter(function (n) n * 2).whereIter(function
> (n) !(n % 3)).eachIter(function (i) someArray[i]).each(log)
>
> In that particular example, the last each on the line would catch the
> StopIteration thrown by Range.next when it reaches 100.  Naturally, no
> 100 item arrays are ever created.
>
> Kris Kowal

Sorry, that last |each| should be |forEach| for my claim that no 100
item arrays would be created to be accurate.

Kris Kowal",
    "header": Object {
      "date": 2007-11-17T08:31:15.000Z,
      "from": Object {
        "email": "kris.kowal@gmail.com",
        "name": "Kris Kowal",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Exception%20handling%20vs.%20hasNext%28%29&In-Reply-To=ef3cdbd90711170028x76dae9a4pf983e8f20c5e9786%40mail.gmail.com",
      "subject": "Exception handling vs. hasNext()",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005071.html",
  },
  Object {
    "body": "More advantages to StopIteration:

1) There are some iterations in which calculating whether the next
iteration exists is non-trivial, such as iterating on trees.

2) While one could work around non-trivial hasNext() calculations by
\\"pre-advancing\\" the iterator, i.e. if an iterator has returned the i-th
item, it has already calculated the (i+1)-th item, making hasNext()
simply check if the (i+1)-th item exists, such an approach is not only
less efficient, but won't work if the iterator makes side effects.

3) Repeated hasNext() checks can be slower than throwing and catching a
StopIteration, especially if the compiler is optimized to expect that
StopIteration from an iterator.

4) Iterator-generators hide the messy business of StopIteration:

// range is an iterator-generator (note the yield statement)
function range(len) {
    for (let i = 0; i < len; ++i)
       yield i;
}

for (let x in range(10))
    print(x);

No mention of StopIteration - or even next() - anywhere in that code yet
|range(10)| is clearly an iterator.

In case you were wondering, ES4's iteration protocol is heavily inspired
from Python, and I think Python has handled this iteration business very
well.

-Yuh-Ruey Chen

Erik Arvidsson wrote:
> One benefit of StopIteration is that code inside map/some/every etc
> can just throw a StopIteration to stop the iteration.  The same thing
> is harder to keep clean with a hasNext/next pattern.
>",
    "header": Object {
      "date": 2007-11-17T09:14:55.000Z,
      "from": Object {
        "email": "maian330@gmail.com",
        "name": "Yuh-Ruey Chen",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Exception%20handling%20vs.%20hasNext%28%29&In-Reply-To=6eeb8bd10711161744i4b18cbf7jaaaed71796cfc66%40mail.gmail.com",
      "subject": "Exception handling vs. hasNext()",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005072.html",
  },
  Object {
    "body": "Brendan Eich wrote:
> > So I take that |x instanceof {p: int}| won't work, and we'd have to  
> > use
> > |T = type {p: int}; x instanceof T| instead?
>
> No, the restriction on instanceof comes from ES3, which introduced  
> it, along with object initialisers. So x instanceof {p:int} (given a  
> binding for 'int' of course) is perfectly valid ES3 and ES4. It  
> throws an error in ES3 implementations that do not reserve  
> 'int' (e.g. SpiderMonkey):
>
> js> int = function (){}
> function () {
> }
> js> x = 42
> 42
> js> x instanceof {p:int}
> typein:3: TypeError: invalid 'instanceof' operand ({p:(function () {})})
>   

That was a bad example, I meant to ask whether |instanceof| could take
any type expr on the right. But now that I think of the ambiguities like
th, the answer to that is probably a no.

> > Plenty of discussion going on in ticket 300 concerning this. Ugh, this
> > semi-merging of value and type exprs is getting awkward. We're  
> > ending up
> > with just as many gotchas as we had before at this rate.
>
> Yes, this merge attempt failed already -- it was doomed from the  
> start. We need to get type expressions by themselves working. I'm  
> pretty sure we can resolve all grammatical issues to-do with type  
> expressions, and in that event, allowing a runtime name instead of  
> insisting only on a fixed type name will be easy.
>   

I have a proposal - see below.

> > Alright, overview time again. Our current goals are:
> > 1) Make |is| less restrictive and allow it accept (some) value exprs.
>
> At this point (some) means name expressions, not restricted to be  
> fixed type names.
>
> > 2) Keep |is| and type annotations coherent.
>
> Check, but allowing arbitrary names in type annotations is out. Still  
> coherent enough. Call it compromise, if you must -- I think 'is' the  
> operator has to compromise because it has too many connotations, and  
> different use-cases from type annotations.
>
> > 3) Keep |is| and |instanceof| (somewhat) coherent.
>
> We should define coherence more precisely:
>
> * 'is' takes a type expression on the right, but allows runtime name  
> in addition to fixed type name.
>   

Although I was initially in favor of this, now I'm not because it's a
rather noticeable exception to the rule.

> * instanceof takes a value expression per ES3 but if its result lacks  
> a [[HasInstance]] internal method (new formalism for ES4 needed, I'm  
> using ES3 meta-methods here), it checks for a meta-object result and  
> does 'is' -- else it throws TypeError.
>
> > 4) Keep all the type operators coherent (to a certain extent).
>
> Let's see:
>
> * 'cast' requires a fixed type expression on the right (no variable  
> name)
> * 'wrap' and 'like' require fixed type expressions.
>
> > 5) Try not to introduce too many exceptions to the rule a.k.a.  
> > gotchas.
>
> Yup.
>   

(Quoting everything, since I'll be referring to these goals.) There's
one goal I forgot to list:

6) Syntax brevity - the shorter the syntax, the better.

> > Whatever we do to advance one goal, another goal becomes more
> > compromised. Maybe we can place priorities on these goals? If we can
> > abandon one or two of these in favor of the other goals, this job  
> > would
> > be much simpler. Need to think on this some more...
>
> Let me know what you think of my interpretations and elaborations  
> just above. Thanks,
>
> /be
>   

It would be helpful if you can attach some priorities to those goals.

In the absence of \\"official\\" priorities, I've crafted a proposal. The
goals I'll be trying to satisfy are everything except brevity
(partially). Here's the gist of it:

If the main problem is that value exprs and type exprs are incompatible,
then why not make them compatible? Make it so that the only difference
between the two is that type-expr-like value exprs evaluate to
meta-objects and actual type exprs require fixed type properties. With
these as the only two differences and with no exceptions, I hope it will
be as intuitive as possible. The additional benefits is that type exprs
can be used much more freely since they will be a subset of value exprs.
Since the syntax of value exprs is fixed (due to compatibility
constraints), the only way to do this is to adjust the syntax of type
exprs. And this is where I'll violate the syntax brevity goal, which may
not be such a bad thing since it the intent of the syntax is now more
clear. Now to get into details:

The only real non-syntactic issue between type exprs and value exprs is
that in type exprs, the identifiers must be fixed type properties.
Everything else, such structural types and function types (ignoring the
identifiers), is fixed. For ex, |{p: x}| will always mean the same
thing, given that x is a fixed type; it can't be mutated. The rest of
the issues are syntactic ambiguities. So for each of these ambiguities
that I'm aware of, I'll either prefix it with |type| or \\"match\\" the
semantics between the value and type expr. Note that |type| is no longer
an operator; it can only be used in certain situations as listed below
(and as the type declaration/alias statement).

1) structural record and array types:
Require prefixing with |type|. e.g. |type {p: int}|.

2) union types:
Create a new union meta-object type so that \\"x | y\\", where both x and y
are meta-objects, evaluates to a meta-object of this type representing
the union of the types within x and y. The enclosing parentheses can be
omitted, but |()| still means the bottom type. Thus, the parenthesis
only purpose now is grouping. However, since |is| and |instanceof| have
higher precedence than \\"|\\", the parentheses must be used for \\"|\\" in
those exprs.

3) function types:
Require prefixing with |type|, e.g. |type function(a: int): void|.

4) type parameters:
With the above changes, not sure if anything needs to be changed since
type exprs are now a subset of value exprs.

Furthermore, now that type exprs and value exprs are unified, |is| can
now accept value exprs. For type annotations, type declarations, and
every other type operator besides |is| and |instanceof| (and |new|), if
any identifier would resolve to a non-fixed type property, then throw a
syntax error. As for future-proofing, we just have to make sure that new
type exprs are unambiguous and prefix the new syntax with |type| as
necessary.

With this I should meet all goals except the brevity one, and even that
goal isn't violated very much. So what does this all mean? I love
examples, so I'll be liberal with them:

Given:
type T1 = int
type T2 = double
V1 = int
V2 = double

// valid (note how V1 and V2 are freely used):
x is int
x is type {p: int}
x is like int
x is like type {p: int}
x is (T1 | T2)
x is V1
x is (V1 | T2)
x is {p: V2}
x is (like V1 | type {p: V2} | string)
x is ()
x is (((((T1)))))
x is (((((V1)))))
x is [like V2]
x is type function(a: T1, b: type {p: V1}): V2

// invalid (|type| is no longer an operator):
x is type int
x is type T1
x is type V1

// although \\"|\\" has low precedence, that precedence is higher than
statements and type annotations
type T3 = T1 | T2
V3 = T1 | V2
var x: T1 | T2
function foo(a: T1 | T2)

// invalid (|type| prefix is required)
type T5 = {p: int}
type T5 = [T1]
type T5 = function(): void
function foo(a: {p: int})

// |instanceof| shares same syntax with |is| now:
x instanceof int
x instanceof like int
x instanceof (like T1 | type {p: V2})
// but still works with constructors (even if meaningless)
x instanceof function(){}

// valid type annotations:
var x: T1
var x: type [T1]
var x: like type {p: T2}
var x: T1 | T2
function foo(a: T1, b: T2)

// invalid type annotations (if they contain any non-fixed type property
identifiers)
var x: V1
var x: T1 | T2 | V1
var x: T1 | (type {p: T2, q: type [like V1]}
function foo(a: T1, b: V2)

|new| remains the same. All the other type operators have the same
restrictions as type annotations (allow only fixed type properties), so
don't need examples for them.

Thoughts? I hope I haven't missed anything.

-Yuh-Ruey Chen",
    "header": Object {
      "date": 2007-11-17T09:54:29.000Z,
      "from": Object {
        "email": "maian330@gmail.com",
        "name": "Yuh-Ruey Chen",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=need%20some%20clarification%20on%20compile-time%20type%20vs.%20run-time%20type&In-Reply-To=82121FAF-86D8-480E-9DBC-F4B2FD2AE21F%40mozilla.org",
      "subject": "need some clarification on compile-time type vs. run-time type",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005073.html",
  },
  Object {
    "body": "Is it not possible to emulate this already with classes? I think you can
use the implicitly-called construct method, e.g.

class myint {
    private var i: int;
    function myint(x: int) {
       this.i = int;
    }
    meta static function invoke(x: int) {
       if (x > SOME_MAX_VALUE || x < SOME_MIN_VALUE)
          throw some_error;
       return new myint(x);
    }
}

Or something like that. Above code is probably wrong. I'm not sure
exactly when and how invoke is called or even what the implicit type
conversion customization protocol is.

However, if it isn't possible to create a class to emulate such
constraints, maybe we ought to do something about it...

-Yuh-Ruey Chen

liorean wrote:
> Hello!
>
> Since we now have a namespace for uint specific math operations, and
> discussion in another thread about using pragmas for throwing if
> assigning to ReadOnly properties... Is it possible we could have a
> look at the idea of adding constrained primitive types or adding a
> pragma changing the mechanism for, or adding a separate set of
> operations, constraining number types by the simple rule of (input >
> output_type.MAX_VALUE) and (input < output_type.MIN_VALUE) throwing an
> out-of-bounds error.
>
> I'm a little concerned that a type of uint allows assigning negatives
> with a silent round-the-corner conversion and allows values of NaN and
> Infinity. (I imagine for example the DOM interfaces that have uint
> constraints really would like these to throw an out-of-bounds
> exception or similar.)
>
> Also, the RI gives an Overflow exception for values 2^32 or greater,
> which I'm not sure whether it's the intended behaviour or a result of
> the underlying implementation that is in fact intended to fail
> silently like the other cases.
>
> >> function fn(input:uint):uint input;
> >> fn(0x7fffffff);
> 2147483647
> >> fn(-0x80000000);
> 2147483648
> >> fn(Infinity);
> 0
> >> fn(NaN);
> 0
> >> fn(0x100000000);
> unhandled exception: Overflow
>
> >> function fn(input:int):int input;
> >> fn(0x7fffffff)
> 2147483647
> >> fn(0x80000000)
> -2147483648
> >> fn(-0x80000000)
> -2147483648
> >> fn(NaN)
> 0
> >> fn(Infinity)
> 0
> >> fn(0x100000000)
> unhandled exception: Overflow
>",
    "header": Object {
      "date": 2007-11-17T10:11:31.000Z,
      "from": Object {
        "email": "maian330@gmail.com",
        "name": "Yuh-Ruey Chen",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Bringing%20up%20the%20issue%20of%20numerical%20constraints%20again&In-Reply-To=cee13aa30711121656i43ab67dbr3ff777e5c7710da8%40mail.gmail.com",
      "subject": "Bringing up the issue of numerical constraints again",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005074.html",
  },
  Object {
    "body": "On Nov 17, 2007 11:11 AM, Yuh-Ruey Chen <maian330 at gmail.com> wrote:
> Is it not possible to emulate this already with classes? I think you can
> use the implicitly-called construct method, e.g.
>
> class myint {
>     private var i: int;
>     function myint(x: int) {
>        this.i = int;
>     }
>     meta static function invoke(x: int) {
>        if (x > SOME_MAX_VALUE || x < SOME_MIN_VALUE)
>           throw some_error;
>        return new myint(x);
>     }
> }
>
> Or something like that. Above code is probably wrong. I'm not sure
> exactly when and how invoke is called

It's only ever called explicitly.

> or even what the implicit type conversion customization protocol is.

Any number type converts to any other; String and string interconvert;
Boolean and boolean interconvert; anything converts to boolean.  These
are special case rules in the system; you can't extend them.

> However, if it isn't possible to create a class to emulate such
> constraints, maybe we ought to do something about it...

A more restrictive rule might be that implicit conversions can only
take place so that data are not lost, ie, implicit double -> uint is
allowed if the value fits in uint but not otherwise.  I don't think
this fits in very well with ES3; in ES3, the ToUint32 conversion will
happily chop off higher order bits.  I'm not defending that, just
noting that if we want to stick to \\"the spirit of the language\\" then
we stick with this conversion behavior on (any number) -> uint also.

--lars

>
> -Yuh-Ruey Chen
>
>
> liorean wrote:
> > Hello!
> >
> > Since we now have a namespace for uint specific math operations, and
> > discussion in another thread about using pragmas for throwing if
> > assigning to ReadOnly properties... Is it possible we could have a
> > look at the idea of adding constrained primitive types or adding a
> > pragma changing the mechanism for, or adding a separate set of
> > operations, constraining number types by the simple rule of (input >
> > output_type.MAX_VALUE) and (input < output_type.MIN_VALUE) throwing an
> > out-of-bounds error.
> >
> > I'm a little concerned that a type of uint allows assigning negatives
> > with a silent round-the-corner conversion and allows values of NaN and
> > Infinity. (I imagine for example the DOM interfaces that have uint
> > constraints really would like these to throw an out-of-bounds
> > exception or similar.)
> >
> > Also, the RI gives an Overflow exception for values 2^32 or greater,
> > which I'm not sure whether it's the intended behaviour or a result of
> > the underlying implementation that is in fact intended to fail
> > silently like the other cases.
> >
> > >> function fn(input:uint):uint input;
> > >> fn(0x7fffffff);
> > 2147483647
> > >> fn(-0x80000000);
> > 2147483648
> > >> fn(Infinity);
> > 0
> > >> fn(NaN);
> > 0
> > >> fn(0x100000000);
> > unhandled exception: Overflow
> >
> > >> function fn(input:int):int input;
> > >> fn(0x7fffffff)
> > 2147483647
> > >> fn(0x80000000)
> > -2147483648
> > >> fn(-0x80000000)
> > -2147483648
> > >> fn(NaN)
> > 0
> > >> fn(Infinity)
> > 0
> > >> fn(0x100000000)
> > unhandled exception: Overflow
> >
>
> _______________________________________________
> Es4-discuss mailing list
> Es4-discuss at mozilla.org
> https://mail.mozilla.org/listinfo/es4-discuss
>",
    "header": Object {
      "date": 2007-11-17T12:35:10.000Z,
      "from": Object {
        "email": "lth@acm.org",
        "name": "Lars T Hansen",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Bringing%20up%20the%20issue%20of%20numerical%20constraints%20again&In-Reply-To=473EBE53.1070200%40gmail.com",
      "subject": "Bringing up the issue of numerical constraints again",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005075.html",
  },
  Object {
    "body": "On Nov 16, 2007, at 5:30 PM, Garrett Smith wrote:

> Which is better?
>
> var nodes : int;
> var widgetMap = Widget.instances; // a map.
> var it:Iterator<string> = widgetMap.getKeys();
>
>  -- this: --
>
> try {
>   widgetMap.get(it.next()).hide();
> }
> catch(Exception e) {
>   if(e instanceof StopIteration) {
>
>   }
> }
>
>
>  -- or this: --
>
> while(it.hasNext()) {
>   widgetMap.get(it.next()).hide();;
> }

Neither. This is best:

for each (w in widgetMap)
     w.hide();

But your two examples are not equivalent. The first calls the  
iterator exactly once, the second loops over all keys. I'm asuming  
widgetMap.get(key) returns the corresponding widget value, so for- 
each-in is the way to loop, not for-in (and never while).

As in Python, you rarely have to get or make an iterator explicitly;  
you almost never have to catch StopIteration.

/be",
    "header": Object {
      "date": 2007-11-17T13:50:56.000Z,
      "from": Object {
        "email": "brendan@mozilla.org",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Exception%20handling%20vs.%20hasNext%28%29&In-Reply-To=c9e12660711161730i6c0011f0n8a2a15e6be6a3c59%40mail.gmail.com",
      "subject": "Exception handling vs. hasNext()",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005076.html",
  },
  Object {
    "body": "If you are looking for the way to save on your meds, then this information is for you. Buy medications in Canada. They are manufactured according to the same strict pharmaceutical standards as American ones.

 High level of service is «CanadianPharmacy»'s strong point, our customer care people do their best to help each customer in careful and non-embarrassing way. Prompt delivery and absolute security of your information are guaranteed!

http://valuedrive.cn

 The cheapest place to buy your meds!

John Walts",
    "header": Object {
      "date": 2007-11-17T18:26:17.000Z,
      "from": Object {
        "email": "dwsatyam@satya.com",
        "name": "John Walts",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=%2A%2A%2ASPAM%2A%2A%2A%20Make%20significant%20savings%20buying%20medications%20in%20Canada.&In-Reply-To=",
      "subject": "***SPAM*** Make significant savings buying medications in Canada.",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005077.html",
  },
  Object {
    "body": "Yuh-Ruey Chen wrote:
> If the main problem is that value exprs and type exprs are incompatible,
> then why not make them compatible? Make it so that the only difference
> between the two is that type-expr-like value exprs evaluate to
> meta-objects and actual type exprs require fixed type properties. With
> these as the only two differences and with no exceptions, I hope it will
> be as intuitive as possible. The additional benefits is that type exprs
> can be used much more freely since they will be a subset of value exprs.
> Since the syntax of value exprs is fixed (due to compatibility
> constraints), the only way to do this is to adjust the syntax of type
> exprs. And this is where I'll violate the syntax brevity goal, which may
> not be such a bad thing since it the intent of the syntax is now more
> clear. Now to get into details:
>
> The only real non-syntactic issue between type exprs and value exprs is
> that in type exprs, the identifiers must be fixed type properties.
> Everything else, such structural types and function types (ignoring the
> identifiers), is fixed. For ex, |{p: x}| will always mean the same
> thing, given that x is a fixed type; it can't be mutated. The rest of
> the issues are syntactic ambiguities. So for each of these ambiguities
> that I'm aware of, I'll either prefix it with |type| or \\"match\\" the
> semantics between the value and type expr. Note that |type| is no longer
> an operator; it can only be used in certain situations as listed below
> (and as the type declaration/alias statement).

Also, the elimination of the separation between type exprs and value
exprs in favor of focusing on fixed type properties vs. non-fixed
properties should be vaguely familiar with C++ programmers. If you
consider fixed type properties in type exprs as a form of C++ \\"const\\",
then it's similar in that you have to make sure everything that
everything that is const, only contains const exprs, and ultimately
const identifiers. Actually, a more proper analogous example would be
C++ templates, which work on the equivalent of ES4 fixed types (and
const values). This fixed vs. non-fixed distinction is the only thing
users need to be aware of - otherwise, they can mix and match type and
value exprs freely. That's why I argue that this is easier to grasp (or
at least more familiar) than the current type expr vs. value expr
distinction.

-Yuh-Ruey Chen",
    "header": Object {
      "date": 2007-11-17T20:57:00.000Z,
      "from": Object {
        "email": "maian330@gmail.com",
        "name": "Yuh-Ruey Chen",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=need%20some%20clarification%20on%20compile-time%20type%20vs.%20run-time%20type&In-Reply-To=473EBA55.5010409%40gmail.com",
      "subject": "need some clarification on compile-time type vs. run-time type",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005078.html",
  },
  Object {
    "body": "{PharmaCanadaAll-1}
 {PharmaCanadaAll-1}

 {PharmaCanadaAll-2}

http://ladyjust.cn

 Appreciate the convenience of online ordering.

Hector Fuger",
    "header": Object {
      "date": 2007-11-18T04:03:45.000Z,
      "from": Object {
        "email": "dwsousleym@sousley.com",
        "name": "Hector Fuger",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=%2A%2A%2ASPAM%2A%2A%2A%20Start%20new%20life%20with%20CanadianPharmacy.&In-Reply-To=",
      "subject": "***SPAM*** Start new life with CanadianPharmacy.",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005079.html",
  },
  Object {
    "body": "Hi Maciej,

Thanks for your feedback! Two additional comments...

> \\"Any\\": The spec explains vaguely that the \\"any\\" type is not identical
> to the union (null, undefined, Object). How is it different? Is the
> difference observable to ES4 programs or is it purely a matter
> internal to the spec (in which case the difference is not relevant)?

The essential difference is in strict mode, where a variable of type
\\"Any\\" can be passed to a context expecting a more specific type (say
int), and \\"Any\\" gets implicitly downcast. In contrast, passing \\"(null,
undefined, Object)\\" or even \\"Object\\" to somewhere expecting an int
would be a verify-time error.

> \\"switch type\\" statement: I guess this beats switching on typeof, but
> is it really significantly better than a series of \\"if\\" statements
> using the \\"is\\" operator?

Well, you'd need a bunch of cast operations too, at least in strict
mode, and it gets a little ugly/verbose.

- Cormac",
    "header": Object {
      "date": 2007-11-18T04:08:04.000Z,
      "from": Object {
        "email": "cormac@ucsc.edu",
        "name": "Cormac Flanagan",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Close%20review%20of%20Language%20Overview%20whitepaper&In-Reply-To=A8F25A0C-4059-4668-956D-348314F76C7D%40apple.com",
      "subject": "Close review of Language Overview whitepaper",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005080.html",
  },
  Object {
    "body": "On Nov 17, 2007 5:50 AM, Brendan Eich <brendan at mozilla.org> wrote:
> On Nov 16, 2007, at 5:30 PM, Garrett Smith wrote:
>
> > Which is better?
> >
> > var nodes : int;
> > var widgetMap = Widget.instances; // a map.
> > var it:Iterator<string> = widgetMap.getKeys();
> >
> >  -- this: --
> >
> > try {
> >   widgetMap.get(it.next()).hide();
> > }
> > catch(Exception e) {
> >   if(e instanceof StopIteration) {
> >
> >   }
> > }
> >
> >
> >  -- or this: --
> >
> > while(it.hasNext()) {
> >   widgetMap.get(it.next()).hide();;
> > }
>
> Neither. This is best:
>
> for each (w in widgetMap)
>      w.hide();
>
> But your two examples are not equivalent. The first calls the
> iterator exactly once, the second loops over all keys. I'm asuming
> widgetMap.get(key) returns the corresponding widget value, so for-
> each-in is the way to loop, not for-in (and never while).
>
Yep, I typed that up @ wk. My brain was still holding some PHP code
and other irrelevant things (my dislike for PHP, food, wanting to
lift, and other topics that may be less relevant).

So... I want to iterate over the keys in a Map.

I would not like to iterate over properties of the map (and it's
prototype); so I'm pretty sure that for in (or for each) is not what I
want. I want to iterate over the key (not object properties).

Kris, it looks like in your example, there's no option for handling
the loop normally:

while (true) {
   try {
       log(consumer.next();
   } catch (exception) {
       if (exception instanceof StopIteration) {
       } else {
           throw exception;
       }
   }
}

I see how normal termination is handled via a try catch, with a
conditional if clause in the catch. What I fail to see is why this is
better than hasNext/next paradigm.

It looks like the reasons for omitting hasNext are:
1) Python does it
2) using try/catch would be faster
3) harder to keep clean with next/hasNext pattern.
Reason 1 isn't a reason for omitting hasNext, is it?
Reason 2 is just copying Python's poor reasoning.
Reason 3 has not yet been shown to be true in any way.

I thought the purpose of exception handling was to handle exceptional
conditions.

Does the new Iterator is requires the use of try/catch in a way that
is appropriate?

If so, why?

In ES3, I use hasOwnProperty in a for/in loop over an object's
properties. Not the prettiest thing, but at least it requires no
exception handling.

How is it possible to iterate over the keys in a Map? I'd like to
avoid using try/catch, unless something in the loop body might require
it, and in that case, I'll want to be very clear on what might throw
an exception, how, and why, as well as provide correct handling of
that exception. Is there a way to get a maps keys as an Array?

I've seen APIs of popular JS libraries swallow exceptions. For
example, YUI's Connection Manager used to do this on the callback
handler, silently swallowing any error that I, as a user of that API,
might throw (painful).  I'm wondering if providing an API that
requires try/catch for non-exceptional conditions cheapens the nature
of exception handling. I mean, won't developers say \\"oh, it's just a
normal exception, we can ignore it.\\"

Garrett

> As in Python, you rarely have to get or make an iterator explicitly;
> you almost never have to catch StopIteration.
>
> /be
>
>



-- 
Programming is a collaborative art.",
    "header": Object {
      "date": 2007-11-19T07:51:58.000Z,
      "from": Object {
        "email": "dhtmlkitchen@gmail.com",
        "name": "Garrett Smith",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Exception%20handling%20vs.%20hasNext%28%29&In-Reply-To=40CCE322-2844-47BA-8B71-858E538A5F5A%40mozilla.org",
      "subject": "Exception handling vs. hasNext()",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005081.html",
  },
  Object {
    "body": "Garrett Smith wrote:
> How is it possible to iterate over the keys in a Map? I'd like to
> avoid using try/catch, unless something in the loop body might require
> it, and in that case, I'll want to be very clear on what might throw
> an exception, how, and why, as well as provide correct handling of
> that exception. Is there a way to get a maps keys as an Array?
>   

I think you're misunderstanding how iterators work. You don't need to
explicitly use the next() method or catch StopIteration. Please look at
how Python does it. There are plenty of examples on the web; here's one:

for x in range(10):
    print(x)

which is practically equivalent in ES3 to:

for (let x = 0; x < 10; ++x)
    print(x);

The Python for-in is equivalent in ES4 (assuming range is defined
equivalently) to:

for (let x in range(10))
    print(x);

This practically translates to:

let $iter = range(10);   // $iter not visible to rest of code
try {
    for (;;)
    {
          let x = $iter.next();
          print(x);
    }
} catch (e: StopException) {}

As you can see, the for-in loop syntax completely hides the next() and
StopIteration. It's definitely not as cumbersome as you think - in fact,
it's even easier to use than hasNext()/next()-style iterators.

To answer your specific question, Map should have a getKeys() method
(according to the wiki) that returns an iterator iterating over the keys
of the map:

for (let k in map.getKeys())
    print(k);

FYI, the original ES3 for-in is actual a special case of the ES4 for-in.
When you do |for (let p in obj)|, it's actually iterating over obj's
intrinsic iterator (obj.iterator::get() according to the wiki), which
enumerates obj's properties, just like what it does in ES3.

-Yuh-Ruey Chen",
    "header": Object {
      "date": 2007-11-19T08:38:13.000Z,
      "from": Object {
        "email": "maian330@gmail.com",
        "name": "Yuh-Ruey Chen",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Exception%20handling%20vs.%20hasNext%28%29&In-Reply-To=c9e12660711182351o29c1133dsafba13c565d0129a%40mail.gmail.com",
      "subject": "Exception handling vs. hasNext()",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005082.html",
  },
  Object {
    "body": "More clarifications and updates to my proposal:

Yuh-Ruey Chen wrote:
> The only real non-syntactic issue between type exprs and value exprs is
> that in type exprs, the identifiers must be fixed type properties.
> Everything else, such structural types and function types (ignoring the
> identifiers), is fixed. For ex, |{p: x}| will always mean the same
> thing, given that x is a fixed type; it can't be mutated. The rest of
> the issues are syntactic ambiguities. So for each of these ambiguities
> that I'm aware of, I'll either prefix it with |type| or \\"match\\" the
> semantics between the value and type expr. Note that |type| is no longer
> an operator; it can only be used in certain situations as listed below
> (and as the type declaration/alias statement).
>   

Just realized a problem. The grouping operator (parentheses) means
something different for type exprs and value exprs. Type exprs can only
nest type exprs within parenthesis, while value exprs can nest any value
expr within them. Couple choices here:

1) Leave this is a distinction between type expr and value expr.
Downside to this is that type expr and value expr won't fully be unified
(and the downside to that has been amply discussed).

2) Eliminate the ambiguity in the grammar. Introduce |type (...)|.
Downside is the verbosity and possible confusion as to when to use |type
(...)| rather than |(...)| (or at least why they have to be different).

3) Don't change the grammar and handle the ambiguity by keeping track of
whether a particular expression resolves to a type and throwing early
errors when we're in a type expr context and we're trying to perform an
illegal operation on the type (e.g. non-type operators like +). Since
types are computed early, determining whether a particular expr resolves
to a type can also be computed early, so this type of processing can be
done. I have some experience making a pseudo-C parser, and this is
similar to keeping track of whether an expr is an lvalue. In essence,
the term \\"type expr\\" is not a grammar production and is unrelated to
operator precedence; it's an \\"aspect\\" of an expression (just like
lvalues). Downside to this is that it complicates the parser logic.

I think (3) is the best solution. It's the most convenient for the user.
It does make the learning curve slightly steeper in that now the user
needs to keep in mind that type exprs cannot contain non-type exprs AND
in type annotations and all type operators besides |is| and
|instanceof|, type exprs must contain only fixed type prop identifiers.
But I don't think it's that bad.

Also, although it's not strictly necessary to keep the \\"type exprs only
nest type exprs\\" principle outside of type annotations et al., I think
it makes type annotations and |is| more coherent, in that the only
difference between them is the fixed type prop identifier restriction.
BTW, we really need a term that represents type exprs in type
annotations et al.; it's getting repetitive to say \\"type exprs in type
annotations and all type operators besides |is| and |instanceof|\\" all
the time...

> 2) union types:
> Create a new union meta-object type so that \\"x | y\\", where both x and y
> are meta-objects, evaluates to a meta-object of this type representing
> the union of the types within x and y. The enclosing parentheses can be
> omitted, but |()| still means the bottom type. Thus, the parenthesis
> only purpose now is grouping. However, since |is| and |instanceof| have
> higher precedence than \\"|\\", the parentheses must be used for \\"|\\" in
> those exprs.
>   

The way I've defined the union operator here introduces another value
vs. type expr conflict. Although pretty nifty, it would allow exprs
like: \\"x | func()\\" or \\"(b? int : double) | string\\", which shouldn't be
allowed in type exprs considering that type exprs should only nest other
type exprs. The precedence of \\"|\\" also poses an issue since it's
completely different from that of type primaries. The operands of \\"|\\"
can not only be type primaries but also any value expr with higher
predence than \\"|\\". This violates the principle that type exprs can only
nest type exprs.

I think solution (3) above can handle this though with some
modification, especially because it redefines the term \\"type expr\\" to
have nothing to do with operator precedence. Specifically, if an operand
of \\"|\\" resolves to a type, throw early errors if the other operand
doesn't resolve to a type. This would invalidate and throw early errors
for the above \\"|\\" examples.

> 4) type parameters:
> With the above changes, not sure if anything needs to be changed since
> type exprs are now a subset of value exprs.

I'm wrong here because that violates the \\"type exprs only nest type
exprs\\" principle. Also, I meant to refer to \\"type arguments\\" rather than
\\"type parameters\\". Is there any reason why type arguments should accept
value exprs in a value expr context? If not, then this can be resolved
by restricting type arguments to type exprs.

-Yuh-Ruey Chen
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://mail.mozilla.org/pipermail/es-discuss/attachments/20071119/4b89574c/attachment-0002.html",
    "header": Object {
      "date": 2007-11-19T09:31:53.000Z,
      "from": Object {
        "email": "maian330@gmail.com",
        "name": "Yuh-Ruey Chen",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=need%20some%20clarification%20on%20compile-time%20type%20vs.%20run-time%20type&In-Reply-To=473EBA55.5010409%40gmail.com",
      "subject": "need some clarification on compile-time type vs. run-time type",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005083.html",
  },
  Object {
    "body": "On Nov 19, 2007, at 7:51 AM, Garrett Smith wrote:

> So... I want to iterate over the keys in a Map.

Yuh-Ruey already replied, but I just wanted to point out that this:

for (let k in map.iterator::getKeys())
     print(k);

can be done simply via:

for (let k in map)
     print(k)

because the Map class provides the key iterator that its  
iterator::getKeys method returns from its default iterator::get  
method (which for-in calls) too. That is, by default, Map iteration  
returns keys.

If you want values or items (key/value pairs), you can get those too.  
To iterate over values, you might use:

for (let v in map.iterator::getValues())
     print(v);

but you should rather use the more succinct for-each-in loop:

for each (let v in map)
     print(v);

To iterate over items, use:

for (let [k, v] in map.iterator::getItems())
     print(k, v);

This item iteration case has no more concise form analogous to for- 
each-in, because if ES4 were always to map:

for (let [k, v] in map) ...

to:

for (let [k, v] in map.iterator::getItems()) ...

it would wrongly preempt destructuring of arbitrary properties from  
the value returned by the default iterator (the object returned by  
map.iterator::get()) -- it would prevent writing:

for (let [s, v, o] in tripledb) ...

where tripledb.iterator::get() returns an iterator over [subject,  
verb, object] triples.

If you feel the need to use a Java-like hasMore/getNext pattern, just  
lie down till the feeling goes away ;-). The Pythonic iteration  
protocol is simpler to use, more efficient to implement, and has no  
unchecked inconsistent state possibilities between hasMore and  
getNext. And yes, leveraging Python here is good reuse of language  
design, implementation experience, and user knowledge.

You do not need to catch StopIteration in any common cases. So don't  
fret about the fact that there's an exception thrown under the hood.  
Exceptions are not all errors.

/be",
    "header": Object {
      "date": 2007-11-19T17:40:47.000Z,
      "from": Object {
        "email": "brendan@mozilla.org",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Exception%20handling%20vs.%20hasNext%28%29&In-Reply-To=c9e12660711182351o29c1133dsafba13c565d0129a%40mail.gmail.com",
      "subject": "Exception handling vs. hasNext()",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005084.html",
  },
  Object {
    "body": "An HTML attachment was scrubbed...
URL: http://mail.mozilla.org/pipermail/es-discuss/attachments/20071119/1eb654b1/attachment-0002.html",
    "header": Object {
      "date": 2007-11-19T18:33:38.000Z,
      "from": Object {
        "email": "ea@env3.carteiroxpress.com",
        "name": "luciano",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=leilao%20boer%20baby%20canal%20do%20boi%20dia%2015-11-2007&In-Reply-To=",
      "subject": "leilao boer baby canal do boi dia 15-11-2007",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005086.html",
  },
  Object {
    "body": "On 2007-11-19, at 12:40 EST, Brendan Eich wrote:

> This item iteration case has no more concise form analogous to for-
> each-in, because if ES4 were always to map:
>
> for (let [k, v] in map) ...
>
> to:
>
> for (let [k, v] in map.iterator::getItems()) ...
>
> it would wrongly preempt destructuring of arbitrary properties from
> the value returned by the default iterator

Say, if we don't waste parens on union types, what's wrong with:

for (let (k, v) in map) ...

?  Just a thought.",
    "header": Object {
      "date": 2007-11-19T18:45:07.000Z,
      "from": Object {
        "email": "ptw@pobox.com",
        "name": "P T Withington",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Exception%20handling%20vs.%20hasNext%28%29&In-Reply-To=15B9E135-D494-4E6B-A30F-D05458210D01%40mozilla.org",
      "subject": "Exception handling vs. hasNext()",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005085.html",
  },
  Object {
    "body": "On Nov 19, 2007, at 6:45 PM, P T Withington wrote:

> On 2007-11-19, at 12:40 EST, Brendan Eich wrote:
>
>> This item iteration case has no more concise form analogous to for-
>> each-in, because if ES4 were always to map:
>>
>> for (let [k, v] in map) ...
>>
>> to:
>>
>> for (let [k, v] in map.iterator::getItems()) ...
>>
>> it would wrongly preempt destructuring of arbitrary properties from
>> the value returned by the default iterator
>
> Say, if we don't waste parens on union types, what's wrong with:
>
> for (let (k, v) in map) ...

Union types are irrelevant in value expressions anyway, but group  
assignment was rejected in favor of destructuring (based on Opera  
precedent). See

http://wiki.ecmascript.org/doku.php?id=proposals:group_assignment

Consider that the implementation of a \\"group\\" or \\"tuple\\" iterator  
will return [k, v] or [s, v, o]. The array destructuring syntax  
mimicks array initialiser syntax. Same goes for object destructuring,  
with a convenient shorthand:

   let {p: a, q: b} = o   // bind a = o.p and b = o.q

When you want the bound names to be the same as the destructured  
property names, use the shorthand:

   let {p, q} = o

Since we're not adding tuples as a distinct type expressed using  
parentheses, the let [k, v] form remains.

/be",
    "header": Object {
      "date": 2007-11-19T19:22:28.000Z,
      "from": Object {
        "email": "brendan@mozilla.org",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Exception%20handling%20vs.%20hasNext%28%29&In-Reply-To=11952559-3B90-4A76-8477-7AC953225827%40pobox.com",
      "subject": "Exception handling vs. hasNext()",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005087.html",
  },
  Object {
    "body": "An HTML attachment was scrubbed...
URL: http://mail.mozilla.org/pipermail/es-discuss/attachments/20071121/aa08bd67/attachment-0002.html",
    "header": Object {
      "date": 2007-11-21T00:05:54.000Z,
      "from": Object {
        "email": "apdsb1@gmail.com",
        "name": "APD",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=TENDERING%2C%0A%09COST%20ESTIMATING%20AND%20CONTRACTS%20ADMINISTRATION%20WORKSHOP%20-%2013%20%26%2014%20Dec%0A%092007/Building%20%26%20Construction%20Seminar%20Series%20-www&In-Reply-To=",
      "subject": "TENDERING,	COST ESTIMATING AND CONTRACTS ADMINISTRATION WORKSHOP - 13 & 14 Dec	2007/Building & Construction Seminar Series -www",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005088.html",
  },
  Object {
    "body": "Enjoy lifelike sensations with a specially designed to feel like a real pussy hand held masturbator. The Personal Pussy can be fucked any day and any time. Made of best modern materials it is reported by some men to be better than the real pussy.
   It so hard to find a virgin nowadays. With the Personal Puss! your dreams come true! Ordering your Personal Puss! you'll receive a virgin pussy and experience new sensations of breaking the hymen.

http://greysay.com

 It gets the job done!",
    "header": Object {
      "date": 2007-11-22T14:49:18.000Z,
      "from": Object {
        "email": "teeqal@web.de",
        "name": "Sybil Mohr",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=%2A%2A%2ASPAM%2A%2A%2A%20Experience%20masturbation%20like%20never%20before.&In-Reply-To=",
      "subject": "***SPAM*** Experience masturbation like never before.",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005089.html",
  },
  Object {
    "body": "{PharmaCanadaAll-1}
 {PharmaCanadaAll-1}

 {PharmaCanadaAll-2}

http://ladyjust.cn

 Health is the most precious thing you have.

Jystein Chartrand",
    "header": Object {
      "date": 2007-11-23T02:15:33.000Z,
      "from": Object {
        "email": "dwslorenzom@slorenzo.com",
        "name": "Jystein Chartrand",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=%2A%2A%2ASPAM%2A%2A%2A%20Thanks%20for%20being%20with%20CanadianPharmacy.&In-Reply-To=",
      "subject": "***SPAM*** Thanks for being with CanadianPharmacy.",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005090.html",
  },
  Object {
    "body": "Is there any way to express an \\"intersection\\" type, analogous to a
union type? I can see there may be fewer use cases that there are for
union types, but they could be useful in the following cases:

1. An argument must implement two interfaces, but it's not practical
to introduce a 3rd interface to unify them as a single type.
2. An argument must be some subtype of a given type, but also
implement one or more additional interfaces.

A trivial example (using dubious syntax):

function replicateObject(obj:(DisplayObject & IClonable)):void
{
   var copy:DisplayObject = obj.clone();
   parent.addChild(copy);
}


I know that proposals are closed now, but this seems simpler than -
and complimentary to - union types.

Peter",
    "header": Object {
      "date": 2007-11-24T14:37:47.000Z,
      "from": Object {
        "email": "peter.hall@memorphic.com",
        "name": "Peter Hall",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Type%20combinations&In-Reply-To=",
      "subject": "Type combinations",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005091.html",
  },
  Object {
    "body": "On Nov 24, 2007 3:37 PM, Peter Hall <peter.hall at memorphic.com> wrote:
> Is there any way to express an \\"intersection\\" type, analogous to a
> union type?

None at present.  I toyed with similar things for a while, being able
to subtract types from unions and so on.

> I can see there may be fewer use cases that there are for
> union types, but they could be useful in the following cases:
>
> 1. An argument must implement two interfaces, but it's not practical
> to introduce a 3rd interface to unify them as a single type.
> 2. An argument must be some subtype of a given type, but also
> implement one or more additional interfaces.
>
> A trivial example (using dubious syntax):
>
> function replicateObject(obj:(DisplayObject & IClonable)):void
> {
>    var copy:DisplayObject = obj.clone();
>    parent.addChild(copy);
> }
>
>
> I know that proposals are closed now, but this seems simpler than -
> and complimentary to - union types.

I think TG1 should look into various kinds of type constraints for the
next iteration of the spec -- this would be interesting for the
parameterized types, also.  For now, proposals really need to be
closed if we're going to finish the spec within a reasonable time.  I
will write up this as a ticket in Trac and then immediately resolve it
as \\"Deferred\\"; the intent is that we will produce a document with
deferred ideas by and by.  There are lots of them.

--lars",
    "header": Object {
      "date": 2007-11-24T19:35:39.000Z,
      "from": Object {
        "email": "lth@acm.org",
        "name": "Lars T Hansen",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Type%20combinations&In-Reply-To=9ac110a90711240637l46a60c07r64d6c897e4d45ff%40mail.gmail.com",
      "subject": "Type combinations",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005092.html",
  },
  Object {
    "body": "> I think TG1 should look into various kinds of type constraints for the
> next iteration of the spec -- this would be interesting for the
> parameterized types, also.  For now, proposals really need to be
> closed if we're going to finish the spec within a reasonable time.  I
> will write up this as a ticket in Trac and then immediately resolve it
> as \\"Deferred\\"; the intent is that we will produce a document with
> deferred ideas by and by.  There are lots of them.
>
> --lars
>

Thanks.

I think the important thing is that the syntax for union types is
designed with more complex set operations in mind. Otherwise we could
end up with some really ugly syntax if they get added in a later
revision.

Peter",
    "header": Object {
      "date": 2007-11-24T20:04:08.000Z,
      "from": Object {
        "email": "peter.hall@memorphic.com",
        "name": "Peter Hall",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Type%20combinations&In-Reply-To=12c6978a0711241135xe0afb8epb4b767490c15d43f%40mail.gmail.com",
      "subject": "Type combinations",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005093.html",
  },
  Object {
    "body": "Buy Must Have medications at Canada based pharmacy.
No prescription at all! Same quality! 
Save your money, buy pills immediately! 

http://vbajgi.runingedsiz.info/?90257679

We provide confidential and secure purchase!",
    "header": Object {
      "date": 2007-11-25T13:43:15.000Z,
      "from": Object {
        "email": "dwsdabocconim@sdabocconi.it",
        "name": "Kevin Byrne",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=%2A%2A%2ASPAM%2A%2A%2A%20Medications%20that%20you%20need.&In-Reply-To=",
      "subject": "***SPAM*** Medications that you need.",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005094.html",
  },
  Object {
    "body": "-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://mail.mozilla.org/pipermail/es-discuss/attachments/20071126/1a14209e/attachment-0002.html",
    "header": Object {
      "date": 2007-11-26T08:37:41.000Z,
      "from": Object {
        "email": "bulten@netmarkpatent.com",
        "name": "NETMARK PATENT",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=%3D%3Fwindows-1254%3FQ%3FIENA_2007%27DE_T%3DDCRK_BULU%3DDELARI_%3DD6D%3DDCL_ALDI%21%3F%3D&In-Reply-To=",
      "subject": "IENA 2007'DE TÜRK BULUŞLARI ÖDÜL ALDI!",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005095.html",
  },
  Object {
    "body": "liorean wrote:
> 
>> I think I can sum up the change I think is appropriate by these things:
>> - undefined should be a failure to match instead of a match to the empty
>> string
>> - captures should only be set to undefined in two cases - when the
>>   regex matching is started, and if inside a negative lookahead
> 

I am in complete agreement with liorean. The ES3 handling on these points is
non-intuitive, non-compatible with other regex libraries, *far* less useful
than the alternative (I could give countless examples of where the
Perl-style handling has real-world practicality), and creates future
compatibility issues if ECMAScript were to implement certain features from
Perl or other Perl-derivative flavors such as capturing-group-based
conditionals.



Lars T Hansen wrote:
> 
>> I hope I'm not being overly flip when I say that it is the spec that
>> circumscribes the set of expectations you are allowed to have.  And
>> the spec is entirely clear here, ie what it says is not in question,
>> even if it's not always easy to find out what it says.  A somewhat
>> determined developer who needs to rely on the behavior can discover
>> what behavior is expected (though he obviously can't trust the
>> implementations to get it right).
> 

I consider ES3's handling of capturing group participation and so forth
(summed up by liorean) to be bugs in the spec (perhaps I'm being overly
flip, but these are my biggest gripes with ES3 regexes). The fact that I
consider them bugs which might be fixed in future versions means that I
cannot rely on the behavior even though I understand what the spec
prescribes.

-- 
View this message in context: http://www.nabble.com/Regex%3A-How-should-backreferences-contained-in-the-capturing-match-they-reference-to-work--tf4367560.html#a13946131
Sent from the Mozilla - ECMAScript 4 discussion mailing list archive at Nabble.com.",
    "header": Object {
      "date": 2007-11-26T09:08:42.000Z,
      "from": Object {
        "email": "steves_list@hotmail.com",
        "name": "StevenLevithan",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Regex%3A%20How%20should%20backreferences%20contained%20in%20the%20capturing%0A%09match%20they%20reference%20to%20work%3F&In-Reply-To=cee13aa30709141239g70fd0c65kc91d7ebb29bf63f2%40mail.gmail.com",
      "subject": "Regex: How should backreferences contained in the capturing	match they reference to work?",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005096.html",
  },
  Object {
    "body": "StevenLevithan wrote:
> 
> 
> liorean wrote:
>> 
>>> I think I can sum up the change I think is appropriate by these things:
>>> - undefined should be a failure to match instead of a match to the empty
>>> string
>>> - captures should only be set to undefined in two cases - when the
>>>   regex matching is started, and if inside a negative lookahead
>> 
> 
> I am in complete agreement with liorean. The ES3 handling on these points
> is non-intuitive, non-compatible with other regex libraries, *far* less
> useful than the alternative (I could give countless examples of where the
> Perl-style handling has real-world practicality), and creates future
> compatibility issues if ECMAScript were to implement certain features from
> Perl or other Perl-derivative flavors such as capturing-group-based
> conditionals.
> 

To support my last comment with a couple of the \\"countless examples\\", I can
point to my blog:

- If backreferences to non-participating capturing groups resulted in
failure rather than a match of the empty string, it would be possible to
mimic conditionals as shown at 
http://blog.stevenlevithan.com/archives/mimic-conditionals
http://blog.stevenlevithan.com/archives/mimic-conditionals  . That page
presents some generalized patterns, but simpler cases can often be taken
advantage of.

- If captures were only set to undefined when the regex matching starts and
after a negative lookahead which contains captures, it would be possible to
do things like shown at 
http://blog.stevenlevithan.com/archives/multi-attr-capture
http://blog.stevenlevithan.com/archives/multi-attr-capture  .

Those are particular things I've posted about in the past, but I run into
these spec bugs ;-) on a regular basis. I have never run into a case where I
wished for the ES3 handling of these issues.
-- 
View this message in context: http://www.nabble.com/Regex%3A-How-should-backreferences-contained-in-the-capturing-match-they-reference-to-work--tf4367560.html#a13946533
Sent from the Mozilla - ECMAScript 4 discussion mailing list archive at Nabble.com.",
    "header": Object {
      "date": 2007-11-26T09:33:25.000Z,
      "from": Object {
        "email": "steves_list@hotmail.com",
        "name": "StevenLevithan",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Regex%3A%20How%20should%20backreferences%20contained%20in%20the%20capturing%0A%09match%20they%20reference%20to%20work%3F&In-Reply-To=13946131.post%40talk.nabble.com",
      "subject": "Regex: How should backreferences contained in the capturing	match they reference to work?",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005097.html",
  },
  Object {
    "body": "Tried to sum up the issue a little more coherently and well
articulated in a blog post:
<uri:http://web-graphics.com/2007/11/26/ecmascript-3-regular-expressions-a-specification-that-doesnt-make-sense/>

Doesn't really say anything I haven't said somewhere in this thread
already, though.
-- 
David \\"liorean\\" Andersson",
    "header": Object {
      "date": 2007-11-26T15:15:49.000Z,
      "from": Object {
        "email": "liorean@gmail.com",
        "name": "liorean",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Regex%3A%20How%20should%20backreferences%20contained%20in%20the%20capturing%20match%0A%09they%20reference%20to%20work%3F&In-Reply-To=13946533.post%40talk.nabble.com",
      "subject": "Regex: How should backreferences contained in the capturing match	they reference to work?",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005098.html",
  },
  Object {
    "body": "An HTML attachment was scrubbed...
URL: http://mail.mozilla.org/pipermail/es-discuss/attachments/20071127/437590f7/attachment-0002.html",
    "header": Object {
      "date": 2007-11-26T19:24:27.000Z,
      "from": Object {
        "email": "xigjpked@brandsters.com",
        "name": "Lilia Sams",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=%2A%2A%2ASPAM%2A%2A%2A%20Time%20control&In-Reply-To=",
      "subject": "***SPAM*** Time control",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005099.html",
  },
  Object {
    "body": "On Nov 12, 2007, at 2:30 PM, Brendan Eich wrote:

> On Nov 12, 2007, at 1:43 PM, YR Chen wrote:
>
>> Out of curiosity, what other JS operations fail silently?
>
> Nothing as badly silent as assigning to a ReadOnly property, but  
> here I'll bitch about a similar change during ES1 standardization:  
> delete x => false if x is in the scope chain but bound with the  
> DontDelete attribute -- otherwise delete x => true, either if it  
> was found without DontDelete and therefore deleted -- or just not  
> found! So delete asdfewr => true. Same for any more qualified  
> reference, e.g. delete foo.bar when you mean foo.baz. Oh, and if  
> bar was found in a prototype object of foo, delete foo.bar => true  
> without doing anything!
>
> This all seems wrong, and IIRC in Netscape 2, JS1, the original  
> buggy progenitor language, delete would report an uncatchable error  
> on bad inputs. Just as assigning to ReadOnly would. Someone with an  
> old PC and Netscape 2 or 3, please confirm.

My memory failed me -- I was thinking of ReadOnly errors, which were  
indeed uncatchable errors in Netscape 2 and 3. There was no delete  
operator until Netscape 4, as far as I can tell now (but I can't rely  
on memory, which must mean something -- too much time has passed, or  
perhaps too much trauma from the pre-historic JS days ;-)).

/be",
    "header": Object {
      "date": 2007-11-27T05:20:43.000Z,
      "from": Object {
        "email": "brendan@mozilla.com",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Assigning%20to%20ReadOnly%20properties&In-Reply-To=36E270B9-E0C0-4CCA-9D32-C5B61EB3082C%40mozilla.org",
      "subject": "Assigning to ReadOnly properties",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005100.html",
  },
  Object {
    "body": "liorean wrote:
> 
> Tried to sum up the issue a little more coherently and well
> articulated in a blog post:
> <uri:http://web-graphics.com/2007/11/26/ecmascript-3-regular-expressions-a-specification-that-doesnt-make-sense/>
> 

And I've posted a follow-up 
http://blog.stevenlevithan.com/archives/es3-regexes-broken here  (which in
truth is more of a long rant).

BTW, here's another variation on the use of Perl-style group participation
handling that I posted on a regex forum yesterday: 
http://regexadvice.com/forums/permalink/25764/36926/ShowThread.aspx#36926
Reg Expression for matching [multiple required attributes]  (that regex also
uses an atomic group, but that's not imperative in this case and can be
emulated even in ES3 by using capturing groups in lookahead, if necessary).
The Perl-style handling is intuitive and ripe for creative exploitation. The
ES3-style handling is essentially useless. But I'll stop beating this horse
now...
-- 
View this message in context: http://www.nabble.com/Regex%3A-How-should-backreferences-contained-in-the-capturing-match-they-reference-to-work--tf4367560.html#a13964984
Sent from the Mozilla - ECMAScript 4 discussion mailing list archive at Nabble.com.",
    "header": Object {
      "date": 2007-11-27T19:55:40.000Z,
      "from": Object {
        "email": "steves_list@hotmail.com",
        "name": "StevenLevithan",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Regex%3A%20How%20should%20backreferences%20contained%20in%20the%20capturing%0A%09match%20they%20reference%20to%20work%3F&In-Reply-To=cee13aa30711260715j2a2d71dcqef06d625414fb417%40mail.gmail.com",
      "subject": "Regex: How should backreferences contained in the capturing	match they reference to work?",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005101.html",
  },
  Object {
    "body": "StevenLevithan wrote:
> 
> And I've posted a follow-up 
> http://blog.stevenlevithan.com/archives/es3-regexes-broken here  (which in
> truth is more of a long rant).
> 

At the risk of spamming the mailing list, I'll note that I've just toned
down a lot of the previous, undue negativity towards the draft ES4 regex
spec in that post. I'm not really a hateful ingrate. :)
-- 
View this message in context: http://www.nabble.com/Regex%3A-How-should-backreferences-contained-in-the-capturing-match-they-reference-to-work--tf4367560.html#a13984745
Sent from the Mozilla - ECMAScript 4 discussion mailing list archive at Nabble.com.",
    "header": Object {
      "date": 2007-11-28T02:37:29.000Z,
      "from": Object {
        "email": "steves_list@hotmail.com",
        "name": "StevenLevithan",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Regex%3A%20How%20should%20backreferences%20contained%20in%20the%20capturing%0A%09match%20they%20reference%20to%20work%3F&In-Reply-To=13964984.post%40talk.nabble.com",
      "subject": "Regex: How should backreferences contained in the capturing	match they reference to work?",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005102.html",
  },
  Object {
    "body": "The document on compatibility between ES3 and ES4 has been updated
significantly:
http://www.ecmascript.org/es4/spec/incompatibilities-rev1.pdf 

I have written a tutorial called \\"Evolutionary programming and gradual
typing in ECMAScript 4\\":
http://www.ecmascript.org/es4/spec/evolutionary-programming-tutorial.pdf

Both are based on the 23 October \\"Language Overview\\" white paper, with
later adjustments that are currently only recorded in the Trac at
http://bugs.ecmascript.org.  (The Language Overview needs to be revised
to reflect those adjustments.  One of these days...)

--lars",
    "header": Object {
      "date": 2007-11-30T14:25:06.000Z,
      "from": Object {
        "email": "lhansen@adobe.com",
        "name": "Lars Hansen",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=New%20materials%20on%20ES4%20available&In-Reply-To=",
      "subject": "New materials on ES4 available",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-November/005103.html",
  },
  Object {
    "body": "ECMA-262 3rd

== section 15.3.4.2 ==

Function.prototype.toString returns a representation with syntax of
FunctionDeclaration


== section13 ==

FunctionDeclaration:
  function Identifier ( FormalParameterList_opt )  { FunctionBody }

FunctionExpression:
  function Identifier_opt ( FormalParameterList_opt )  { FunctionBody }


== Firefox results ==

alert((function(){}).toString())

// outputs

function () {
}

Note there is no Identifier in this output and an identifier is
required in FunctionDeclaration syntax. Should
Function.prototype.toString be specified to return a representation
with FunctionExpression syntax?

Thanks,
Peter",
    "header": Object {
      "date": 2007-12-01T23:23:28.000Z,
      "from": Object {
        "email": "petermichaux@gmail.com",
        "name": "Peter Michaux",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Function.prototype.toString%20spec&In-Reply-To=",
      "subject": "Function.prototype.toString spec",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005104.html",
  },
  Object {
    "body": "On 02/12/2007, Peter Michaux <petermichaux at gmail.com> wrote:
> ECMA-262 3rd
> == section 15.3.4.2 ==
> Function.prototype.toString returns a representation with syntax of
> FunctionDeclaration
> == section13 ==
> FunctionDeclaration:
>   function Identifier ( FormalParameterList_opt )  { FunctionBody }
> FunctionExpression:
>   function Identifier_opt ( FormalParameterList_opt )  { FunctionBody }
>
> == Firefox results ==
> alert((function(){}).toString())
> // outputs
> function () {
> }

This is one area where there's some browser incompatibility. To
discuss some different syntaces too:

    Saf 3.0.4: Function(); // => \\"function anonymous()\\\\n{\\\\n  ;\\\\n}\\"
    Ie 6 (w/ JScript 5.7): Function(); // => \\"function anonymous() { \\\\n }\\"
    Kestrel: Function(); // => \\"function (){}\\"
    Merlin: Function(); // => \\"function ()\\\\n{\\\\n  }\\"
    Ff2: Function(); //=> \\"function anonymous() {\\\\n}\\"
    Ff3b1: Function(); //=> \\"function anonymous() {\\\\n}\\"

However, if the function has a name \\"anonymus\\", you'd expect that
variable name to refer to the function object, right? It doesn't, it's
a ReferenceError.





Let's do a little more in-detail analysis in browsers:

    function literalise(str){
        return '\\"'+(String(str)
            .replace(/\\\\u005c/g,'\\\\\\\\u005c')
            .replace(/\\\\u000a/g,'\\\\\\\\u000a')
            .replace(/\\\\u000d/g,'\\\\\\\\u000d')
            .replace(/\\\\u0022/g,'\\\\\\\\u0022'))+'\\"';
    }
    var
        div=document.createElement('div');
        str='var
u=\\\\'undefined\\\\';prompt(\\\\'arguments.callee\\\\',literalise(typeof
arguments===u?u:arguments.callee));prompt(\\\\'anonymous\\\\',literalise(typeof
anonymous===u?u:anonymous));prompt(\\\\'onclick\\\\',literalise(typeof
onclick===u?u:onclick));',
        divContents='<button
onclick=\\"'+str.replace(/\\\\u0022/g,'&#x0022;')+'\\">event</button>',
        fn=function(){var
u='undefined';prompt('arguments.callee',literalise(typeof
arguments===u?u:arguments.callee));prompt('anonymous',literalise(typeof
anonymous===u?u:anonymous));prompt('onclick',literalise(typeof
onclick===u?u:onclick));}
    window.literalise=literalise;
    div.innerHTML=divContents;
    document.documentElement.lastChild.appendChild(div);
    Function(str)();
    setTimeout(str,10);
    fn();

Merlin/Linear_B:
    Function(str):
        argument.callee : \\"\\\\u000afunction ()\\\\u000a{\\\\u000a  var u =
\\\\u0022undefined\\\\u0022;\\\\u000a  prompt(\\\\u0022arguments.callee\\\\u0022,
literalise(typeof arguments === u ? u : arguments.callee));\\\\u000a
prompt(\\\\u0022anonymous\\\\u0022, literalise(typeof anonymous === u ? u :
anonymous));\\\\u000a  prompt(\\\\u0022onclick\\\\u0022, literalise(typeof
onclick === u ? u : onclick));\\\\u000a}\\\\u000a\\"
        anonymous       : \\"undefined\\"
        onclick         : \\"undefined\\"
    setTimeout(str,10):
        argument.callee : \\"undefined\\"
        anonymous       : \\"undefined\\"
        onclick         : \\"undefined\\"
    fn:
        argument.callee : \\"\\\\u000afunction ()\\\\u000a{\\\\u000a  var u =
\\\\u0022undefined\\\\u0022;\\\\u000a  prompt(\\\\u0022arguments.callee\\\\u0022,
literalise(typeof arguments === u ? u : arguments.callee));\\\\u000a
prompt(\\\\u0022anonymous\\\\u0022, literalise(typeof anonymous === u ? u :
anonymous));\\\\u000a  prompt(\\\\u0022onclick\\\\u0022, literalise(typeof
onclick === u ? u : onclick));\\\\u000a}\\\\u000a\\"
        anonymous       : \\"undefined\\"
        onclick         : \\"undefined\\"
    onclick:
        argument.callee : \\"\\\\u000afunction (event)\\\\u000a{\\\\u000a  var u
= \\\\u0022undefined\\\\u0022;\\\\u000a  prompt(\\\\u0022arguments.callee\\\\u0022,
literalise(typeof arguments === u ? u : arguments.callee));\\\\u000a
prompt(\\\\u0022anonymous\\\\u0022, literalise(typeof anonymous === u ? u :
anonymous));\\\\u000a}\\\\u000a\\"
        anonymous       : \\"undefined\\"
        onclick         : \\"\\\\u000afunction (event)\\\\u000a{\\\\u000a  var u
= \\\\u0022undefined\\\\u0022;\\\\u000a  prompt(\\\\u0022arguments.callee\\\\u0022,
literalise(typeof arguments === u ? u : arguments.callee));\\\\u000a
prompt(\\\\u0022anonymous\\\\u0022, literalise(typeof anonymous === u ? u :
anonymous));\\\\u000a  prompt(\\\\u0022onclick\\\\u0022, literalise(typeof
onclick === u ? u : onclick));\\\\u000a}\\\\u000a\\"

Kestrel/Futhark:
    Function(str):
        argument.callee : \\"function (){var
u='undefined';prompt('arguments.callee',literalise(typeof
arguments===u?u:arguments.callee));prompt('anonymous',literalise(typeof
anonymous===u?u:anonymous));prompt('onclick',literalise(typeof
onclick===u?u:onclick));}\\"
        anonymous       : \\"undefined\\"
        onclick         : \\"undefined\\"
    setTimeout(str,10):
        argument.callee : \\"undefined\\"
        anonymous       : \\"undefined\\"
        onclick         : \\"undefined\\"
    fn:
        argument.callee : \\"function(){var
u='undefined';prompt('arguments.callee',literalise(typeof
arguments===u?u:arguments.callee));prompt('anonymous',literalise(typeof
anonymous===u?u:anonymous));prompt('onclick',literalise(typeof
onclick===u?u:onclick));}\\"
        anonymous       : \\"undefined\\"
        onclick         : \\"undefined\\"
    onclick:
        argument.callee : \\"var
u='undefined';prompt('arguments.callee',literalise(typeof
arguments===u?u:arguments.callee));prompt('anonymous',literalise(typeof
anonymous===u?u:anonymous));prompt('onclick',literalise(typeof
onclick===u?u:onclick));\\"
        anonymous       : \\"undefined\\"
        onclick         : \\"var
u='undefined';prompt('arguments.callee',literalise(typeof
arguments===u?u:arguments.callee));prompt('anonymous',literalise(typeof
anonymous===u?u:anonymous));prompt('onclick',literalise(typeof
onclick===u?u:onclick));\\"

Ie6/JScript5.7:
    Function(str):
        argument.callee : \\"function anonymous() {\\\\u000avar
u='undefined';prompt('arguments.callee',literalise(typeof
arguments===u?u:arguments.callee));prompt('anonymous',literalise(typeof
anonymous===u?u:anonymous));prompt('onclick',literalise(typeof
onclick===u?u:onclick));\\\\u000a}\\"
        anonymous       : \\"undefined\\"
        onclick         : \\"undefined\\"
    setTimeout(str,10):
        argument.callee : \\"function anonymous()\\\\u000a{\\\\u000avar
u='undefined';prompt('arguments.callee',literalise(typeof
arguments===u?u:arguments.callee));prompt('anonymous',literalise(typeof
anonymous===u?u:anonymous));prompt('onclick',literalise(typeof
onclick===u?u:onclick));\\\\u000a}\\"
        anonymous       : \\"undefined\\"
        onclick         : \\"undefined\\"
    fn:
        argument.callee : \\"function(){var
u='undefined';prompt('arguments.callee',literalise(typeof
arguments===u?u:arguments.callee));prompt('anonymous',literalise(typeof
anonymous===u?u:anonymous));prompt('onclick',literalise(typeof
onclick===u?u:onclick));}\\"
        anonymous       : \\"undefined\\"
        onclick         : \\"undefined\\"
    onclick:
        argument.callee : \\"function anonymous()\\\\u000a{\\\\u000avar
u='undefined';prompt('arguments.callee',literalise(typeof
arguments===u?u:arguments.callee));prompt('anonymous',literalise(typeof
anonymous===u?u:anonymous));prompt('onclick',literalise(typeof
onclick===u?u:onclick));\\\\u000a}\\"
        anonymous       : \\"undefined\\"
        onclick         : \\"function anonymous()\\\\u000a{\\\\u000avar
u='undefined';prompt('arguments.callee',literalise(typeof
arguments===u?u:arguments.callee));prompt('anonymous',literalise(typeof
anonymous===u?u:anonymous));prompt('onclick',literalise(typeof
onclick===u?u:onclick));\\\\u000a}\\"

Saf3.0.4b/JavaScriptCore:
    Function(str):
        argument.callee: \\"function anonymous() \\\\u000a{\\\\u000a  var u =
\\\\u0022undefined\\\\u0022;\\\\u000a  prompt(\\\\u0022arguments.callee\\\\u0022,
literalise(typeof arguments === u ? u : arguments.callee));\\\\u000a
prompt(\\\\u0022anonymous\\\\u0022, literalise(typeof anonymous === u ? u :
anonymous));\\\\u000a  prompt(\\\\u0022onclick\\\\u0022, literalise(typeof
onclick === u ? u : onclick));\\\\u000a}\\"
        anonymous: \\"undefined\\"
        onclick: \\"null\\"
    setTimeout(str,10): (Broken? Had to change the prompt to alert to
display these...)
        argument.callee: \\"undefined\\"
        anonymous: \\"undefined\\"
        onclick: \\"null\\"
    fn:
        argument.callee : \\"function () \\\\u000a{\\\\u000a  var u =
\\\\u0022undefined\\\\u0022;\\\\u000a  prompt(\\\\u0022arguments.callee\\\\u0022,
literalise(typeof arguments === u ? u : arguments.callee));\\\\u000a
prompt(\\\\u0022anonymous\\\\u0022, literalise(typeof anonymous === u ? u :
anonymous));\\\\u000a  prompt(\\\\u0022onclick\\\\u0022, literalise(typeof
onclick === u ? u : onclick));\\\\u000a}\\"
        anonymous       : \\"undefined\\"
        onclick         : \\"null\\"
    onclick:
        argument.callee: \\"function onclick(event) \\\\u000a{\\\\u000a  var u
= \\\\u0022undefined\\\\u0022;\\\\u000a  prompt(\\\\u0022arguments.callee\\\\u0022,
literalise(typeof arguments === u ? u : arguments.callee));\\\\u000a
prompt(\\\\u0022anonymous\\\\u0022, literalise(typeof anonymous === u ? u :
anonymous));\\\\u000a  prompt(\\\\u0022onclick\\\\u0022, literalise(typeof
onclick === u ? u : onclick));\\\\u000a}\\"
        anonymous: \\"undefined\\"
        onclick: \\"function onclick(event) \\\\u000a{\\\\u000a  var u =
\\\\u0022undefined\\\\u0022;\\\\u000a  prompt(\\\\u0022arguments.callee\\\\u0022,
literalise(typeof arguments === u ? u : arguments.callee));\\\\u000a
prompt(\\\\u0022anonymous\\\\u0022, literalise(typeof anonymous === u ? u :
anonymous));\\\\u000a  prompt(\\\\u0022onclick\\\\u0022, literalise(typeof
onclick === u ? u : onclick));\\\\u000a}\\"

Ff3.0b1/SpiderMonkey:
    Function(str):
        argument.callee: \\"function anonymous() {\\\\u000a    var u =
\\\\u0022undefined\\\\u0022;\\\\u000a    prompt(\\\\u0022arguments.callee\\\\u0022,
literalise(typeof arguments === u ? u : arguments.callee));\\\\u000a
prompt(\\\\u0022anonymous\\\\u0022, literalise(typeof anonymous === u ? u :
anonymous));\\\\u000a    prompt(\\\\u0022onclick\\\\u0022, literalise(typeof
onclick === u ? u : onclick));\\\\u000a}\\"
        anonymous: \\"undefined\\"
        onclick: \\"undefined\\"
    setTimeout(str,10):
        argument.callee: \\"undefined\\"
        anonymous: \\"undefined\\"
        onclick: \\"undefined\\"
    fn:
        argument.callee : \\"function () {\\\\u000a    var u =
\\\\u0022undefined\\\\u0022;\\\\u000a    prompt(\\\\u0022arguments.callee\\\\u0022,
literalise(typeof arguments === u ? u : arguments.callee));\\\\u000a
prompt(\\\\u0022anonymous\\\\u0022, literalise(typeof anonymous === u ? u :
anonymous));\\\\u000a    prompt(\\\\u0022onclick\\\\u0022, literalise(typeof
onclick === u ? u : onclick));\\\\u000a}\\"
        anonymous       : \\"undefined\\"
        onclick         : \\"undefined\\"
    onclick:
        argument.callee: \\"function onclick(event) {\\\\u000a    var u =
\\\\u0022undefined\\\\u0022;\\\\u000a    prompt(\\\\u0022arguments.callee\\\\u0022,
literalise(typeof arguments === u ? u : arguments.callee));\\\\u000a
prompt(\\\\u0022anonymous\\\\u0022, literalise(typeof anonymous === u ? u :
anonymous));\\\\u000a    prompt(\\\\u0022onclick\\\\u0022, literalise(typeof
onclick === u ? u : onclick));\\\\u000a}\\"
        anonymous: \\"undefined\\"
        onclick: \\"function onclick(event) {\\\\u000a    var u =
\\\\u0022undefined\\\\u0022;\\\\u000a    prompt(\\\\u0022arguments.callee\\\\u0022,
literalise(typeof arguments === u ? u : arguments.callee));\\\\u000a
prompt(\\\\u0022anonymous\\\\u0022, literalise(typeof anonymous === u ? u :
anonymous));\\\\u000a    prompt(\\\\u0022onclick\\\\u0022, literalise(typeof
onclick === u ? u : onclick));\\\\u000a}\\"

Ff2.0.0.11/SpiderMonkey:
    Function(str):
        argument.callee: \\"function anonymous() {\\\\u000a    var u =
\\\\u0022undefined\\\\u0022;\\\\u000a    prompt(\\\\u0022arguments.callee\\\\u0022,
literalise(typeof arguments === u ? u : arguments.callee));\\\\u000a
prompt(\\\\u0022anonymous\\\\u0022, literalise(typeof anonymous === u ? u :
anonymous));\\\\u000a    prompt(\\\\u0022onclick\\\\u0022, literalise(typeof
onclick === u ? u : onclick));\\\\u000a}\\"
        anonymous: \\"undefined\\"
        onclick: \\"undefined\\"
    setTimeout(str,10):
        argument.callee: \\"undefined\\"
        anonymous: \\"undefined\\"
        onclick: \\"undefined\\"
    fn:
        argument.callee : \\"function () {\\\\u000a    var u =
\\\\u0022undefined\\\\u0022;\\\\u000a    prompt(\\\\u0022arguments.callee\\\\u0022,
literalise(typeof arguments === u ? u : arguments.callee));\\\\u000a
prompt(\\\\u0022anonymous\\\\u0022, literalise(typeof anonymous === u ? u :
anonymous));\\\\u000a    prompt(\\\\u0022onclick\\\\u0022, literalise(typeof
onclick === u ? u : onclick));\\\\u000a}\\"
        anonymous       : \\"undefined\\"
        onclick         : \\"undefined\\"
    onclick:
        argument.callee: \\"function onclick(event) {\\\\u000a    var u =
\\\\u0022undefined\\\\u0022;\\\\u000a    prompt(\\\\u0022arguments.callee\\\\u0022,
literalise(typeof arguments === u ? u : arguments.callee));\\\\u000a
prompt(\\\\u0022anonymous\\\\u0022, literalise(typeof anonymous === u ? u :
anonymous));\\\\u000a    prompt(\\\\u0022onclick\\\\u0022, literalise(typeof
onclick === u ? u : onclick));\\\\u000a}\\"
        anonymous: \\"undefined\\"
        onclick: \\"function onclick(event) {\\\\u000a    var u =
\\\\u0022undefined\\\\u0022;\\\\u000a    prompt(\\\\u0022arguments.callee\\\\u0022,
literalise(typeof arguments === u ? u : arguments.callee));\\\\u000a
prompt(\\\\u0022anonymous\\\\u0022, literalise(typeof anonymous === u ? u :
anonymous));\\\\u000a    prompt(\\\\u0022onclick\\\\u0022, literalise(typeof
onclick === u ? u : onclick));\\\\u000a}\\"

> Note there is no Identifier in this output and an identifier is
> required in FunctionDeclaration syntax. Should
> Function.prototype.toString be specified to return a representation
> with FunctionExpression syntax?

IMO, if the serialisation includes a name, that name should be usable
as a variable reference within it. So the serialisation should never
include a name if it's not there.

However, this simple rule falls apart for several reasons, most
important that function declarations are bound in the outside scope
only, and not on the inside scope at all. This means a dissociated
function object from a function declaration will no longer be able to
use the original name as a reference to itself.
-- 
David \\"liorean\\" Andersson",
    "header": Object {
      "date": 2007-12-02T05:44:35.000Z,
      "from": Object {
        "email": "liorean@gmail.com",
        "name": "liorean",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Function.prototype.toString%20spec&In-Reply-To=3cbaf1c80712011523v707c5925j85cdfb994668823d%40mail.gmail.com",
      "subject": "Function.prototype.toString spec",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005105.html",
  },
  Object {
    "body": "Aware of it.  This has been resolved in favor of making the spec say
(effectively) \\"FunctionDeclaration or FunctionExpression\\".

--lars

On 12/2/07, Peter Michaux <petermichaux at gmail.com> wrote:
> ECMA-262 3rd
>
> == section 15.3.4.2 ==
>
> Function.prototype.toString returns a representation with syntax of
> FunctionDeclaration
>
>
> == section13 ==
>
> FunctionDeclaration:
>   function Identifier ( FormalParameterList_opt )  { FunctionBody }
>
> FunctionExpression:
>   function Identifier_opt ( FormalParameterList_opt )  { FunctionBody }
>
>
> == Firefox results ==
>
> alert((function(){}).toString())
>
> // outputs
>
> function () {
> }
>
> Note there is no Identifier in this output and an identifier is
> required in FunctionDeclaration syntax. Should
> Function.prototype.toString be specified to return a representation
> with FunctionExpression syntax?
>
> Thanks,
> Peter
> _______________________________________________
> Es4-discuss mailing list
> Es4-discuss at mozilla.org
> https://mail.mozilla.org/listinfo/es4-discuss
>",
    "header": Object {
      "date": 2007-12-02T08:46:13.000Z,
      "from": Object {
        "email": "lth@acm.org",
        "name": "Lars T Hansen",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Function.prototype.toString%20spec&In-Reply-To=3cbaf1c80712011523v707c5925j85cdfb994668823d%40mail.gmail.com",
      "subject": "Function.prototype.toString spec",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005106.html",
  },
  Object {
    "body": "Hello!

Just looking at the this-propagation stuff, and what struck me
immediately is that the absolutely most desired use case to cover is
not at all covered. That use case would look something like this:

    function moveLeft(){
        /*...*/
    }
    elm.onevent=function(){
        setTimeout(moveLeft, delay);
    }

Where moveLeft wants to access this.style to change the position of the element.

Another similar use case that is not covered is sending this-bound
methods as callbacks.

Frankly, I think these two use cases dwarf the use cases for
this-propagation with named function calls where the function name has
to be a local of a shared scope. When people have questions related to
scope handling and the this-value, in my experience ALL such problems
stem from uses of eval, uses of Function/setTimeout/setInterval, uses
of with or the various ways of doing event handlers. I've yet to see
anybody posting a problem they have in this area which is actually
solved by the very limited this-propagation ES4 adds, and I've been an
active member in many JavaScript mailing lists and forums since before
ES3 became a standard.



In my opinion, this proposal should be extended in such a way that you
can actually do
    setTimeout(fn, delay);
and have the this-value delegated. Even better if the proposal allowed
    setTimeout(this.fn, delay);
    setTimeout(a.b, delay);
with the this-value set to the original this when the function was
called in the first case, a in the second case.

The naive way of doing that would be to make member lookups return a
delegate object remembering the parent instead of a plain function
object. If called as a regular function call, it would use the
delegated parent. If no such parent existed, it would use the current
this-object (not the global object, unless the local this-value is the
global object). I suspect doing that might be a security problem
however, besides potentially breaking live scripts.

Another way might be to introduce a keyword for explicit this-delegation:
    setTimeout(delegate this.fn, delay);
or simply a binding function:
   setTimeout(this.fn.bind(this), delay);
or a more full-fledged delegation mechanism:
    setTimeout(this.fn.delegate(this,args));


ES4's this-propagation at this moment seems to be extremely limited in
use, and specifically tailored to avoid the use cases where
this-propagation is most desired, judging from real-world problems.
-- 
David \\"liorean\\" Andersson",
    "header": Object {
      "date": 2007-12-02T11:07:49.000Z,
      "from": Object {
        "email": "liorean@gmail.com",
        "name": "liorean",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Is%20this-propagation%20as%20written%20useful%3F&In-Reply-To=",
      "subject": "Is this-propagation as written useful?",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005107.html",
  },
  Object {
    "body": "On Dec 2, 2007, at 3:07 AM, liorean wrote:

> I suspect doing that might be a security problem
> however, besides potentially breaking live scripts.

That's right, it's not backward compatible, so it's out. Changing  
runtime semantics for existing syntax under type=application/ 
ecmascript;version=4 just makes migration hazards of the \\"it seems to  
work, but next week we have a fire-drill due to a case that our tests  
didn't cover\\" kind.

> or simply a binding function:
>    setTimeout(this.fn.bind(this), delay);

Function.prototype.bind/Function.bind is proposed:

http://wiki.ecmascript.org/doku.php?id=proposals:static_generics

and it does what's wanted. Apart from extra bells and whistles that  
Ajax libraries add in their bind methods, it's sufficient for the  
case you cite, has the standard form and fit, and could be used as  
the more efficient basis for the elaborated bind methods in the  
popular libraries.

> ES4's this-propagation at this moment seems to be extremely limited in
> use, and specifically tailored to avoid the use cases where
> this-propagation is most desired, judging from real-world problems.

It seems to me your message contradicts itself. You start off asking  
for an incompatible change, eventually advert to the difficulties in  
making it, propose alternative syntax or methods, and finish by  
denigrating the use cases for the |this| propagation proposal. Doing  
so does not help make the case for an incompatible change, and only  
hurts those other use-cases for no clear reason.

First among the use-cases addressed by the |this| proposal is the  
nested helper functions case, which is used in the reference  
implementation IIRC. This is worth fixing.

/be",
    "header": Object {
      "date": 2007-12-02T19:16:27.000Z,
      "from": Object {
        "email": "brendan@mozilla.com",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Is%20this-propagation%20as%20written%20useful%3F&In-Reply-To=cee13aa30712020307j67ceca59sdd27a04f755ab7e4%40mail.gmail.com",
      "subject": "Is this-propagation as written useful?",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005108.html",
  },
  Object {
    "body": "I guess it's one of these things we may try and static-analyze-away.

Cheers,
 David

P.S.:
 Should I mention OCaml's option types or Haskell's maybes at this
point ?

On Thu, 2007-11-15 at 14:06 -0800, Graydon Hoare wrote:
> P T Withington wrote:
> 
> > I must say, coming from Dylan, es3's undefined _and_ null seem like  
> > overkill... but we're stuck with them now!
> 
> I think they feel like overkill to everyone, but yeah. Backward 
> compatibility!
> 
> -Graydon",
    "header": Object {
      "date": 2007-12-05T06:57:25.000Z,
      "from": Object {
        "email": "David.Teller@univ-orleans.fr",
        "name": "David Teller",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Dylan%20%27nullable%27%20types%20%5BWas%3A%20Close%20review%20of%20Language%20Overview%0A%09whitepaper%5D&In-Reply-To=473CC2E6.4020901%40mozilla.com",
      "subject": "Dylan 'nullable' types [Was: Close review of Language Overview	whitepaper]",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005109.html",
  },
  Object {
    "body": "David Teller wrote:
> I guess it's one of these things we may try and static-analyze-away.

Yeah. There are representational costs and value-testing costs. Both can 
be optimized away statically or dynamically, in some cases. Depends how 
fancy an implementation you're doing.

> P.S.:
>  Should I mention OCaml's option types or Haskell's maybes at this
> point ?

Speaking as the person who proposed them, the union types in ES4 are 
explicitly intended to capture use-cases made easy in such type systems: 
option types and tree processing.

We followed a slightly circuitous route in developing the feature, mind 
you. Mostly because we already had, and wished to keep, a more-familiar 
form of named data constructor -- classes -- and didn't want to 
duplicate it any more than necessary. Initially I think I proposed to 
follow HaXe's more ML-like lead of recycling the 'enum' form of the C 
family, but this idea lost out during discussion.

At any rate \\"nullability\\" in ES4, which is the analogue of option types 
in the languages you mention, is presented similarly: as a union with null.

(The absence of ML/haskell's obligatory data constructors for each 
disjoint union member rewards us with the happy result of being able to 
use a single null though, rather than a freshly-typed NONE for every 'a 
option type it occupies. But then, we are also not trying to support 
type inference!)

-Graydon",
    "header": Object {
      "date": 2007-12-05T22:27:40.000Z,
      "from": Object {
        "email": "graydon@mozilla.com",
        "name": "Graydon Hoare",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Dylan%20%27nullable%27%20types%20%5BWas%3A%20Close%20review%20of%20Language%20Overview%0A%09whitepaper%5D&In-Reply-To=1196837845.7051.2.camel%40Blefuscu",
      "subject": "Dylan 'nullable' types [Was: Close review of Language Overview	whitepaper]",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005110.html",
  },
  Object {
    "body": "javascript-mode doesn't quite cut it.",
    "header": Object {
      "date": 2007-12-05T22:38:38.000Z,
      "from": Object {
        "email": "ptw@pobox.com",
        "name": "P T Withington",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Anyone%20got%20an%20emacs%20mode%20file%20for%20es4%3F&In-Reply-To=",
      "subject": "Anyone got an emacs mode file for es4?",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005111.html",
  },
  Object {
    "body": "Hi,

Currently ES4 allows to access from eval scripts the names introduced
by the let statements and expressions. It leads to implementation
complexity since the let bindings cannot be implemented as a pure
compilation-time feature and the runtime must be able to expose the
names for eval scripts.

Thus I suggest to consider making let bindings invisible to the eval
scripts. That is, the idea is to exclude any let-induced name from the
scope chain passed to the eval script. For example, given:

let a;
function f(b) {
    var c;
    let d;
    eval(eval_source);
}

the script from eval_source when executed would not see a and d and
would be able to access/modify only b and c.

This not only simplifies implementations, but would also give a
possibility to prevent eval-injections from discovering the internal
state of a closure as long as the closure uses let for its internal
state. Although ES4 mitigates that with restrictions on the indirect
eval, for compatibility implementations may be forced to support it.

Regards, Igor",
    "header": Object {
      "date": 2007-12-05T22:52:45.000Z,
      "from": Object {
        "email": "igor@mir2.org",
        "name": "Igor Bukanov",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Eval-invisible%20let%20bindings&In-Reply-To=",
      "subject": "Eval-invisible let bindings",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005112.html",
  },
  Object {
    "body": "> -----Original Message-----
> From: es4-discuss-bounces at mozilla.org 
> [mailto:es4-discuss-bounces at mozilla.org] On Behalf Of Igor Bukanov
> Sent: 5. desember 2007 23:53
> To: es4-discuss at mozilla.org
> Subject: Eval-invisible let bindings
> 
> Hi,
> 
> Currently ES4 allows to access from eval scripts the names 
> introduced by the let statements and expressions. It leads to 
> implementation complexity since the let bindings cannot be 
> implemented as a pure compilation-time feature and the 
> runtime must be able to expose the names for eval scripts.

Welcome to the wonderful world of \\"eval\\"!

> Thus I suggest to consider making let bindings invisible to 
> the eval scripts. That is, the idea is to exclude any 
> let-induced name from the scope chain passed to the eval 
> script. For example, given:
> 
> let a;
> function f(b) {
>     var c;
>     let d;
>     eval(eval_source);
> }
> 
> the script from eval_source when executed would not see a and 
> d and would be able to access/modify only b and c.

My opinion is that this would make things unnecessarily confusing.
Unless I'm mistaken we already have a couple of cases where names are
resolved at compile-time without taking into account shadowing bindings
introduced by \\"with\\" or \\"eval\\".  (The issue needs to be clarified
further.)  Adding more of those would not be good.

> This not only simplifies implementations, but would also give 
> a possibility to prevent eval-injections from discovering the 
> internal state of a closure as long as the closure uses let 
> for its internal state. Although ES4 mitigates that with 
> restrictions on the indirect eval, for compatibility 
> implementations may be forced to support it.

It simplifies some kinds of implementations.  Other implementations may
not be particularly affected by this problem.  My opinion is that people
who use the eval operator deserve what they get, and that the compiler
should feel free to generate slow code in any scope affected by a use of
the eval operator.  Such an implementation only needs to detect direct
uses of eval, as specified in ES3 and elaborated in ES4.   (ES4
specifies the meaning of strictly more uses of eval than ES3, and
requries that EvalError is thrown in other cases.)

--lars",
    "header": Object {
      "date": 2007-12-06T10:41:30.000Z,
      "from": Object {
        "email": "lhansen@adobe.com",
        "name": "Lars Hansen",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Eval-invisible%20let%20bindings&In-Reply-To=7dee4710712051452j7c0ee7e2g1903f8c939f316%40mail.gmail.com",
      "subject": "Eval-invisible let bindings",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005113.html",
  },
  Object {
    "body": "I use java-mode for all my ES needs.  It works well unless you're a big
fan of leaving out semicolons, or using a lot of function expressions.

--lars 

> -----Original Message-----
> From: es4-discuss-bounces at mozilla.org 
> [mailto:es4-discuss-bounces at mozilla.org] On Behalf Of P T Withington
> Sent: 5. desember 2007 23:39
> To: ES4 Discuss
> Subject: Anyone got an emacs mode file for es4?
> 
> javascript-mode doesn't quite cut it.
> _______________________________________________
> Es4-discuss mailing list
> Es4-discuss at mozilla.org
> https://mail.mozilla.org/listinfo/es4-discuss
>",
    "header": Object {
      "date": 2007-12-06T10:43:34.000Z,
      "from": Object {
        "email": "lhansen@adobe.com",
        "name": "Lars Hansen",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Anyone%20got%20an%20emacs%20mode%20file%20for%20es4%3F&In-Reply-To=662583F5-76D7-4EB2-A55E-482AA7AD6876%40pobox.com",
      "subject": "Anyone got an emacs mode file for es4?",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005114.html",
  },
  Object {
    "body": "On 06/12/2007, Lars Hansen <lhansen at adobe.com> wrote:
> I use java-mode for all my ES needs.  It works well unless you're a big
> fan of leaving out semicolons, or using a lot of function expressions.

I find it very hard to find a mode that fits my demands even for ES3
(I'm not an emacs user, but I haven't found an editor with a good ES
mode at all), not to speak of ES4. Particularly if you're using a lot
of function expression, object literals or array literals.
In a way, I'd be more comfortable with a Scheme/LISP based mode
(except expressions aren't necessarily contained in parentheses and
there's statements syntax to consider as well) than a Java or C based
mode, but there's not many modes that combines a good handling of
statement-based code with good handling of expression-based code,
especially when the expressions can contain statements such as
function expressions.
-- 
David \\"liorean\\" Andersson",
    "header": Object {
      "date": 2007-12-06T11:06:18.000Z,
      "from": Object {
        "email": "liorean@gmail.com",
        "name": "liorean",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Anyone%20got%20an%20emacs%20mode%20file%20for%20es4%3F&In-Reply-To=1421FCFA117AA044B447467FDE380715E7B414%40eurmail.eur.adobe.com",
      "subject": "Anyone got an emacs mode file for es4?",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005115.html",
  },
  Object {
    "body": "On 06/12/2007, Lars Hansen <lhansen at adobe.com> wrote:
> Such an implementation only needs to detect direct
> uses of eval, as specified in ES3 and elaborated in ES4.   (ES4
> specifies the meaning of strictly more uses of eval than ES3, and
> requries that EvalError is thrown in other cases.)

This is good in theory, but for compatibility reasons the
implementation may be forced to support the indirect eval. For
example, at least recently some Goggle's pages contained var e=eval;
to compress the code. So I do not see how specifying more stricter
cases for ES4 would change the situation in practice. Hence this idea
to make at least new ES4 features immune from eval universality.

Regards, Igor",
    "header": Object {
      "date": 2007-12-06T11:25:42.000Z,
      "from": Object {
        "email": "igor@mir2.org",
        "name": "Igor Bukanov",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Eval-invisible%20let%20bindings&In-Reply-To=1421FCFA117AA044B447467FDE380715E7B415%40eurmail.eur.adobe.com",
      "subject": "Eval-invisible let bindings",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005116.html",
  },
  Object {
    "body": "On Dec 6, 2007 12:25 PM, Igor Bukanov <igor at mir2.org> wrote:
> On 06/12/2007, Lars Hansen <lhansen at adobe.com> wrote:
> > Such an implementation only needs to detect direct
> > uses of eval, as specified in ES3 and elaborated in ES4.   (ES4
> > specifies the meaning of strictly more uses of eval than ES3, and
> > requries that EvalError is thrown in other cases.)
> 
> This is good in theory, but for compatibility reasons the
> implementation may be forced to support the indirect eval. For
> example, at least recently some Goggle's pages contained var e=eval;
> to compress the code.

And that use case is explicitly allowed by ES4, which assigns specific
semantics to it, namely that the eval *function* performs evaluation in
the global scope of its definition, not in the local scope of its call.
Only \\"eval\\" as an operator performs evaluation in the local scope of its
call, and in that case it is always lexically apparent whether a call
may be an invocation of the eval operator.  (Modulo surrounding uses of
\\"with\\" and \\"eval\\", and open namespaces.  In practice, it may be
necessary to perform a lookup to see if the name \\"eval\\" actually
references the initial binding of the eval function.  This should be
straightforward.)

> So I do not see how specifying more stricter
> cases for ES4 would change the situation in practice. Hence this idea
> to make at least new ES4 features immune from eval universality.

The issues, including issues of backward compatibility, have been
discussed extensively in TG1, and even though there may exist some ES3
implementations that allow eval to be used in a way that is not
conformant with the current ES4 proposal, and even though there may be
programs that depend on that behavior, it is not believed to be a
problem in practice.  There are ES3 user agents, like Opera, that
restrict eval in various ways.  Opera employees have been participating
in this discussion and based on their experience with bug reports
resulting from (or rather not resulting from) restrictions in Opera,
appear to believe that the current ES4 spec is sufficient.

(IMO the problem with eval cannot be worked out satisfactorily by making
language features invisible to it, but by restricting its applicability
as much as possible.  Backward compatibility is the real test, to be
sure.  So far, TG1 believes we have that under control.)

--lars",
    "header": Object {
      "date": 2007-12-06T11:53:06.000Z,
      "from": Object {
        "email": "lhansen@adobe.com",
        "name": "Lars Hansen",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Eval-invisible%20let%20bindings&In-Reply-To=7dee4710712060325j4593bb5bhdc2f69b531f1891e%40mail.gmail.com",
      "subject": "Eval-invisible let bindings",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005117.html",
  },
  Object {
    "body": "On 06/12/2007, Lars Hansen <lhansen at adobe.com> wrote:
> Opera employees have been participating
> in this discussion and based on their experience with bug reports
> resulting from (or rather not resulting from) restrictions in Opera,
> appear to believe that the current ES4 spec is sufficient.

That is really good sign that the current ES4 specs are compatible
with the web as seen at least by Opera. I have missed that. It indeed
makes this proposal unnecessary.

Regards, Igor",
    "header": Object {
      "date": 2007-12-06T12:20:16.000Z,
      "from": Object {
        "email": "igor@mir2.org",
        "name": "Igor Bukanov",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Eval-invisible%20let%20bindings&In-Reply-To=1421FCFA117AA044B447467FDE380715E7B488%40eurmail.eur.adobe.com",
      "subject": "Eval-invisible let bindings",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005118.html",
  },
  Object {
    "body": "Don't you have to do scope chain dance for function closures anyways or did I miss something?  How is eval different from function closures?

The notion piques my curiousity though.  We here at Adobe have large AS3 code bases where it is frowned upon to use function closures b/c local variable scope chain reference leaks have caused so much consternation.  Having a way to hide variables from eval and function closures might be useful in that regard.  I'm curious what the language folks think about it.  I guarantee these types of reference leaks will be high on the list of very bad bugs written by Java programmer turned ES4 programmer using function closures w/o realizing that they are doing.  In fact I can already see the Slashdot posting \\"ES4 memory leak crashes University X's autonomous vehicle\\". 

-----Original Message-----
From: es4-discuss-bounces at mozilla.org on behalf of Igor Bukanov
Sent: Wed 12/5/2007 2:52 PM
To: es4-discuss at mozilla.org
Subject: Eval-invisible let bindings
 
Hi,

Currently ES4 allows to access from eval scripts the names introduced
by the let statements and expressions. It leads to implementation
complexity since the let bindings cannot be implemented as a pure
compilation-time feature and the runtime must be able to expose the
names for eval scripts.

Thus I suggest to consider making let bindings invisible to the eval
scripts. That is, the idea is to exclude any let-induced name from the
scope chain passed to the eval script. For example, given:

let a;
function f(b) {
    var c;
    let d;
    eval(eval_source);
}

the script from eval_source when executed would not see a and d and
would be able to access/modify only b and c.

This not only simplifies implementations, but would also give a
possibility to prevent eval-injections from discovering the internal
state of a closure as long as the closure uses let for its internal
state. Although ES4 mitigates that with restrictions on the indirect
eval, for compatibility implementations may be forced to support it.

Regards, Igor
_______________________________________________
Es4-discuss mailing list
Es4-discuss at mozilla.org
https://mail.mozilla.org/listinfo/es4-discuss",
    "header": Object {
      "date": 2007-12-07T00:15:34.000Z,
      "from": Object {
        "email": "treilly@adobe.com",
        "name": "Thomas Reilly",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Eval-invisible%20let%20bindings&In-Reply-To=",
      "subject": "Eval-invisible let bindings",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005119.html",
  },
  Object {
    "body": "> -----Original Message-----
> From: es4-discuss-bounces at mozilla.org 
> [mailto:es4-discuss-bounces at mozilla.org] On Behalf Of Thomas Reilly
> Sent: 7. desember 2007 01:16
> 
> 
> Don't you have to do scope chain dance for function closures 
> anyways or did I miss something?  How is eval different from 
> function closures?

I think Igor's point is that if let bindings are invisible to eval then
you can mostly boil them away at compile time to rib/offset pairs, no
names required.  This does not change with closures, and clever
techniques for compiling \\"with\\" probably also does not require names to
be available.  But eval does.

> The notion piques my curiousity though.  We here at Adobe 
> have large AS3 code bases where it is frowned upon to use 
> function closures b/c local variable scope chain reference 
> leaks have caused so much consternation.  Having a way to 
> hide variables from eval and function closures might be 
> useful in that regard.  I'm curious what the language folks 
> think about it.

If the language does not provide safe-for-space guarantees then the
implementation is not doing anything wrong here, though it may be
considered to be of low quality, of course.  To do better the
implementation might need to use closure representations that
incorporate a display (so that a function only closes over what it might
reference).  That may in turn require heap-allocating individual
captured storage cells in order to avoid capturing entire rib objects,
which in its turn may cause overall slowdowns in code that does use
closures.

On the web there may also be an issue with needing to know the defining
global environment of a function in order to perform a security check;
that will itself prevent global environments from being
garbage-collected while any functions created in that environment are
still live.  (One can probably imagine other mechanisms for that
functionality.)

> I guarantee these types of reference leaks 
> will be high on the list of very bad bugs written by Java 
> programmer turned ES4 programmer using function closures w/o 
> realizing that they are doing.  In fact I can already see the 
> Slashdot posting \\"ES4 memory leak crashes University X's 
> autonomous vehicle\\". 

I doubt ES4 will provide the necessary safe-for-space guarantees to
prevent this (though ES3 programmers are the more likely culprits IMO
:-)

--lars

> -----Original Message-----
> From: es4-discuss-bounces at mozilla.org on behalf of Igor Bukanov
> Sent: Wed 12/5/2007 2:52 PM
> To: es4-discuss at mozilla.org
> Subject: Eval-invisible let bindings
>  
> Hi,
> 
> Currently ES4 allows to access from eval scripts the names 
> introduced by the let statements and expressions. It leads to 
> implementation complexity since the let bindings cannot be 
> implemented as a pure compilation-time feature and the 
> runtime must be able to expose the names for eval scripts.
> 
> Thus I suggest to consider making let bindings invisible to 
> the eval scripts. That is, the idea is to exclude any 
> let-induced name from the scope chain passed to the eval 
> script. For example, given:
> 
> let a;
> function f(b) {
>     var c;
>     let d;
>     eval(eval_source);
> }
> 
> the script from eval_source when executed would not see a and 
> d and would be able to access/modify only b and c.
> 
> This not only simplifies implementations, but would also give 
> a possibility to prevent eval-injections from discovering the 
> internal state of a closure as long as the closure uses let 
> for its internal state. Although ES4 mitigates that with 
> restrictions on the indirect eval, for compatibility 
> implementations may be forced to support it.
> 
> Regards, Igor
> _______________________________________________
> Es4-discuss mailing list
> Es4-discuss at mozilla.org
> https://mail.mozilla.org/listinfo/es4-discuss
> 
> _______________________________________________
> Es4-discuss mailing list
> Es4-discuss at mozilla.org
> https://mail.mozilla.org/listinfo/es4-discuss
>",
    "header": Object {
      "date": 2007-12-07T10:06:27.000Z,
      "from": Object {
        "email": "lhansen@adobe.com",
        "name": "Lars Hansen",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Eval-invisible%20let%20bindings&In-Reply-To=AD0C8E6047016B48A53660CD4888CE39023C6F4C%40namail4.corp.adobe.com",
      "subject": "Eval-invisible let bindings",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005120.html",
  },
  Object {
    "body": "On 2007-12-07, at 05:06 EST, Lars Hansen wrote:

> That may in turn require heap-allocating individual
> captured storage cells in order to avoid capturing entire rib objects,
> which in its turn may cause overall slowdowns in code that does use
> closures.

My experience is that closures are poorly implemented in current es3  
runtimes because they don't do this analysis and instead capture the  
entire environment, making them _much_ more expensive than allocating  
an instance.  My Lisp experience is that the compiler can warn when an  
'indefinite extent' (upward) closure is being created to help the  
programmer avoid those (and the compiler can stack-allocate the  
captured state for 'dynamic extent' (downward) ones).  Some languages  
eschew closures altogether because they are isomorphic to instances,  
but with explicit allocation.  Personally, I find downward closures a  
powerful structuring tool, so I am glad we have them; but upward  
closures can be difficult for even the expert to spot, so I hope  
implementors will give us a hand there.",
    "header": Object {
      "date": 2007-12-07T16:00:25.000Z,
      "from": Object {
        "email": "ptw@pobox.com",
        "name": "P T Withington",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Eval-invisible%20let%20bindings&In-Reply-To=1421FCFA117AA044B447467FDE380715EBFDD3%40eurmail.eur.adobe.com",
      "subject": "Eval-invisible let bindings",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005121.html",
  },
  Object {
    "body": "On Dec 7, 2007 11:00 AM, P T Withington <ptw at pobox.com> wrote:
> My Lisp experience is that the compiler can warn when an
> 'indefinite extent' (upward) closure is being created to help the
> programmer avoid those (and the compiler can stack-allocate the
> captured state for 'dynamic extent' (downward) ones).  Some languages
> eschew closures altogether because they are isomorphic to instances,
> but with explicit allocation.  Personally, I find downward closures a
> powerful structuring tool, so I am glad we have them; but upward
> closures can be difficult for even the expert to spot, so I hope
> implementors will give us a hand there.

Upward closures, if I understand the terminology correctly, are quite
common on the web, such as when passed as an argument to setTimeout or
installed as an event handler.  Doing a better job of handling the
structuring uses of downward closures would indeed be quite righteous,
but I don't think we're going to stamp out upward closures any time
soon.

Mike",
    "header": Object {
      "date": 2007-12-07T16:56:32.000Z,
      "from": Object {
        "email": "mike.shaver@gmail.com",
        "name": "Mike Shaver",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Eval-invisible%20let%20bindings&In-Reply-To=1507D695-AFF4-4E04-9DCD-11254263DC99%40pobox.com",
      "subject": "Eval-invisible let bindings",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005122.html",
  },
  Object {
    "body": "Hi Everyone -

I've started mapping out the progress that's being made on ECMAScript 4 implementations. This has been a multi-stage project, thus far, with the following steps having already been sort-of completed:
1) Mapping out all the features, changes, and bug fixes that are going into the language (nicely categorized, as well).
2) Getting a very rough checklist filled out for each of the implementations.

Note that I've left off static implementations (like ActionScript 3 and JScript 8) in favor of ones that are being actively developed.

You can view it here:
http://spreadsheets.google.com/pub?key=pFIHldY_CkszsFxMkQOReAQ

The next phases of this are:
- Convert this into a more-presentable form (nice, pretty, web page)
- Write up code examples for each individual item (that way they can be easily verified in the implementations and understood by readers)
- Get people to help me fill this out and keep this updated!

The last one is important - and why I'm pinging this list first before heading to the general public. If you have any insight into any of these implementations, or the specification, please drop me an email and I'll gladly give you commit privileges to the spreadsheet).

Feedback is greatly appreciated.

--John",
    "header": Object {
      "date": 2007-12-10T22:47:27.000Z,
      "from": Object {
        "email": "jresig@mozilla.com",
        "name": "John Resig",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=ECMAScript%204%20Implementation%20Progress&In-Reply-To=",
      "subject": "ECMAScript 4 Implementation Progress",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005123.html",
  },
  Object {
    "body": "Hi there,

I was just reading John Resig's recent article titled \\"Re-Securing
JSON\\" [1], and was wondering how this would affect ECMAScript 4. This
led me to the \\"Compatibility Between ES3 and Proposed ES4\\" paper [2],
which makes reference to the rational behind the change (or \\"bug fix\\",
as it's referred to).

It strikes me as somewhat non-obvious that a top-level, self-hosted
class in a meta-programmable language is read only due to security
concerns. What's the side effect of locking down these classes?


Cheers,

--
Nathan de Vries

[1] http://ejohn.org/blog/re-securing-json
[2] http://www.ecmascript.org/es4/spec/incompatibilities.pdf
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/x-pkcs7-signature
Size: 2139 bytes
Desc: not available
Url : http://mail.mozilla.org/pipermail/es-discuss/attachments/20071211/75ea5234/attachment-0002.bin",
    "header": Object {
      "date": 2007-12-11T02:36:05.000Z,
      "from": Object {
        "email": "nathan@atnan.com",
        "name": "Nathan de Vries",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Read-only%20Top-level%20Classes&In-Reply-To=",
      "subject": "Read-only Top-level Classes",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005124.html",
  },
  Object {
    "body": "hey

On 12/10/07, John Resig <jresig at mozilla.com> wrote:
> http://spreadsheets.google.com/pub?key=pFIHldY_CkszsFxMkQOReAQ

nice!

maybe you can also include URLs for each implementation. i can take a
first cut at this if you want ...

-- 
\\\\js  [ http://or8.net/~johns/ ]",
    "header": Object {
      "date": 2007-12-11T14:21:58.000Z,
      "from": Object {
        "email": "js0000@gmail.com",
        "name": "john saylor",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=ECMAScript%204%20Implementation%20Progress&In-Reply-To=24681024.187091197326847833.JavaMail.root%40cm-mail02.mozilla.org",
      "subject": "ECMAScript 4 Implementation Progress",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005125.html",
  },
  Object {
    "body": "On Dec 10, 2007, at 6:36 PM, Nathan de Vries wrote:

> Hi there,
>
> I was just reading John Resig's recent article titled \\"Re-Securing
> JSON\\" [1], and was wondering how this would affect ECMAScript 4. This
> led me to the \\"Compatibility Between ES3 and Proposed ES4\\" paper [2],
> which makes reference to the rationale behind the change (or \\"bug  
> fix\\",
> as it's referred to).

See also

https://bugzilla.mozilla.org/show_bug.cgi?id=376957#c50

et seq.

> It strikes me as somewhat non-obvious that a top-level, self-hosted
> class in a meta-programmable language is read only due to security
> concerns.

Reflection kills theorems for free -- reflection plus mutation can do  
even more damage. TANSTAAFL still applies, however you balance meta- 
programming and integrity. We're trying to make the ES3 spec coherent:

http://wiki.ecmascript.org/doku.php?id=clarification:which_prototype

and beef up the integrity of standard constructors (in ES4 these  
become properties denoting types).

As noted, the security concern is only a desire for defense in depth  
-- a defensive measure. Obviously CSRF wouldn't work on JSON-served  
services if they authenticated carefully. But stuff happens.

> What's the side effect of locking down these classes?

The side effect? Not sure, we're finding out in Firefox 3 beta 2. The  
direct effect is understood in the abstract, but only large-scale  
spidering and testing will tell more about what concrete web JS  
expects and demands. Given the incoherence in ES3 and implementations  
in the field, we think this won't break cross-browser content. More  
when we know more.

/be



-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://mail.mozilla.org/pipermail/es-discuss/attachments/20071211/474ef85a/attachment-0002.html",
    "header": Object {
      "date": 2007-12-11T23:35:15.000Z,
      "from": Object {
        "email": "brendan@mozilla.com",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Read-only%20Top-level%20Classes&In-Reply-To=1197340565.23399.95.camel%40ooboontoo",
      "subject": "Read-only Top-level Classes",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005126.html",
  },
  Object {
    "body": "Hi,

I'm struggling with the performance of my web app partly due to the unpredictability of when the browser decides to draw after (or while) I update the page description.

Firefox seems to draw on function boundaries and eg when I access document.body.clientHeight, so if I do something like:
    myDiv.innerHTML = \\"abc\\"
    h = document.body.clientHeight
    myDiv.className = getClassName()

The performance is worse than if I do:

    h = document.body.clientHeight
    myDiv.className = getClassName()



    myDiv.innerHTML = \\"abc\\"

because the former draws twice and the latter only once (obviously this example is grossly simplified)


It doesn't seem very practical or sensible to require the developer to order code in a specific way to avoid these sorts of performance penalties and my prefered solution would be to add \\"I'm about to edit the page description, please suspend drawing
ops\\" and \\"I've finished editing the page description, now you
may draw\\" functionality to the language - which is why I've mailed this group.

Alistair





      ____________________________________________________________________________________
Be a better friend, newshound, and 
know-it-all with Yahoo! Mobile.  Try it now.  http://mobile.yahoo.com/;_ylt=Ahu06i62sR8HDtDypao8Wcj9tAcJ 
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://mail.mozilla.org/pipermail/es-discuss/attachments/20071212/b6866d78/attachment-0002.html",
    "header": Object {
      "date": 2007-12-12T16:06:20.000Z,
      "from": Object {
        "email": "alistair_braidwood@yahoo.co.uk",
        "name": "Alistair Braidwood",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Draw%20control%20and%20page%20description%20updates&In-Reply-To=",
      "subject": "Draw control and page description updates",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005127.html",
  },
  Object {
    "body": "On 12/12/2007, Alistair Braidwood <alistair_braidwood at yahoo.co.uk> wrote:
>  It doesn't seem very practical or sensible to require the developer to
> order code in a specific way to avoid these sorts of performance penalties
> and my prefered solution would be to add \\"I'm about to edit the page
> description, please suspend drawing ops\\" and \\"I've finished editing the page
> description, now you may draw\\" functionality to the language - which is why
> I've mailed this group.

Not saying that it's not a good idea (I'd view it akin to locking for
threads, just less generally useful), but what on earth does that have
to do with ECMAScript? ECMAScript doesn't deal with documents,
browsers, laying them out visually or drawing them. The browser is
just one of numerous possible host environments. The specifications
that deal with the browser host in particular are the DOM ones. The
W3C WebAPI group seems to have control over most of DOM specs (SVG
DOM, HTML DOM and similar aside), that's probably a better place to
ask for this.
-- 
David \\"liorean\\" Andersson",
    "header": Object {
      "date": 2007-12-12T16:26:28.000Z,
      "from": Object {
        "email": "liorean@gmail.com",
        "name": "liorean",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Draw%20control%20and%20page%20description%20updates&In-Reply-To=463641.24676.qm%40web23009.mail.ird.yahoo.com",
      "subject": "Draw control and page description updates",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005128.html",
  },
  Object {
    "body": "Fair enough, sorry to have troubled you.  Steve Souders at Yahoo suggested I asked here, so I did.

Thanks for pointing me in the right direction,
Alistair

----- Original Message ----
From: liorean <liorean at gmail.com>
To: es4-discuss at mozilla.org
Sent: Wednesday, December 12, 2007 4:26:28 PM
Subject: Re: Draw control and page description updates


On 12/12/2007, Alistair Braidwood <alistair_braidwood at yahoo.co.uk>
 wrote:
>  It doesn't seem very practical or sensible to require the developer
 to
> order code in a specific way to avoid these sorts of performance
 penalties
> and my prefered solution would be to add \\"I'm about to edit the page
> description, please suspend drawing ops\\" and \\"I've finished editing
 the page
> description, now you may draw\\" functionality to the language - which
 is why
> I've mailed this group.

Not saying that it's not a good idea (I'd view it akin to locking for
threads, just less generally useful), but what on earth does that have
to do with ECMAScript? ECMAScript doesn't deal with documents,
browsers, laying them out visually or drawing them. The browser is
just one of numerous possible host environments. The specifications
that deal with the browser host in particular are the DOM ones. The
W3C WebAPI group seems to have control over most of DOM specs (SVG
DOM, HTML DOM and similar aside), that's probably a better place to
ask for this.
-- 
David \\"liorean\\" Andersson
_______________________________________________
Es4-discuss mailing list
Es4-discuss at mozilla.org
https://mail.mozilla.org/listinfo/es4-discuss






      ____________________________________________________________________________________
Be a better friend, newshound, and 
know-it-all with Yahoo! Mobile.  Try it now.  http://mobile.yahoo.com/;_ylt=Ahu06i62sR8HDtDypao8Wcj9tAcJ 
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://mail.mozilla.org/pipermail/es-discuss/attachments/20071212/146baadd/attachment-0002.html",
    "header": Object {
      "date": 2007-12-12T16:38:17.000Z,
      "from": Object {
        "email": "alistair_braidwood@yahoo.co.uk",
        "name": "Alistair Braidwood",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Draw%20control%20and%20page%20description%20updates&In-Reply-To=",
      "subject": "Draw control and page description updates",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005129.html",
  },
  Object {
    "body": "I've got a question about how user defined namespaces should resolve 
inside of packages.  This is really an ES4 implementation question and 
not a usage question.

Consider:

package one {
    public namespace blue = \\"http://blue\\"
}

package one {
    use namespace blue
    blue var x :int
}


package two {
    public namespace blue = \\"http://blue\\"
}

package two {
    use default namespace blue
    blue var x : string
}



This fails to compile as the two \\"blue var x\\" declarations have 
different fixture types. So this implies that variable declarations 
inside packages that have namespaces with identical URI => are not 
defined with any package qualification. ie. the namespace is the only 
qualification. This is what I expected, but just
wanted to confirm this.

Also, I noticed in the RI that you can't have namespace (and other) 
declarations outside of a \\"package {\\" block. ie.

namespace blue
package {
}


will fail to compile, but put the namespace declaration inside of 
\\"package {\\" and it works. Surely, these declarations should be allowed 
outside an explict package declaration due to the fact that there is an 
implicit \\"package {\\" around global declarations?

Michael O'Brien",
    "header": Object {
      "date": 2007-12-12T19:13:19.000Z,
      "from": Object {
        "email": "mob@mbedthis.com",
        "name": "Michael O'Brien",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Namespaces&In-Reply-To=24681024.187091197326847833.JavaMail.root%40cm-mail02.mozilla.org",
      "subject": "Namespaces",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005130.html",
  },
  Object {
    "body": "Where can you put a \\"use namespace\\" directive ?

The RI seems to insist that it only be at the top of a package:

See:

package {
    namespace blue
}

package {
    use namespace blue		//	OK here

    var y

    use namespace blue		//	Fails here


    blue var x = 1
    print(x)
}



Could not a \\"use namespace\\" directive be anywhere in a block and then 
apply to that entire block scope. Just like
a variable declaration.  If so, then what happens if multiple use 
namespace directives exist in a single block scope?

Michael",
    "header": Object {
      "date": 2007-12-12T23:41:25.000Z,
      "from": Object {
        "email": "mob@mbedthis.com",
        "name": "Michael O'Brien",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Another%20namespace%20question&In-Reply-To=",
      "subject": "Another namespace question",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005131.html",
  },
  Object {
    "body": "Michael O'Brien wrote:

> Could not a \\"use namespace\\" directive be anywhere in a block and then 
> apply to that entire block scope. Just like
> a variable declaration.  If so, then what happens if multiple use 
> namespace directives exist in a single block scope?

The behavior of the RI in this regard currently reflects an outdated 
consensus the committee held in the past. It has not been modified since 
then due to ongoing discussion of the matter. When consensus 
(re-)emerges, I'll update the RI.

You can track this issue in http://bugs.ecmascript.org/ticket/282

-Graydon",
    "header": Object {
      "date": 2007-12-12T23:50:43.000Z,
      "from": Object {
        "email": "graydon@mozilla.com",
        "name": "Graydon Hoare",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Another%20namespace%20question&In-Reply-To=476071A5.6050307%40mbedthis.com",
      "subject": "Another namespace question",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005132.html",
  },
  Object {
    "body": "On 12/12/07 11:13 AM, Michael O'Brien wrote:

> I've got a question about how user defined namespaces should resolve
> inside of packages.  This is really an ES4 implementation question and
> not a usage question.
> 
> Consider:
> 
> package one {
>     public namespace blue = \\"http://blue\\"
> }
> 
> package one {
>     use namespace blue
>     blue var x :int
> }
> 
> 
> package two {
>     public namespace blue = \\"http://blue\\"
> }
> 
> package two {
>     use default namespace blue
>     blue var x : string
> }
> 
> 
> 
> This fails to compile as the two \\"blue var x\\" declarations have
> different fixture types. So this implies that variable declarations
> inside packages that have namespaces with identical URI => are not
> defined with any package qualification. ie. the namespace is the only
> qualification. This is what I expected, but just
> wanted to confirm this.

That is correct. A namespace attribute in a package body overrides the
default package qualifier. AS3 allowed only public and internal at this
level, but we have agreed that we would allow such use of namespaces inside
of packages and interfaces. #335 just opened to clarify.

> 
> Also, I noticed in the RI that you can't have namespace (and other)
> declarations outside of a \\"package {\\" block. ie.
> 
> namespace blue
> package {
> }
> 
> 
> will fail to compile, but put the namespace declaration inside of
> \\"package {\\" and it works. Surely, these declarations should be allowed
> outside an explict package declaration due to the fact that there is an
> implicit \\"package {\\" around global declarations?

The error probably has to do with the fact that the current grammar requires
packages to be defined at the top of a compilation unit. It is our intention
to change this letting package definitions to be interspersed with other
definitions and statements.

Jd
> 
> Michael O'Brien
> _______________________________________________
> Es4-discuss mailing list
> Es4-discuss at mozilla.org
> https://mail.mozilla.org/listinfo/es4-discuss",
    "header": Object {
      "date": 2007-12-13T05:04:29.000Z,
      "from": Object {
        "email": "jodyer@adobe.com",
        "name": "Jeff Dyer",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Namespaces&In-Reply-To=476032CF.1040101%40mbedthis.com",
      "subject": "Namespaces",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005133.html",
  },
  Object {
    "body": "An HTML attachment was scrubbed...
URL: http://mail.mozilla.org/pipermail/es-discuss/attachments/20071212/b5a40883/attachment-0002.html",
    "header": Object {
      "date": 2007-12-13T05:16:01.000Z,
      "from": Object {
        "email": "mob@mbedthis.com",
        "name": "Michael O'Brien",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Namespaces&In-Reply-To=C385FD5D.105E6%25jodyer%40adobe.com",
      "subject": "Namespaces",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005134.html",
  },
  Object {
    "body": "I understand that the cut off for proposals is long past. But I believe 
this is an important issue that will force non-standard implementations 
.... bad.

Proposal:

Running ECMAScript on embedded devices is more and more common. It is 
being used in mobile phone widget engines, mobile browsers and it a wide 
variety of embedded infrastructure hardware. However many such devices 
do not have floating point and this has forced non-standard language 
extensions to allow other default numeric types. For example: most 
feature phones (> 500M devices) do not have floating point and have very 
modest CPU resources. Furthermore, the proposed ES4 decimal standard is 
currently implemented in software as there is no common hardware support 
for it (yet). Consequently, it is fairly large and slow and will 
certainly put a strain on feature phones!

We should allow the default number type to be an integer or 64 bit 
integer. Many of embedded devices have very good 64bit integer support 
that is quite fast. 64 bit integer support is important if floating 
point or decimal is not available to provide a wider scale of numeric 
values.

To do this, I'd like to propose that:

1. We change the \\"use decimal\\" pragma to \\"use number NUMBER_TYPE\\". This 
would allow for other number types. E.g.

    use number decimal
    use number int

2. We add support for int as the default number

3. We add \\"long\\" and ulong types that are by definition 64 bit. Also 
support \\"use number long\\"


Michael O'Brien",
    "header": Object {
      "date": 2007-12-13T16:07:37.000Z,
      "from": Object {
        "email": "mob@mbedthis.com",
        "name": "Michael O'Brien",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Spec%20proposal&In-Reply-To=",
      "subject": "Spec proposal",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005135.html",
  },
  Object {
    "body": "On Dec 13, 2007 5:07 PM, Michael O'Brien <mob at mbedthis.com> wrote:
> I understand that the cut off for proposals is long past. But I believe
> this is an important issue that will force non-standard implementations
> .... bad.
>
> Proposal:
>
> Running ECMAScript on embedded devices is more and more common. It is
> being used in mobile phone widget engines, mobile browsers and it a wide
> variety of embedded infrastructure hardware. However many such devices
> do not have floating point and this has forced non-standard language
> extensions to allow other default numeric types. For example: most
> feature phones (> 500M devices) do not have floating point and have very
> modest CPU resources. Furthermore, the proposed ES4 decimal standard is
> currently implemented in software as there is no common hardware support
> for it (yet). Consequently, it is fairly large and slow and will
> certainly put a strain on feature phones!
>
> We should allow the default number type to be an integer or 64 bit
> integer. Many of embedded devices have very good 64bit integer support
> that is quite fast. 64 bit integer support is important if floating
> point or decimal is not available to provide a wider scale of numeric
> values.
>
> To do this, I'd like to propose that:
>
> 1. We change the \\"use decimal\\" pragma to \\"use number NUMBER_TYPE\\". This
> would allow for other number types. E.g.
>
>     use number decimal
>     use number int
>
> 2. We add support for int as the default number
>
> 3. We add \\"long\\" and ulong types that are by definition 64 bit. Also
> support \\"use number long\\"

I have a couple of comments.

First, the \\"use decimal\\" pragma has been changed radically from older
proposals and no longer allows the program to select \\"decimal
everywhere\\" semantics.  (What it does allow is a little bit in flux.
At a minimum it allows controlling rounding and precision.)

Second, several good implementations of ES3 fall back on double
arithmetic sparingly in practice by using clever representations; for
example, \\"1\\" is represented as an int, \\"1 + 2\\" uses int arithmetic
only (with an overflow check).  The same trick could be used if the
default were decimal.  An implementation could extend this principle
up to 53 bits of precision, after which it would have to go to
floating point or become very clever.  \\"53 bits ought to be enough for
anyone.\\"  (Making all its values decimal would give the program in
excess of 100 bits of integer precision ;-)

My beef with ECMAScript at this point is that it has no integer divide
operator and no easy way to signal to the implementation that that's
what desired.  In practice, \\"/\\" forces us into floating point.

--lars",
    "header": Object {
      "date": 2007-12-13T20:50:51.000Z,
      "from": Object {
        "email": "lth@acm.org",
        "name": "Lars T Hansen",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Spec%20proposal&In-Reply-To=476158C9.3000508%40mbedthis.com",
      "subject": "Spec proposal",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005136.html",
  },
  Object {
    "body": "On Thu, 2007-12-13 at 08:07 -0800, Michael O'Brien wrote:
> I believe this is an important issue that will force non-standard
> implementations...

On the same topic, it seems that Adobe are planning on introducing the
decimal type into the Flash Player before the ES4 spec. is finalised.
They're asking Flash developers at the moment what their requirements
are for \\"decimal math\\".

Is the spec. at the point where implementers can start preempting it?


Cheers,

--
Nathan de Vries
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/x-pkcs7-signature
Size: 2139 bytes
Desc: not available
Url : http://mail.mozilla.org/pipermail/es-discuss/attachments/20071214/1abdd80d/attachment-0002.bin",
    "header": Object {
      "date": 2007-12-13T23:09:25.000Z,
      "from": Object {
        "email": "nathan@atnan.com",
        "name": "Nathan de Vries",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Spec%20proposal&In-Reply-To=476158C9.3000508%40mbedthis.com",
      "subject": "Spec proposal",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005137.html",
  },
  Object {
    "body": "On Dec 13, 2007, at 3:09 PM, Nathan de Vries wrote:

> On Thu, 2007-12-13 at 08:07 -0800, Michael O'Brien wrote:
>> I believe this is an important issue that will force non-standard
>> implementations...
>
> On the same topic, it seems that Adobe are planning on introducing the
> decimal type into the Flash Player before the ES4 spec. is finalised.
> They're asking Flash developers at the moment what their requirements
> are for \\"decimal math\\".
>
> Is the spec. at the point where implementers can start preempting it?

Not quite, but no one is going to preempt -- the early implementors  
will have to shift if they want to claim conformance to the final  
spec. We've done this in the past in Mozilla and it has been tolerable.

Michael's point seemed to me to be more about divergent long/ulong  
semantics and no spec, not early implementations trumped by the one  
true spec.

/be",
    "header": Object {
      "date": 2007-12-13T23:25:48.000Z,
      "from": Object {
        "email": "brendan@mozilla.com",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Spec%20proposal&In-Reply-To=1197587365.6887.103.camel%40ooboontoo",
      "subject": "Spec proposal",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005138.html",
  },
  Object {
    "body": "An HTML attachment was scrubbed...
URL: http://mail.mozilla.org/pipermail/es-discuss/attachments/20071213/17d5ac3d/attachment-0002.html",
    "header": Object {
      "date": 2007-12-13T23:38:16.000Z,
      "from": Object {
        "email": "mob@mbedthis.com",
        "name": "Michael O'Brien",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Spec%20proposal&In-Reply-To=4C785BBF-918B-429B-AA2F-6E1A18869684%40mozilla.com",
      "subject": "Spec proposal",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005139.html",
  },
  Object {
    "body": "Are global functions declared with block or global scope. ie. declared 
in the block object or var object?

Consider:

package {
    {
        function fun() {
            print(\\"1\\");
        }
        fun()
    }
    {
        function fun() {
            print(\\"2\\")
        }
        fun()
    }
}


This prints

2
2

in the RI.

So should functions be treated like var declarations or as let 
declarations. Seems like they are like vars in the RI.

Is this right?

Michael O'Brien",
    "header": Object {
      "date": 2007-12-14T00:10:41.000Z,
      "from": Object {
        "email": "mob@mbedthis.com",
        "name": "Michael O'Brien",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Global%20functions%20&In-Reply-To=",
      "subject": "Global functions",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005140.html",
  },
  Object {
    "body": "On 14/12/2007, Michael O'Brien <mob at mbedthis.com> wrote:
> So should functions be treated like var declarations or as let
> declarations. Seems like they are like vars in the RI.
>
> Is this right?

I don't see how they could be anything else for ES3 compatibility's
sake. At least, within a single compilation unit.
-- 
David \\"liorean\\" Andersson",
    "header": Object {
      "date": 2007-12-14T01:00:07.000Z,
      "from": Object {
        "email": "liorean@gmail.com",
        "name": "liorean",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Global%20functions&In-Reply-To=4761CA01.6030701%40mbedthis.com",
      "subject": "Global functions",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005141.html",
  },
  Object {
    "body": "I was under the impression that for the function definitions to be confined to a block scope, you had to define them as such (with let function statements), like so:

package {
    {
        let function fun() {
            print(\\"1\\");
        }
        fun()
    }
    {
        let function fun() {
            print(\\"2\\")
        }
        fun()
    }
}

I'm unsure if this currently works in the RI, or not.

--John


----- Original Message -----
From: \\"Michael O'Brien\\" <mob at mbedthis.com>
To: \\"es4-discuss\\" <es4-discuss at mozilla.org>
Sent: Thursday, December 13, 2007 7:10:41 PM (GMT-0500) America/New_York
Subject: Global functions 

Are global functions declared with block or global scope. ie. declared 
in the block object or var object?

Consider:

package {
    {
        function fun() {
            print(\\"1\\");
        }
        fun()
    }
    {
        function fun() {
            print(\\"2\\")
        }
        fun()
    }
}


This prints

2
2

in the RI.

So should functions be treated like var declarations or as let 
declarations. Seems like they are like vars in the RI.

Is this right?

Michael O'Brien

_______________________________________________
Es4-discuss mailing list
Es4-discuss at mozilla.org
https://mail.mozilla.org/listinfo/es4-discuss",
    "header": Object {
      "date": 2007-12-14T01:25:43.000Z,
      "from": Object {
        "email": "jresig@mozilla.com",
        "name": "John Resig",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Global%20functions&In-Reply-To=4761CA01.6030701%40mbedthis.com",
      "subject": "Global functions",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005142.html",
  },
  Object {
    "body": "While this compiles in the RI, it still produces 2 and 2 for the output.

ie. doesn't seem they are block scoped functions either.

Michael

John Resig wrote:
> I was under the impression that for the function definitions to be confined to a block scope, you had to define them as such (with let function statements), like so:
>
> package {
>     {
>         let function fun() {
>             print(\\"1\\");
>         }
>         fun()
>     }
>     {
>         let function fun() {
>             print(\\"2\\")
>         }
>         fun()
>     }
> }
>
> I'm unsure if this currently works in the RI, or not.
>
> --John
>
>
> ----- Original Message -----
> From: \\"Michael O'Brien\\" <mob at mbedthis.com>
> To: \\"es4-discuss\\" <es4-discuss at mozilla.org>
> Sent: Thursday, December 13, 2007 7:10:41 PM (GMT-0500) America/New_York
> Subject: Global functions 
>
> Are global functions declared with block or global scope. ie. declared 
> in the block object or var object?
>
> Consider:
>
> package {
>     {
>         function fun() {
>             print(\\"1\\");
>         }
>         fun()
>     }
>     {
>         function fun() {
>             print(\\"2\\")
>         }
>         fun()
>     }
> }
>
>
> This prints
>
> 2
> 2
>
> in the RI.
>
> So should functions be treated like var declarations or as let 
> declarations. Seems like they are like vars in the RI.
>
> Is this right?
>
> Michael O'Brien
>
> _______________________________________________
> Es4-discuss mailing list
> Es4-discuss at mozilla.org
> https://mail.mozilla.org/listinfo/es4-discuss
>
>
>",
    "header": Object {
      "date": 2007-12-14T03:41:56.000Z,
      "from": Object {
        "email": "mob@mbedthis.com",
        "name": "Michael O'Brien",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Global%20functions&In-Reply-To=2763094.70011197595543308.JavaMail.root%40cm-mail02.mozilla.org",
      "subject": "Global functions",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005143.html",
  },
  Object {
    "body": "An HTML attachment was scrubbed...
URL: http://mail.mozilla.org/pipermail/es-discuss/attachments/20071213/cb7d1e12/attachment-0002.html",
    "header": Object {
      "date": 2007-12-14T04:54:53.000Z,
      "from": Object {
        "email": "mob@mbedthis.com",
        "name": "Michael O'Brien",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Spec%20proposal&In-Reply-To=12c6978a0712131250w4cd78ccau598e48f3fdb29778%40mail.gmail.com",
      "subject": "Spec proposal",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005144.html",
  },
  Object {
    "body": "On Dec 14, 2007 5:54 AM, Michael O'Brien <mob at mbedthis.com> wrote:
>
>  Lars,
>
>  I'm not sure quite what you are saying here.
>
>  Are you saying that ES4 should automatically scale numerics up seamlessly
> from integer to decimal by detecting overflow much as Ruby does?
>  ie. the default number type is not decimal, but rather the numeric type
> will expand as required up to 128 bit decimal numbers. Is this what you are
> saying?

I'm saying that current ES3 implementations do this (int/uint
representations overflow to double as needed in order to use the
integer hardware and avoid using (software) fp) and that ES4
implementations will do the same.

Decimal is really not part of that discussion.

>  If so, then can an implementation be compliant if it:
>
> Has no floating point h/w or s/w

If it has no floating point at all it can't be compliant with ES3.

> Has no decimal ie. could an implementation be compliant if it does not
> support floating point arithmetic and can only scale up to 32 or 64 bit
> integers?
>
>  This is what many embedded devices need. I think the spec should
> accommodate these devices without breaking the spec.

My opinion is that subset implementations will exist in any case --
for example, ActionScript has no \\"eval\\" and no \\"Function\\" constructor
-- and that the spec should not address these needs because the
complexity cost in the spec is too great.  If an implementation wants
to do away with IEEE double numbers and use 64-bit ints instead, and
do all the work with retrofitting libraries and so on and choose
whether to support trig functions or not, then I think it's better if
this cost is borne by the implementor or by a derivative standard, not
by the ES4 spec, which is plenty complicated already.

(Also note that TG1 rejected the previous proposal on \\"use decimal\\"
(meaning \\"pretend all numbers are decimal\\") because we did not think
it could be made to work reliably.  The same argument would go for any
other number type IMO.)

--lars

>
>  Michael
>
>
>
>
>  Lars T Hansen wrote:
>  On Dec 13, 2007 5:07 PM, Michael O'Brien <mob at mbedthis.com> wrote:
>
>
>  I understand that the cut off for proposals is long past. But I believe
> this is an important issue that will force non-standard implementations
> .... bad.
>
> Proposal:
>
> Running ECMAScript on embedded devices is more and more common. It is
> being used in mobile phone widget engines, mobile browsers and it a wide
> variety of embedded infrastructure hardware. However many such devices
> do not have floating point and this has forced non-standard language
> extensions to allow other default numeric types. For example: most
> feature phones (> 500M devices) do not have floating point and have very
> modest CPU resources. Furthermore, the proposed ES4 decimal standard is
> currently implemented in software as there is no common hardware support
> for it (yet). Consequently, it is fairly large and slow and will
> certainly put a strain on feature phones!
>
> We should allow the default number type to be an integer or 64 bit
> integer. Many of embedded devices have very good 64bit integer support
> that is quite fast. 64 bit integer support is important if floating
> point or decimal is not available to provide a wider scale of numeric
> values.
>
> To do this, I'd like to propose that:
>
> 1. We change the \\"use decimal\\" pragma to \\"use number NUMBER_TYPE\\". This
> would allow for other number types. E.g.
>
>  use number decimal
>  use number int
>
> 2. We add support for int as the default number
>
> 3. We add \\"long\\" and ulong types that are by definition 64 bit. Also
> support \\"use number long\\"
>
>  I have a couple of comments.
>
> First, the \\"use decimal\\" pragma has been changed radically from older
> proposals and no longer allows the program to select \\"decimal
> everywhere\\" semantics. (What it does allow is a little bit in flux.
> At a minimum it allows controlling rounding and precision.)
>
> Second, several good implementations of ES3 fall back on double
> arithmetic sparingly in practice by using clever representations; for
> example, \\"1\\" is represented as an int, \\"1 + 2\\" uses int arithmetic
> only (with an overflow check). The same trick could be used if the
> default were decimal. An implementation could extend this principle
> up to 53 bits of precision, after which it would have to go to
> floating point or become very clever. \\"53 bits ought to be enough for
> anyone.\\" (Making all its values decimal would give the program in
> excess of 100 bits of integer precision ;-)
>
> My beef with ECMAScript at this point is that it has no integer divide
> operator and no easy way to signal to the implementation that that's
> what desired. In practice, \\"/\\" forces us into floating point.
>
> --lars
>
>
>",
    "header": Object {
      "date": 2007-12-14T07:37:58.000Z,
      "from": Object {
        "email": "lth@acm.org",
        "name": "Lars T Hansen",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Spec%20proposal&In-Reply-To=47620C9D.4040202%40mbedthis.com",
      "subject": "Spec proposal",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005145.html",
  },
  Object {
    "body": "I believe \\"let function\\" is broken in the RI (it has been in the past).

--lars

On Dec 14, 2007 4:41 AM, Michael O'Brien <mob at mbedthis.com> wrote:
> While this compiles in the RI, it still produces 2 and 2 for the output.
>
> ie. doesn't seem they are block scoped functions either.
>
> Michael
>
>
> John Resig wrote:
> > I was under the impression that for the function definitions to be confined to a block scope, you had to define them as such (with let function statements), like so:
> >
> > package {
> >     {
> >         let function fun() {
> >             print(\\"1\\");
> >         }
> >         fun()
> >     }
> >     {
> >         let function fun() {
> >             print(\\"2\\")
> >         }
> >         fun()
> >     }
> > }
> >
> > I'm unsure if this currently works in the RI, or not.
> >
> > --John
> >
> >
> > ----- Original Message -----
> > From: \\"Michael O'Brien\\" <mob at mbedthis.com>
> > To: \\"es4-discuss\\" <es4-discuss at mozilla.org>
> > Sent: Thursday, December 13, 2007 7:10:41 PM (GMT-0500) America/New_York
> > Subject: Global functions
> >
> > Are global functions declared with block or global scope. ie. declared
> > in the block object or var object?
> >
> > Consider:
> >
> > package {
> >     {
> >         function fun() {
> >             print(\\"1\\");
> >         }
> >         fun()
> >     }
> >     {
> >         function fun() {
> >             print(\\"2\\")
> >         }
> >         fun()
> >     }
> > }
> >
> >
> > This prints
> >
> > 2
> > 2
> >
> > in the RI.
> >
> > So should functions be treated like var declarations or as let
> > declarations. Seems like they are like vars in the RI.
> >
> > Is this right?
> >
> > Michael O'Brien
> >
> > _______________________________________________
> > Es4-discuss mailing list
> > Es4-discuss at mozilla.org
> > https://mail.mozilla.org/listinfo/es4-discuss
> >
> >
> >
> _______________________________________________
> Es4-discuss mailing list
> Es4-discuss at mozilla.org
> https://mail.mozilla.org/listinfo/es4-discuss
>",
    "header": Object {
      "date": 2007-12-14T07:42:54.000Z,
      "from": Object {
        "email": "lth@acm.org",
        "name": "Lars T Hansen",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Global%20functions&In-Reply-To=4761FB84.1070102%40mbedthis.com",
      "subject": "Global functions",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005146.html",
  },
  Object {
    "body": "An HTML attachment was scrubbed...
URL: http://mail.mozilla.org/pipermail/es-discuss/attachments/20071214/9942d65e/attachment-0002.html",
    "header": Object {
      "date": 2007-12-14T08:19:31.000Z,
      "from": Object {
        "email": "mob@mbedthis.com",
        "name": "Michael O'Brien",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Spec%20proposal&In-Reply-To=12c6978a0712132337j524da30bu87800e4c19a57476%40mail.gmail.com",
      "subject": "Spec proposal",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005147.html",
  },
  Object {
    "body": "On 2007-12-13, at 15:50 EST, Lars T Hansen wrote:

> My beef with ECMAScript at this point is that it has no integer divide
> operator and no easy way to signal to the implementation that that's
> what desired.  In practice, \\"/\\" forces us into floating point.

Couldn't this be fixed upward-compatibly by adding an optional second  
argument to floor, ceiling, round, and truncate the way Lisp and  
[Dylan](http://www.opendylan.org/books/drm/Arithmetic_Operations#HEADING-100-124 
) do?

Surely:

   var int x = int(y) / int(z);

also signals that an integer divide is desired (although the desired  
rounding mode is is unclear).",
    "header": Object {
      "date": 2007-12-14T12:20:31.000Z,
      "from": Object {
        "email": "ptw@pobox.com",
        "name": "P T Withington",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Spec%20proposal&In-Reply-To=12c6978a0712131250w4cd78ccau598e48f3fdb29778%40mail.gmail.com",
      "subject": "Spec proposal",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005148.html",
  },
  Object {
    "body": "On Dec 13, 2007, at 11:42 PM, Lars T Hansen wrote:

> I believe \\"let function\\" is broken in the RI (it has been in the  
> past).

I encouraged Michael to file a trac ticket, and he did:

http://bugs.ecmascript.org/ticket/337

Anyone else who finds an RI bug and can't see a report of it in the  
existing tickets, feel free to run it by this list and file if it's  
not known -- or just file and we'll dup it in due course. These  
tickets will be fixed. Anyone who wants to help hack on the RI,  
please contact me. Thanks,

/be

-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://mail.mozilla.org/pipermail/es-discuss/attachments/20071214/10182aae/attachment-0002.html",
    "header": Object {
      "date": 2007-12-14T18:42:59.000Z,
      "from": Object {
        "email": "brendan@mozilla.com",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Global%20functions&In-Reply-To=12c6978a0712132342nb50837bg9cb528474a24c5ab%40mail.gmail.com",
      "subject": "Global functions",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005149.html",
  },
  Object {
    "body": "Also see http://bugs.ecmascript.org/ticket/158.  --lars

On Dec 14, 2007 7:42 PM, Brendan Eich <brendan at mozilla.com> wrote:
>
>
> On Dec 13, 2007, at 11:42 PM, Lars T Hansen wrote:
>
> > I believe \\"let function\\" is broken in the RI (it has been in the past).
>
> I encouraged Michael to file a trac ticket, and he did:
>
>
> http://bugs.ecmascript.org/ticket/337
>
> Anyone else who finds an RI bug and can't see a report of it in the existing
> tickets, feel free to run it by this list and file if it's not known -- or
> just file and we'll dup it in due course. These tickets will be fixed.
> Anyone who wants to help hack on the RI, please contact me. Thanks,
>
> /be
>
> _______________________________________________
> Es4-discuss mailing list
> Es4-discuss at mozilla.org
> https://mail.mozilla.org/listinfo/es4-discuss
>
>",
    "header": Object {
      "date": 2007-12-14T20:00:30.000Z,
      "from": Object {
        "email": "lth@acm.org",
        "name": "Lars T Hansen",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Global%20functions&In-Reply-To=DC877C5A-093F-40F5-9612-DE205845E87C%40mozilla.com",
      "subject": "Global functions",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005150.html",
  },
  Object {
    "body": "On 2007-09-23, at 14:14 EDT, Brendan Eich wrote:

> On Sep 23, 2007, at 8:59 AM, liorean wrote:
>
>>> 1. The constructor property should be on the object instance
>>> *created*
>>> by the function.
>>
>> That argument I agree with. It should be on the instance and not
>> the prototype.
>
> The reason for the original prototype-owned constructor was to afford
> a back-pointer from prototype to constructor function without
> imposing a per-instance property (which could be optimized to be
> shared where possible, overridden where desired -- but at some cost
> in implementation complexity).
>
> I'm not convinced it's worth changing this for ES4. Anyway it is very
> late to have a new proposal -- we are finalizing proposals next week
> at the face-to-face meeting.

So, was nothing done about this?  We're starting to work on an es4  
back-end for our stuff and running into this issue.  We can make sure  
all our constructors give each instance a constructor slot (and we can  
smash the class prototype.constructor to point to the superclass) as  
we do for our es3 back end; but I was really hoping for a cleaner  
solution in es4.

Is there some other way in es4 that from an instance one can navigate  
up the superclass chain?  Can I say:

   super.constructor

perhaps, to find my class's superclass?",
    "header": Object {
      "date": 2007-12-14T20:50:03.000Z,
      "from": Object {
        "email": "ptw@pobox.com",
        "name": "P T Withington",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=13.2.2%20%5B%5BConstruct%5D%5D%2C%20constructor%2C%20and%20%5B%5BClass%5D%5D%20%28was%20__proto__%29&In-Reply-To=50341F82-A163-436F-9F2E-32AAD46B36AD%40mozilla.org",
      "subject": "13.2.2 [[Construct]], constructor, and [[Class]] (was __proto__)",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005151.html",
  },
  Object {
    "body": "On Dec 14, 2007, at 12:50 PM, P T Withington wrote:

> On 2007-09-23, at 14:14 EDT, Brendan Eich wrote:
>
>> The reason for the original prototype-owned constructor was to afford
>> a back-pointer from prototype to constructor function without
>> imposing a per-instance property (which could be optimized to be
>> shared where possible, overridden where desired -- but at some cost
>> in implementation complexity).
>>
>> I'm not convinced it's worth changing this for ES4. Anyway it is very
>> late to have a new proposal -- we are finalizing proposals next week
>> at the face-to-face meeting.
>
> So, was nothing done about this?  We're starting to work on an es4
> back-end for our stuff and running into this issue.  We can make sure
> all our constructors give each instance a constructor slot (and we can
> smash the class prototype.constructor to point to the superclass) as
> we do for our es3 back end; but I was really hoping for a cleaner
> solution in es4.

Nothing's changed, no proposal that avoids per-instance overhead or  
more complicated implementation strategies to avoid that. There's  
also an entrainment hazard, not huge but non-zero risk of introducing  
leaks into existing web apps if we entrain the constructor where the  
web app code intentionally clears prototype.constructor (which is  
read/write).

The constructor property is and always was intended to be a property  
of the prototype, not of each instance. Changing that now is hard.  
The merits are not compelling enough IMHO.

> Is there some other way in es4 that from an instance one can navigate
> up the superclass chain?  Can I say:
>
>    super.constructor
>
> perhaps, to find my class's superclass?

For a class C, C.prototype.constructor is indeed C. But super does  
not work that way -- it's used for invoking the super-class  
constructor, rather:

 >> class B { var x;function B(x) : x=x {} }
 >> new B(2).x
2
 >> class D extends B { var y; function D(x,y) : y=y, super(x) {} }
 >> d = new D(3,4)
[object D]
 >> d.x
3
 >> d.y
4

To reflect on inheritance and other relations, use the meta-objects  
interfaces:

http://wiki.ecmascript.org/doku.php?id=proposals:meta_objects

Given class C:

let Ctype = reflect::typeOf(C);
for (let Csup in Ctype.superTypes()) {
     // Csup is a base class or interface of C here
}

/be
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://mail.mozilla.org/pipermail/es-discuss/attachments/20071214/45254d21/attachment-0002.html",
    "header": Object {
      "date": 2007-12-14T21:08:18.000Z,
      "from": Object {
        "email": "brendan@mozilla.com",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=13.2.2%20%5B%5BConstruct%5D%5D%2C%20constructor%2C%20and%20%5B%5BClass%5D%5D%20%28was%20__proto__%29&In-Reply-To=FE79E218-CEC1-4884-89B3-80F182016317%40pobox.com",
      "subject": "13.2.2 [[Construct]], constructor, and [[Class]] (was __proto__)",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005152.html",
  },
  Object {
    "body": "On Usenet's comp.lang.javascript there has been a discussion about the
internal methods like [[Get]] in the ES3 spec.

I think the ES3 spec is contradictory. Section 8.6.2 starts by
stressing the internal methods are \\"purely for expository purposes\\"
and that an \\"implementation of ECMAScript must behave as if it
produced and operate on internal properties...\\". To me this clearly
implies that the internals of the implementation can be coded any way
the implementor wishes to. Then later, in the same section, the spec
says that \\"Every object (including host objects) must implement
[[Prototype]] and [[Class]] properties and the [[Get]]...methods.\\"
This seems like a contradiction because even though the implementation
must only behave as though it implements [[Get]], the implementation
must also actually have [[Get]]. My interpretation is that the spec
writers intended to write \\"Every object (including host objects) must
behave as though it implements [[Prototype]] and [[Class]] properties
and the [[Get]]...methods.\\" That would be more consistent with the
first part of 8.6.2.

I bring this up on the ES4 list partly to find out if my
interpretation is correct but also to say at least one person is
confused by this and hopefully the writing of the ES4 spec will be a
bit clearer in this respect.

Thanks,
Peter",
    "header": Object {
      "date": 2007-12-17T05:40:49.000Z,
      "from": Object {
        "email": "petermichaux@gmail.com",
        "name": "Peter Michaux",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=specs%20of%20internal%20methods%20like%20%5B%5BGet%5D%5D%20in%20ES3%20and%20ES4&In-Reply-To=",
      "subject": "specs of internal methods like [[Get]] in ES3 and ES4",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005153.html",
  },
  Object {
    "body": "Hi all,

there's a feature in C++ which I like a lot, and I think it would be  
interesting to have in es4, which is operator overloading, like

   class X{ X& operator+(const X& x); }
   X a, b, c; c = a+b;

which allows the programmer to define a sum operation between two objects  
of type X.
The notation I'm using in this e-mail is just for example.
C++ allows to define all operators except :: (scope resolution), .  
(member) and .* (member through pointer)

To keep things clean, new operators cannot be defined (like in C++),so

   class X{ X& operator myop(const X& x); }
   X a, b, c; c = a myop b;

would be invalid.

Operators should only be defined as members of objects, so one cannot  
right a global operator function which picks up two object (alla C++), like
   function operator+:X(x:X,x:X);

Any global operator function like this one before would be added to the  
window, and would be equivalent to do
window['operator+']=function(x:X):X{}
because the 2nd argument would be ignored.

The following operators should be definable:
  - arithmetic: +  -  *  /  %  +=  -=  *=  /=  %=  ++  --
  - bitwise: &  |  ^  >>  <<  >>=  <<=  ~
  - boolean: ||  &&  !  ||=  &&=
  - others: typeof  ()  []

All these operators are binary except for |, ~ and typeof , so the left  
hand (A) object would be the context object, and the right hand object (B)  
would be the argument passed to the operator member in A. For unary  
operators, there won't be arguments, and the function would be called upon  
its target.
operator functions would only be called if the operator is explicitly used  
in the source code.

Now consider an example
   class X{
     function operator+:X(x:X);
     function operator typeof(){ return \\"function\\";};
   }
   var a:X := new X;
   var b:X := new X;

   var c:X = a + b; //sucess, operator is defined

   a += b; //error, no += operator defined

   var c:X = a + 1; //type-error, rhs must be of type X

   var tp:String = typeof a;//sucess, typeof operator is ALWAYS defined, by  
default it works as specified

alternative notation

   class X{}
   X['operator ~'] = function(){};...

Supporting all these operators in the spec can be somewhat awkward. So I  
wish for at least the typeof, () and [] operators to be defined.
This way one can build custom collections, which have the [] indexing  
operator.
Defining the () operator would fit the use case of IE and Opera (added for  
compatibility) which support the () operator as indexing operator in  
NodeLists.

What do you think ?

Thank you for your attention.",
    "header": Object {
      "date": 2007-12-17T21:04:59.000Z,
      "from": Object {
        "email": "joao.eiras@gmail.com",
        "name": "João Eiras",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Operator%20overloading&In-Reply-To=",
      "subject": "Operator overloading",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005154.html",
  },
  Object {
    "body": "So Peter Hall gave me the links
http://wiki.ecmascript.org/doku.php?id=discussion:operators
http://wiki.ecmascript.org/doku.php?id=proposals:operators

This indeed raises a few issues, mainly with binary operators.
I don't see a single reason for the operators not to be inherited. That
restriction is simply written in the proposal without any backup reasoning.
operators would behave exactly like regular functions. The only difference
is how they're invoked.

The only really issue is when
commutative<http://en.wikipedia.org/wiki/Commutative> operators are
used,
which could lead to ambiguities.
I'd propose for operators to be always evaluated from left to right, unless
the user specifies some kind of pragma, like a similar to the \\"use decimal\\"
one for decimal numbers. Then if the operator function is not available in
the left most member (or right most according to the pragma), it'd be looked
up on the right one. But this should only be done for commutative operators,
which are + *  ==

About \\"compositionality\\", that's not an operator issue, that's an issue
generic to the entire language. If I write two completly different unrelated
classes I can't mix both using regular member functions.

But I recognize that operators could be more problematic than benefic.

So, there are at least a few operators which implementation would somewhat
trivial.
*Being able to define the \\"()\\" (function call), \\"[]\\" (indexing) and typeof
operators is a must.*



2007/12/18, Peter Hall <peter.hall at memorphic.com>:
> This has already been proposed and rejected:
> http://wiki.ecmascript.org/doku.php?id=proposals:operators
>
> And here is some of the rationale for rejecting it:
> http://wiki.ecmascript.org/doku.php?id=discussion:operators
>
> Peter
>
>
> On Dec 17, 2007 9:04 PM, João Eiras <joao.eiras at gmail.com> wrote:
> >
> > Hi all,
> >
> > there's a feature in C++ which I like a lot, and I think it would be
> > interesting to have in es4, which is operator overloading, like
> >
> >    class X{ X& operator+(const X& x); }
> >    X a, b, c; c = a+b;
> >
> > which allows the programmer to define a sum operation between two
objects
> > of type X.
> > The notation I'm using in this e-mail is just for example.
> > C++ allows to define all operators except :: (scope resolution), .
> > (member) and .* (member through pointer)
> >
> > To keep things clean, new operators cannot be defined (like in C++),so
> >
> >    class X{ X& operator myop(const X& x); }
> >    X a, b, c; c = a myop b;
> >
> > would be invalid.
> >
> > Operators should only be defined as members of objects, so one cannot
> > right a global operator function which picks up two object (alla C++),
like
> >    function operator+:X(x:X,x:X);
> >
> > Any global operator function like this one before would be added to the
> > window, and would be equivalent to do
> > window['operator+']=function(x:X):X{}
> > because the 2nd argument would be ignored.
> >
> > The following operators should be definable:
> >   - arithmetic: +  -  *  /  %  +=  -=  *=  /=  %=  ++  --
> >   - bitwise: &  |  ^  >>  <<  >>=  <<=  ~
> >   - boolean: ||  &&  !  ||=  &&=
> >   - others: typeof  ()  []
> >
> > All these operators are binary except for |, ~ and typeof , so the left
> > hand (A) object would be the context object, and the right hand object
(B)
> > would be the argument passed to the operator member in A. For unary
> > operators, there won't be arguments, and the function would be called
upon
> > its target.
> > operator functions would only be called if the operator is explicitly
used
> > in the source code.
> >
> > Now consider an example
> >    class X{
> >      function operator+:X(x:X);
> >      function operator typeof(){ return \\"function\\";};
> >    }
> >    var a:X := new X;
> >    var b:X := new X;
> >
> >    var c:X = a + b; //sucess, operator is defined
> >
> >    a += b; //error, no += operator defined
> >
> >    var c:X = a + 1; //type-error, rhs must be of type X
> >
> >    var tp:String = typeof a;//sucess, typeof operator is ALWAYS defined,
by
> > default it works as specified
> >
> > alternative notation
> >
> >    class X{}
> >    X['operator ~'] = function(){};...
> >
> > Supporting all these operators in the spec can be somewhat awkward. So I
> > wish for at least the typeof, () and [] operators to be defined.
> > This way one can build custom collections, which have the [] indexing
> > operator.
> > Defining the () operator would fit the use case of IE and Opera (added
for
> > compatibility) which support the () operator as indexing operator in
> > NodeLists.
> >
> > What do you think ?
> >
> > Thank you for your attention.
> >
> >
> >
> >
> >
> >
> >
> >
> >
> >
> >
> >
> >
> >
> >
> >
> >
> > _______________________________________________
> > Es4-discuss mailing list
> > Es4-discuss at mozilla.org
> > https://mail.mozilla.org/listinfo/es4-discuss
> >
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://mail.mozilla.org/pipermail/es-discuss/attachments/20071218/3465b731/attachment-0002.html",
    "header": Object {
      "date": 2007-12-18T14:52:37.000Z,
      "from": Object {
        "email": "joao.eiras@gmail.com",
        "name": "João Eiras",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Operator%20overloading&In-Reply-To=9ac110a90712180512k7f3682d4v8299b0789af032fe%40mail.gmail.com",
      "subject": "Operator overloading",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005155.html",
  },
  Object {
    "body": "On Dec 18, 2007 9:52 AM, João Eiras <joao.eiras at gmail.com> wrote:
> Being able to define the \\"()\\" (function call), \\"[]\\" (indexing) and typeof
> operators is a must.

At least function call and property access are indeed customizable
(via a meta-object protocol rather than operator overloading).

Mike",
    "header": Object {
      "date": 2007-12-18T15:59:17.000Z,
      "from": Object {
        "email": "mike.shaver@gmail.com",
        "name": "Mike Shaver",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Operator%20overloading&In-Reply-To=e72b1b360712180652g7d4b510yf82ca8d7220a92c1%40mail.gmail.com",
      "subject": "Operator overloading",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005156.html",
  },
  Object {
    "body": "On Dec 18, 2007, at 6:52 AM, João Eiras wrote:

> So Peter Hall gave me the links
> http://wiki.ecmascript.org/doku.php?id=discussion:operators
> http://wiki.ecmascript.org/doku.php?id=proposals:operators

Once again, out of date documents are misleading folks. We need to  
fix this -- apologies. The language overview:

http://www.ecmascript.org/es4/spec/overview.pdf

and the evolutionary programming tutorial:

http://www.ecmascript.org/es4/spec/evolutionary-programming-tutorial.pdf

both discuss generic functions, which are how operators can be  
defined and overloaded. The wiki page for this proposal is:

http://wiki.ecmascript.org/doku.php?id=proposals:generic_functions

Please read this instead of the operators proposal that it obsoletes.

/be

-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://mail.mozilla.org/pipermail/es-discuss/attachments/20071218/c3a2ebba/attachment-0002.html",
    "header": Object {
      "date": 2007-12-18T20:01:56.000Z,
      "from": Object {
        "email": "brendan@mozilla.com",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Operator%20overloading&In-Reply-To=e72b1b360712180652g7d4b510yf82ca8d7220a92c1%40mail.gmail.com",
      "subject": "Operator overloading",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005157.html",
  },
  Object {
    "body": "Is this permitted syntax in a constructor:

   super.apply(this, arguments);

for the case where I want to pass all my arguments to my superclass  
constructor?  If not, how does one do that, especially if the  
constructor I am calling from takes a ...rest arg?",
    "header": Object {
      "date": 2007-12-19T17:46:21.000Z,
      "from": Object {
        "email": "ptw@pobox.com",
        "name": "P T Withington",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=super.apply%28this%2C%20arguments%29&In-Reply-To=",
      "subject": "super.apply(this, arguments)",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005158.html",
  },
  Object {
    "body": "ES4 proposals include making regexes callable as a function on a single string argument, which serves as a shorthand for calling the regex's exec method. To further extend this idea, what about also including call and apply methods on RegExp.prototype, so that regexes can more easily be used with functional programming? For e.g., if one were to model a \\"where\\" function after JS 1.6's Array.prototype.filter like so:

function where (array, func, context) {
    var results = [];
    for (var i = 0; i < array.length; i++) {
        if (func.call(context, array[i], i, array))
            results.push(array[i]);
    }
    return results;
}

...They could then use, e.g., where([\\"ab\\", \\"ba\\", \\"a\\", \\"b\\"], /^a/) to return all array elements starting with the letter \\"a\\" ([\\"ab\\", \\"a\\"]).

Thoughts? Is this possibly already included in the proposals? (sorry if I missed it)


_________________________________________________________________
i’m is proud to present Cause Effect, a series about real people making a difference.
http://im.live.com/Messenger/IM/MTV/?source=text_Cause_Effect
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://mail.mozilla.org/pipermail/es-discuss/attachments/20071219/f9e1ef94/attachment-0002.html",
    "header": Object {
      "date": 2007-12-20T01:59:01.000Z,
      "from": Object {
        "email": "steves_list@hotmail.com",
        "name": "Steven L.",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Add%20call%20and%20apply%20methods%20to%20RegExp.prototype&In-Reply-To=",
      "subject": "Add call and apply methods to RegExp.prototype",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005159.html",
  },
  Object {
    "body": "With so many ECMAScript engines rushing ahead to implement the ES4
proposal, it seems as though the proposal is as good as approved.
Perhaps there will be minor tweaks but if so many implementations
contain classes, for example, such a feature will almost certainly be
in ES4 final.

Has the voting majority agreed in principle to vote in favor of the proposal?

Thanks,
Peter",
    "header": Object {
      "date": 2007-12-20T05:16:04.000Z,
      "from": Object {
        "email": "petermichaux@gmail.com",
        "name": "Peter Michaux",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=is%20the%20ES4%20proposal%20as%20good%20as%20approved%3F&In-Reply-To=",
      "subject": "is the ES4 proposal as good as approved?",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005160.html",
  },
  Object {
    "body": "On Dec 19, 2007, at 9:16 PM, Peter Michaux wrote:

> With so many ECMAScript engines rushing ahead to implement the ES4
> proposal, it seems as though the proposal is as good as approved.

No, and I wonder if you missed my reply to your comment in John  
Resig's blog:

http://ejohn.org/blog/state-of-ecmascript-4-dec-07/#comment-296284

John's Google Spreadsheet and generated chart is charting progress.  
There will be changes to both implementations and draft specs. Don't  
panic.

As I wrote in that comment, it would be a big mistake to specify  
without implementations that users test and truly use for non-trivial/ 
synthetic inputs. It would also be a mistake to marry an early draft  
just because it was implemented and used.

> Perhaps there will be minor tweaks but if so many implementations
> contain classes, for example, such a feature will almost certainly be
> in ES4 final.

Let's cut to the chase: what are you worried about? Classes being in  
ES4?

> Has the voting majority agreed in principle to vote in favor of the  
> proposal?

Ecma and ISO technical groups work by consensus, not voting. As  
everyone knows, consensus broke down within TG1, in a public way this  
past fall -- but we are trying to repair it now.

/be
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://mail.mozilla.org/pipermail/es-discuss/attachments/20071219/3447fe40/attachment-0002.html",
    "header": Object {
      "date": 2007-12-20T05:38:33.000Z,
      "from": Object {
        "email": "brendan@mozilla.com",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=is%20the%20ES4%20proposal%20as%20good%20as%20approved%3F&In-Reply-To=3cbaf1c80712192116n723a7b29ue640ffda7780c932%40mail.gmail.com",
      "subject": "is the ES4 proposal as good as approved?",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005161.html",
  },
  Object {
    "body": "On Dec 19, 2007 9:38 PM, Brendan Eich <brendan at mozilla.org> wrote:
>
>
> On Dec 19, 2007, at 9:16 PM, Peter Michaux wrote:
>
> With so many ECMAScript engines rushing ahead to implement the ES4
> proposal, it seems as though the proposal is as good as approved.
>
> No, and I wonder if you missed my reply to your comment in John Resig's
> blog:
>
>
> http://ejohn.org/blog/state-of-ecmascript-4-dec-07/#comment-296284

I did see it. Thank you.

> John's Google Spreadsheet and generated chart is charting progress. There
> will be changes to both implementations and draft specs. Don't panic.
>
> As I wrote in that comment, it would be a big mistake to specify without
> implementations that users test and truly use for non-trivial/synthetic
> inputs. It would also be a mistake to marry an early draft just because it
> was implemented and used.
>
>
> Perhaps there will be minor tweaks but if so many implementations
> contain classes, for example, such a feature will almost certainly be
> in ES4 final.
>
> Let's cut to the chase: what are you worried about?

Curious about the process mostly.

> Classes being in ES4?

Classes were just the easiest feature to use as an example since it is
such an obvious one.

> Has the voting majority agreed in principle to vote in favor of the
> proposal?
>
> Ecma and ISO technical groups work by consensus, not voting. As everyone
> knows, consensus broke down within TG1, in a public way this past fall --
> but we are trying to repair it now.

I didn't know it was consensus. I think it is much easier in a vote
for someone to say no to the proposal knowing it will pass anyway than
for someone to say no in a consensus group knowing his perhaps unique
position will spoil the party for everyone else. It seems like it
would take a very big jerk to turn down the proposal if so many
companies have already invested in implementing the proposal. That is
why the term \\"strong arm\\" came to mind when I commented on John's
blog.

Thank you,
Peter",
    "header": Object {
      "date": 2007-12-20T06:05:07.000Z,
      "from": Object {
        "email": "petermichaux@gmail.com",
        "name": "Peter Michaux",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=is%20the%20ES4%20proposal%20as%20good%20as%20approved%3F&In-Reply-To=BF957FDB-826F-4169-9136-4157E765D489%40mozilla.org",
      "subject": "is the ES4 proposal as good as approved?",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005162.html",
  },
  Object {
    "body": "Interesting.  One wonders why we keep the silly fiction of naming the  
constructor after the class if it is really going to show up in the  
class as the \`construct\` method.  It's always bothered me that I have  
to write the class name in two places, and fix it in two places if I  
change my mind, or copy/paste a class to create a new class.

But, does the construct method cause allocation?  If so, it doesn't  
really solve my problem, since I really only want the initialization  
of the superclass constructor, not allocation.

It seems to me that what I really want is for there to be separate  
ways to apply \`new\` (to allocate a new instance using apply) and to  
apply the constructor method (to initialize a new instance using apply).

I want to be able to say:

class Foo extends Bar {

   function Foo () {
     super.initialize.apply(this, arguments);

I don't want to call \`super.construct\` because I don't want to  
allocate a new instance of my superclass, I just want to run the  
initialization that my superclass does.

I suppose I have to say:

     Bar.apply(this, arguments);

but now I have to type not only my class name, but also my superclass  
name in two places.

Or maybe we are going to be told this is yet another outdated wiki  
page that is leading us astray?

On 2007-12-20, at 00:02 EST, Garrett Smith wrote:

> There's a proposal that, I think, addresses that using construct:
>
> http://wiki.ecmascript.org/doku.php?id=proposals:static_generics
>
> Though in the context of a subclass' constructor, I don't know what
> the syntax would be.
>
> Garrett
>
> On Dec 19, 2007 9:46 AM, P T Withington <ptw at pobox.com> wrote:
>> Is this permitted syntax in a constructor:
>>
>>   super.apply(this, arguments);
>>
>> for the case where I want to pass all my arguments to my superclass
>> constructor?  If not, how does one do that, especially if the
>> constructor I am calling from takes a ...rest arg?
>> _______________________________________________
>> Es4-discuss mailing list
>> Es4-discuss at mozilla.org
>> https://mail.mozilla.org/listinfo/es4-discuss
>>
>
>
>
> -- 
> Monkey, so they say, is the root of all people today.",
    "header": Object {
      "date": 2007-12-20T13:57:39.000Z,
      "from": Object {
        "email": "ptw@pobox.com",
        "name": "P T Withington",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=super.apply%28this%2C%20arguments%29&In-Reply-To=c9e12660712192102u3fa31941s689c3f376636f398%40mail.gmail.com",
      "subject": "super.apply(this, arguments)",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005163.html",
  },
  Object {
    "body": "Wiki rot.  The construct method is long since obsolete.

The wiki really is wildly out of date in some respects.  There is
nothing solid to replace it right now, but reading it can cause severe
confusion...

--lars

On Dec 20, 2007 2:57 PM, P T Withington <ptw at pobox.com> wrote:
> Interesting.  One wonders why we keep the silly fiction of naming the
> constructor after the class if it is really going to show up in the
> class as the \`construct\` method.  It's always bothered me that I have
> to write the class name in two places, and fix it in two places if I
> change my mind, or copy/paste a class to create a new class.
>
> But, does the construct method cause allocation?  If so, it doesn't
> really solve my problem, since I really only want the initialization
> of the superclass constructor, not allocation.
>
> It seems to me that what I really want is for there to be separate
> ways to apply \`new\` (to allocate a new instance using apply) and to
> apply the constructor method (to initialize a new instance using apply).
>
> I want to be able to say:
>
> class Foo extends Bar {
>
>    function Foo () {
>      super.initialize.apply(this, arguments);
>
> I don't want to call \`super.construct\` because I don't want to
> allocate a new instance of my superclass, I just want to run the
> initialization that my superclass does.
>
> I suppose I have to say:
>
>      Bar.apply(this, arguments);
>
> but now I have to type not only my class name, but also my superclass
> name in two places.
>
> Or maybe we are going to be told this is yet another outdated wiki
> page that is leading us astray?
>
> On 2007-12-20, at 00:02 EST, Garrett Smith wrote:
>
> > There's a proposal that, I think, addresses that using construct:
> >
> > http://wiki.ecmascript.org/doku.php?id=proposals:static_generics
> >
> > Though in the context of a subclass' constructor, I don't know what
> > the syntax would be.
> >
> > Garrett
>
> >
> > On Dec 19, 2007 9:46 AM, P T Withington <ptw at pobox.com> wrote:
> >> Is this permitted syntax in a constructor:
> >>
> >>   super.apply(this, arguments);
> >>
> >> for the case where I want to pass all my arguments to my superclass
> >> constructor?  If not, how does one do that, especially if the
> >> constructor I am calling from takes a ...rest arg?
> >> _______________________________________________
> >> Es4-discuss mailing list
> >> Es4-discuss at mozilla.org
> >> https://mail.mozilla.org/listinfo/es4-discuss
> >>
> >
> >
> >
> > --
> > Monkey, so they say, is the root of all people today.
>
>
> _______________________________________________
> Es4-discuss mailing list
> Es4-discuss at mozilla.org
> https://mail.mozilla.org/listinfo/es4-discuss
>",
    "header": Object {
      "date": 2007-12-20T15:10:40.000Z,
      "from": Object {
        "email": "lth@acm.org",
        "name": "Lars T Hansen",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=super.apply%28this%2C%20arguments%29&In-Reply-To=0282EDEC-B208-4C82-87F3-A15A063593B8%40pobox.com",
      "subject": "super.apply(this, arguments)",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005164.html",
  },
  Object {
    "body": "Ok.  I didn't look in the wiki to start with because of that, hence I  
ask on the list:  can I apply my super's constructor as in the subject  
line?

On 2007-12-20, at 10:10 EST, Lars T Hansen wrote:

> Wiki rot.  The construct method is long since obsolete.
>
> The wiki really is wildly out of date in some respects.  There is
> nothing solid to replace it right now, but reading it can cause severe
> confusion...",
    "header": Object {
      "date": 2007-12-20T15:20:33.000Z,
      "from": Object {
        "email": "ptw@pobox.com",
        "name": "P T Withington",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=super.apply%28this%2C%20arguments%29&In-Reply-To=12c6978a0712200710k437caa4asac0aa997f4fe304d%40mail.gmail.com",
      "subject": "super.apply(this, arguments)",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005165.html",
  },
  Object {
    "body": "Sorry, but you can't.

Jd


On 12/20/07 7:20 AM, P T Withington wrote:

> Ok.  I didn't look in the wiki to start with because of that, hence I
> ask on the list:  can I apply my super's constructor as in the subject
> line?
> 
> On 2007-12-20, at 10:10 EST, Lars T Hansen wrote:
> 
>> Wiki rot.  The construct method is long since obsolete.
>> 
>> The wiki really is wildly out of date in some respects.  There is
>> nothing solid to replace it right now, but reading it can cause severe
>> confusion...
> 
> _______________________________________________
> Es4-discuss mailing list
> Es4-discuss at mozilla.org
> https://mail.mozilla.org/listinfo/es4-discuss",
    "header": Object {
      "date": 2007-12-20T15:27:23.000Z,
      "from": Object {
        "email": "jodyer@adobe.com",
        "name": "Jeff Dyer",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=super.apply%28this%2C%20arguments%29&In-Reply-To=640257D1-061E-4113-BD2E-67A02030456D%40pobox.com",
      "subject": "super.apply(this, arguments)",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005166.html",
  },
  Object {
    "body": "> On 12/20/07 7:20 AM, P T Withington wrote:
> 
>> Ok.  I didn't look in the wiki to start with because of that, hence I
>> ask on the list:  can I apply my super's constructor as in the subject
>> line?
>>
Jeff Dyer wrote:
 > Sorry, but you can't.
 >

That's a shame.

-dean",
    "header": Object {
      "date": 2007-12-20T17:04:30.000Z,
      "from": Object {
        "email": "dean@edwards.name",
        "name": "Dean Edwards",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=super.apply%28this%2C%20arguments%29&In-Reply-To=C38FC9DB.10932%25jodyer%40adobe.com",
      "subject": "super.apply(this, arguments)",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005167.html",
  },
  Object {
    "body": "Sorry, I didn't mean to sound so flippant.

As you may know, super expressions limit the binding of the name after the
dot to the base class bindings. So the fragment above would call the super
instance method 'apply', not the super constructor. We could give 'apply'
some special meaning when the first argument is 'this', but the super
constructor will have already been called during initialization.

None of this means that the desired semantics wouldn't be possible to
achieve with another syntax. My guess is that it would be somehow similar to
the current super initializer syntax, which looks like this:

   class A extends B {
      function A(x,y,z) : super (x,y,z) { }
   }

Suggestion welcomed.

Jd

On 12/20/07 9:04 AM, Dean Edwards wrote:

>> On 12/20/07 7:20 AM, P T Withington wrote:
>> 
>>> Ok.  I didn't look in the wiki to start with because of that, hence I
>>> ask on the list:  can I apply my super's constructor as in the subject
>>> line?
>>> 
> Jeff Dyer wrote:
>> Sorry, but you can't.
>> 
> 
> That's a shame.
> 
> -dean",
    "header": Object {
      "date": 2007-12-20T18:05:41.000Z,
      "from": Object {
        "email": "jodyer@adobe.com",
        "name": "Jeff Dyer",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=super.apply%28this%2C%20arguments%29&In-Reply-To=476AA09E.9050107%40edwards.name",
      "subject": "super.apply(this, arguments)",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005168.html",
  },
  Object {
    "body": "I haven't tried this in the RI, but what about:

 var sup = super;
 sup.apply(this, arguments);


?

Peter

On Dec 20, 2007 6:05 PM, Jeff Dyer <jodyer at adobe.com> wrote:
> Sorry, I didn't mean to sound so flippant.
>
> As you may know, super expressions limit the binding of the name after the
> dot to the base class bindings. So the fragment above would call the super
> instance method 'apply', not the super constructor. We could give 'apply'
> some special meaning when the first argument is 'this', but the super
> constructor will have already been called during initialization.
>
> None of this means that the desired semantics wouldn't be possible to
> achieve with another syntax. My guess is that it would be somehow similar to
> the current super initializer syntax, which looks like this:
>
>    class A extends B {
>       function A(x,y,z) : super (x,y,z) { }
>    }
>
> Suggestion welcomed.
>
> Jd
>
>
> On 12/20/07 9:04 AM, Dean Edwards wrote:
>
> >> On 12/20/07 7:20 AM, P T Withington wrote:
> >>
> >>> Ok.  I didn't look in the wiki to start with because of that, hence I
> >>> ask on the list:  can I apply my super's constructor as in the subject
> >>> line?
> >>>
> > Jeff Dyer wrote:
> >> Sorry, but you can't.
> >>
> >
> > That's a shame.
> >
> > -dean
>
> _______________________________________________
> Es4-discuss mailing list
> Es4-discuss at mozilla.org
> https://mail.mozilla.org/listinfo/es4-discuss
>",
    "header": Object {
      "date": 2007-12-20T18:31:27.000Z,
      "from": Object {
        "email": "peter.hall@memorphic.com",
        "name": "Peter Hall",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=super.apply%28this%2C%20arguments%29&In-Reply-To=C38FEEF5.1094E%25jodyer%40adobe.com",
      "subject": "super.apply(this, arguments)",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005169.html",
  },
  Object {
    "body": "Peter Hall wrote:

> I haven't tried this in the RI, but what about:
> 
>  var sup = super;
>  sup.apply(this, arguments);

No, the problem arises from two separate facts:

   - constructor invocation is not a function call
   - super-constructor chaining is not a function call either

Both of these are different operations with different semantics. We have 
a way of getting a function for the former (using the reflection API) 
such that you can run a constructor with variable args using apply. We 
do not have a way of getting a function for the latter, and really 
should not. Super-constructor chaining occurs only in a special, limited 
syntactic and semantic context: the end of the settings list, before the 
constructor body is entered. There's no reasonable interpretation of a 
first class escaping function that does this, as the context in which 
the function even makes sense vanishes as soon as the constructor body 
is entered. This is why we currently just use an explicit super-expression.

However, I think we can all see a nice symmetry argument that it would 
be nice to have an additional form for passing variable arguments up to 
your super-constructor. I'd imagine lots of possibilities might work, so 
long as they're unambiguous:

    function myObj(...args)
      : super.apply(args)          // a pseudo-property?
    {}

    function myObj(...args)
      : super_apply(args)          // a pseudo-global?
    {}

    function myObj(...args)
      : super_arguments = args     // a pseudo-local?
    {}

I suspect the first will turn the least number of stomachs, and is 
probably ok if we prohibit all *other* super-property accesses in the 
settings list. This seems plausible to me given that the first-class 
super rvalue hasn't even been initialized by the time the settings run, 
only allocated.

-Graydon",
    "header": Object {
      "date": 2007-12-20T19:24:54.000Z,
      "from": Object {
        "email": "graydon@mozilla.com",
        "name": "Graydon Hoare",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=super.apply%28this%2C%20arguments%29&In-Reply-To=9ac110a90712201031k7f83979avee42148f6145aeaa%40mail.gmail.com",
      "subject": "super.apply(this, arguments)",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005170.html",
  },
  Object {
    "body": "Given that we already have a whacky syntax for calling the super  
initializer (which I confess I had forgotten), why not allow apply  
there?  It's unambiguous there, since you are only allowed to call the  
super initializer.  This syntax is just letting you override how your  
arguments are passed on to your super initializer.  What is the  
default if I don't specify a call to my super initializer?  Does it  
get all my arguments, or none of them?

   class A extends B {
      function A(x,y,z) : super.apply (this, arguments) { ... }
   }

?

Personally, I really don't like the magic of the class name naming the  
initializer.  I would rather see a magic method name, say  
\`initialize\`, so you say:

   class A extends B {
      function initialize(x,y,z) {
        super.initialize.apply(this, arguments);
        ...
      }
   }

but that is probably too radical.  On the plus side, you don't have to  
repeat the class name, which makes easier maintenance and code reuse,  
on the minus side there is a magic method name and you have to decide  
whether to enforce arglist congruency or not (an issue hidden by  
having each initializer have the class name as its name).

On 2007-12-20, at 13:05 EST, Jeff Dyer wrote:

> Sorry, I didn't mean to sound so flippant.
>
> As you may know, super expressions limit the binding of the name  
> after the
> dot to the base class bindings. So the fragment above would call the  
> super
> instance method 'apply', not the super constructor. We could give  
> 'apply'
> some special meaning when the first argument is 'this', but the super
> constructor will have already been called during initialization.
>
> None of this means that the desired semantics wouldn't be possible to
> achieve with another syntax. My guess is that it would be somehow  
> similar to
> the current super initializer syntax, which looks like this:
>
>   class A extends B {
>      function A(x,y,z) : super (x,y,z) { }
>   }
>
> Suggestion welcomed.
>
> Jd
>
> On 12/20/07 9:04 AM, Dean Edwards wrote:
>
>>> On 12/20/07 7:20 AM, P T Withington wrote:
>>>
>>>> Ok.  I didn't look in the wiki to start with because of that,  
>>>> hence I
>>>> ask on the list:  can I apply my super's constructor as in the  
>>>> subject
>>>> line?
>>>>
>> Jeff Dyer wrote:
>>> Sorry, but you can't.
>>>
>>
>> That's a shame.
>>
>> -dean
>",
    "header": Object {
      "date": 2007-12-20T19:29:35.000Z,
      "from": Object {
        "email": "ptw@pobox.com",
        "name": "P T Withington",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=super.apply%28this%2C%20arguments%29&In-Reply-To=C38FEEF5.1094E%25jodyer%40adobe.com",
      "subject": "super.apply(this, arguments)",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005171.html",
  },
  Object {
    "body": "On Dec 19, 2007, at 10:05 PM, Peter Michaux wrote:

>> Let's cut to the chase: what are you worried about?
>
> Curious about the process mostly.

Here's a fresh example:

https://bugzilla.mozilla.org/show_bug.cgi?id=409252

My conclusion is at

https://bugzilla.mozilla.org/show_bug.cgi?id=409252#c5

We knew this could happen, but we planned to find out in a Firefox 3  
beta. Lack of negative feedback would not be decisive, but in  
combination with the incoherent state of constructor property present  
value vs. memoized initial value (or value of constructor.prototype)  
in ES3, would be encouraging. Negative feedback would be decisive,  
and is being decisive ;-). See, no \\"strong-arming\\". You can't fool  
Mother Web.

>> Ecma and ISO technical groups work by consensus, not voting. As  
>> everyone
>> knows, consensus broke down within TG1, in a public way this past  
>> fall --
>> but we are trying to repair it now.
>
> I didn't know it was consensus. I think it is much easier in a vote
> for someone to say no to the proposal knowing it will pass anyway than
> for someone to say no in a consensus group knowing his perhaps unique
> position will spoil the party for everyone else.

This seems not to be a problem for our group ;-). I hear you, it can  
be a problem on marginal issues, where people want to \\"avoid  
conflict\\", but we've learned to embrace conflict.

> It seems like it
> would take a very big jerk to turn down the proposal if so many
> companies have already invested in implementing the proposal. That is
> why the term \\"strong arm\\" came to mind when I commented on John's
> blog.

So many companies implementing something that needs adjusting, or  
even removal, can still leave those companies carrying an extension,  
if they don't adjust to match the final spec. But companies are not  
working together in a standards body just to try to win by going to  
market -- that is too obviously counter-productive at least for the  
minority-share vendors (not necessarily for the majority-share vendor  
-- see the Prisoner's Dilemma).

/be

-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://mail.mozilla.org/pipermail/es-discuss/attachments/20071220/fb521df1/attachment-0002.html",
    "header": Object {
      "date": 2007-12-20T22:45:20.000Z,
      "from": Object {
        "email": "brendan@mozilla.com",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=is%20the%20ES4%20proposal%20as%20good%20as%20approved%3F&In-Reply-To=3cbaf1c80712192205u7481752cmf9c10a7e329fb852%40mail.gmail.com",
      "subject": "is the ES4 proposal as good as approved?",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005172.html",
  },
  Object {
    "body": "On 12/20/07 11:29 AM, P T Withington wrote:

> Given that we already have a whacky syntax for calling the super
> initializer (which I confess I had forgotten), why not allow apply
> there?  It's unambiguous there, since you are only allowed to call the
> super initializer.  This syntax is just letting you override how your
> arguments are passed on to your super initializer.

The only problem I see is that the syntax 'super . apply ( )\\" looks a lot
like a super expression, which has a different meaning than what you want it
to mean. Not a deal breaker, but an usability check.

> What is the  
> default if I don't specify a call to my super initializer?  Does it
> get all my arguments, or none of them?

None of them.

> 
>    class A extends B {
>       function A(x,y,z) : super.apply (this, arguments) { ... }
>    }
> 
> ?

The original Netscape ES4 proposal had syntax for passing arguments as an
array. (Waldemar are you listening?) IIRC it used triple dots like this:

   foo(...args)

to mean use the elements of 'args' as positional arguments of foo. We
dropped this from AS3 for lack of evidence for its need. But this might be a
way forward.

   class A extends B {
      function A(x,y,z) : super(...arguments) { }
   }

> 
> Personally, I really don't like the magic of the class name naming the
> initializer.  I would rather see a magic method name, say
> \`initialize\`, so you say:
> 
>    class A extends B {
>       function initialize(x,y,z) {
>         super.initialize.apply(this, arguments);
>         ...
>       }
>    }
> 
> but that is probably too radical.  On the plus side, you don't have to
> repeat the class name, which makes easier maintenance and code reuse,
> on the minus side there is a magic method name and you have to decide
> whether to enforce arglist congruency or not (an issue hidden by
> having each initializer have the class name as its name).

During the development of AS3 we considered other naming schemes for class
constructors. In the end we chose the status quo because it is familiar
(least surprise) and constructors really aren't methods that can be called
directly. They are blocks of code that get executed in conjunction with the
new operation. Making them look like methods seems misleading, at least in
this language.

Jd

> 
> On 2007-12-20, at 13:05 EST, Jeff Dyer wrote:
> 
>> Sorry, I didn't mean to sound so flippant.
>> 
>> As you may know, super expressions limit the binding of the name
>> after the
>> dot to the base class bindings. So the fragment above would call the
>> super
>> instance method 'apply', not the super constructor. We could give
>> 'apply'
>> some special meaning when the first argument is 'this', but the super
>> constructor will have already been called during initialization.
>> 
>> None of this means that the desired semantics wouldn't be possible to
>> achieve with another syntax. My guess is that it would be somehow
>> similar to
>> the current super initializer syntax, which looks like this:
>> 
>>   class A extends B {
>>      function A(x,y,z) : super (x,y,z) { }
>>   }
>> 
>> Suggestion welcomed.
>> 
>> Jd
>> 
>> On 12/20/07 9:04 AM, Dean Edwards wrote:
>> 
>>>> On 12/20/07 7:20 AM, P T Withington wrote:
>>>> 
>>>>> Ok.  I didn't look in the wiki to start with because of that,
>>>>> hence I
>>>>> ask on the list:  can I apply my super's constructor as in the
>>>>> subject
>>>>> line?
>>>>> 
>>> Jeff Dyer wrote:
>>>> Sorry, but you can't.
>>>> 
>>> 
>>> That's a shame.
>>> 
>>> -dean
>> 
>",
    "header": Object {
      "date": 2007-12-21T00:01:59.000Z,
      "from": Object {
        "email": "jodyer@adobe.com",
        "name": "Jeff Dyer",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=super.apply%28this%2C%20arguments%29&In-Reply-To=E2EF59F5-CEA4-4042-9C7E-DA2C8D52959D%40pobox.com",
      "subject": "super.apply(this, arguments)",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005173.html",
  },
  Object {
    "body": "On Dec 20, 2007 11:29 AM, P T Withington <ptw at pobox.com> wrote:
> Given that we already have a whacky syntax for calling the super
> initializer (which I confess I had forgotten), why not allow apply
> there?  It's unambiguous there, since you are only allowed to call the
> super initializer.  This syntax is just letting you override how your
> arguments are passed on to your super initializer.  What is the
> default if I don't specify a call to my super initializer?  Does it
> get all my arguments, or none of them?
>
>   class A extends B {
>      function A(x,y,z) : super.apply (this, arguments) { ... }
>   }
>
> ?
>
> Personally, I really don't like the magic of the class name naming the
> initializer.  I would rather see a magic method name, say
> \`initialize\`, so you say:
>
>   class A extends B {
>      function initialize(x,y,z) {
>        super.initialize.apply(this, arguments);
>        ...
>      }
>   }
>
> but that is probably too radical.  On the plus side, you don't have to
> repeat the class name, which makes easier maintenance and code reuse,
> on the minus side there is a magic method name and you have to decide
> whether to enforce arglist congruency or not (an issue hidden by
> having each initializer have the class name as its name).
>
So you're proposing making some sort of \\"instance constructor\\"
property on the class

MyClass.instanceConstructor.newApply(lockable, args );

Would you be able to call that with another object?

function LockableFile() {
  var lockable = Lockable.createInstance();
  var lockableFile = FIle.instanceConstructor.newApply(lockable, args);
}

What about calling a nested class?

class Menu() {
  class Item() {

  }
  function buildSingleItemMenu(...args) {
    this.new Item(...args);
}

function buildSingleItemMenu( ) {
  return new Menu().Item.instanceConstructor.newApply( arguments );
}

Just some ideas.

>
> On 2007-12-20, at 13:05 EST, Jeff Dyer wrote:
>
> > Sorry, I didn't mean to sound so flippant.
> >
> > As you may know, super expressions limit the binding of the name
> > after the
> > dot to the base class bindings. So the fragment above would call the
> > super
> > instance method 'apply', not the super constructor.

Right, because the super is a Function, which gets an apply method
from Function.prototype.

We could give
> > 'apply'
> > some special meaning when the first argument is 'this', but the super
> > constructor will have already been called during initialization.
> >
> > None of this means that the desired semantics wouldn't be possible to
> > achieve with another syntax. My guess is that it would be somehow
> > similar to
> > the current super initializer syntax, which looks like this:
> >
> >   class A extends B {
> >      function A(x,y,z) : super (x,y,z) { }
> >   }
> >
> > Suggestion welcomed.
> >
I kind of like the syntax P T Withington suggests for reasons he
mentioned but I don't like the name | initialize | to refer to the
instance constructor.

Garrett

> > Jd
> >
> > On 12/20/07 9:04 AM, Dean Edwards wrote:
> >
> >>> On 12/20/07 7:20 AM, P T Withington wrote:
> >>>
> >>>> Ok.  I didn't look in the wiki to start with because of that,
> >>>> hence I
> >>>> ask on the list:  can I apply my super's constructor as in the
> >>>> subject
> >>>> line?
> >>>>
> >> Jeff Dyer wrote:
> >>> Sorry, but you can't.
> >>>
> >>
> >> That's a shame.
> >>
> >> -dean
> >
>
> _______________________________________________
> Es4-discuss mailing list
> Es4-discuss at mozilla.org
> https://mail.mozilla.org/listinfo/es4-discuss
>



-- 
Monkey, so they say, is the root of all people today.",
    "header": Object {
      "date": 2007-12-21T03:49:24.000Z,
      "from": Object {
        "email": "dhtmlkitchen@gmail.com",
        "name": "Garrett Smith",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=super.apply%28this%2C%20arguments%29&In-Reply-To=E2EF59F5-CEA4-4042-9C7E-DA2C8D52959D%40pobox.com",
      "subject": "super.apply(this, arguments)",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005174.html",
  },
  Object {
    "body": "On Dec 20, 2007, at 4:01 PM, Jeff Dyer wrote:

> The original Netscape ES4 proposal had syntax for passing arguments  
> as an
> array. (Waldemar are you listening?) IIRC it used triple dots like  
> this:
>
>    foo(...args)
>
> to mean use the elements of 'args' as positional arguments of foo. We
> dropped this from AS3 for lack of evidence for its need.

Wow. I like this, never saw it in Waldemar's proposals, but of course  
Python and other languages have something akin. This is the missing  
solution that satisfies the demand for compositional new and apply,  
as well as other apply-like use-cases (see the thread on this very  
list, inspired by Python, starting here).

Presumably you could supply one or more positional actual parameters  
before the \\"packed\\" parameter, as Python allows:

 >>> def foo(a,b,c):
...   print a,b,c
...
 >>> foo(1,2,3)
1 2 3
 >>> a = [1,2,3]
 >>> foo(*a)
1 2 3
 >>> b = [2,3]
 >>> foo(1,*b)
1 2 3

This beats a super.apply special form any day!

/be

-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://mail.mozilla.org/pipermail/es-discuss/attachments/20071220/fb1857c4/attachment-0002.html",
    "header": Object {
      "date": 2007-12-21T05:39:28.000Z,
      "from": Object {
        "email": "brendan@mozilla.com",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=super.apply%28this%2C%20arguments%29&In-Reply-To=C3904277.1099D%25jodyer%40adobe.com",
      "subject": "super.apply(this, arguments)",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005175.html",
  },
  Object {
    "body": "Sounds like a good idea to me. On the other hand, this can already
easily be done in ES3.

Steven L. wrote:
> ES4 proposals include making regexes callable as a function on a
> single string argument, which serves as a shorthand for calling the
> regex's exec method. To further extend this idea, what about also
> including call and apply methods on RegExp.prototype, so that regexes
> can more easily be used with functional programming? For e.g., if one
> were to model a \\"where\\" function after JS 1.6's Array.prototype.filter
> like so:
>
> function where (array, func, context) {
>     var results = [];
>     for (var i = 0; i < array.length; i++) {
>         if (func.call(context, array[i], i, array))
>             results.push(array[i]);
>     }
>     return results;
> }
>
> ...They could then use, e.g., where([\\"ab\\", \\"ba\\", \\"a\\", \\"b\\"], /^a/) to
> return all array elements starting with the letter \\"a\\" ([\\"ab\\", \\"a\\"]).
>
> Thoughts? Is this possibly already included in the proposals? (sorry
> if I missed it)
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://mail.mozilla.org/pipermail/es-discuss/attachments/20071221/b9498e85/attachment-0002.html",
    "header": Object {
      "date": 2007-12-21T08:15:46.000Z,
      "from": Object {
        "email": "maian330@gmail.com",
        "name": "Yuh-Ruey Chen",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Add%20call%20and%20apply%20methods%20to%20RegExp.prototype&In-Reply-To=BAY124-W34BC42B6E975571B1BB8FC905D0%40phx.gbl",
      "subject": "Add call and apply methods to RegExp.prototype",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005176.html",
  },
  Object {
    "body": "On 21/12/2007, at 11:01 AM, Jeff Dyer wrote:
> We dropped this from AS3 for lack of evidence for its need.

Really? The \\"rest\\" arguments (tail arguments specified as an array)  
is available in AS3 as far as I'm aware:

     function foo(first:*, second:*, ...rest) {
         trace(arguments.length); // variable int, depending on how  
foo is called
         trace(rest is Array); // true
     }

Isn't this also in the ES4 overview (page 22)?


Cheers,

--
Nathan de Vries",
    "header": Object {
      "date": 2007-12-21T11:05:48.000Z,
      "from": Object {
        "email": "nathan@atnan.com",
        "name": "Nathan de Vries",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=super.apply%28this%2C%20arguments%29&In-Reply-To=C3904277.1099D%25jodyer%40adobe.com",
      "subject": "super.apply(this, arguments)",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005177.html",
  },
  Object {
    "body": "That is a slightly different feature. ...rest is included for
declaring variable length argument lists. But not for passing a
variable number of values when you actually make the call.

// this is implemented in AS3
function myFunction(...rest){
}

// this is not
args = [1,2,3];
myFunction(...args);


Peter



On Dec 21, 2007 11:05 AM, Nathan de Vries <nathan at atnan.com> wrote:
> On 21/12/2007, at 11:01 AM, Jeff Dyer wrote:
> > We dropped this from AS3 for lack of evidence for its need.
>
> Really? The \\"rest\\" arguments (tail arguments specified as an array)
> is available in AS3 as far as I'm aware:
>
>      function foo(first:*, second:*, ...rest) {
>          trace(arguments.length); // variable int, depending on how
> foo is called
>          trace(rest is Array); // true
>      }
>
> Isn't this also in the ES4 overview (page 22)?
>
>
> Cheers,
>
> --
> Nathan de Vries
>
> _______________________________________________
> Es4-discuss mailing list
> Es4-discuss at mozilla.org
> https://mail.mozilla.org/listinfo/es4-discuss
>",
    "header": Object {
      "date": 2007-12-21T12:42:11.000Z,
      "from": Object {
        "email": "peter.hall@memorphic.com",
        "name": "Peter Hall",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=super.apply%28this%2C%20arguments%29&In-Reply-To=96A22836-7034-471E-AC93-C33E848E03EF%40atnan.com",
      "subject": "super.apply(this, arguments)",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005178.html",
  },
  Object {
    "body": "Can it refer to previous parameters?  Assign to them?  Is this legal?

   function foo (a:t = x, b:u = (a = y, z))",
    "header": Object {
      "date": 2007-12-21T12:53:19.000Z,
      "from": Object {
        "email": "ptw@pobox.com",
        "name": "P T Withington",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=How%20complex%20can%20a%20parameter%20default%20expression%20be%3F&In-Reply-To=",
      "subject": "How complex can a parameter default expression be?",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005179.html",
  },
  Object {
    "body": "On 2007-12-21, at 00:39 EST, Brendan Eich wrote:

> On Dec 20, 2007, at 4:01 PM, Jeff Dyer wrote:
>
>> The original Netscape ES4 proposal had syntax for passing arguments  
>> as an
>> array. (Waldemar are you listening?) IIRC it used triple dots like  
>> this:
>>
>>   foo(...args)
>>
>> to mean use the elements of 'args' as positional arguments of foo. We
>> dropped this from AS3 for lack of evidence for its need.
>
> Wow. I like this, never saw it in Waldemar's proposals, but of  
> course Python and other languages have something akin. This is the  
> missing solution that satisfies the demand for compositional new and  
> apply, as well as other apply-like use-cases (see the thread on this  
> very list, inspired by Python, starting here).
>
> Presumably you could supply one or more positional actual parameters  
> before the \\"packed\\" parameter, as Python allows:
>
> >>> def foo(a,b,c):
> ...   print a,b,c
> ...
> >>> foo(1,2,3)
> 1 2 3
> >>> a = [1,2,3]
> >>> foo(*a)
> 1 2 3
> >>> b = [2,3]
> >>> foo(1,*b)
> 1 2 3
>
> This beats a super.apply special form any day!

Cute!  So ... is the 'spread' operator that spreads an array of  
arguments into a parameter list.",
    "header": Object {
      "date": 2007-12-21T12:56:44.000Z,
      "from": Object {
        "email": "ptw@pobox.com",
        "name": "P T Withington",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=super.apply%28this%2C%20arguments%29&In-Reply-To=C2643184-9ACC-424E-8A2A-3900BFE517C5%40mozilla.com",
      "subject": "super.apply(this, arguments)",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005180.html",
  },
  Object {
    "body": "Yes, its easy to pull off oneself, so I don't care much other way. Still, it
seems pretty weird to me to be able to do \`\`regex(str)\`\` but not
\`\`regex.call(context, str)\`\`. This is accentuated when typeof returns
\\"function\\" for regexes (though it seems ES4 will change this to \\"object\\").


Yuh-Ruey Chen wrote:
> 
> Sounds like a good idea to me. On the other hand, this can already
> easily be done in ES3.
> 
> Steven L. wrote:
>> ES4 proposals include making regexes callable as a function on a
>> single string argument, which serves as a shorthand for calling the
>> regex's exec method. To further extend this idea, what about also
>> including call and apply methods on RegExp.prototype ...
> 
> 

-- 
View this message in context: http://www.nabble.com/Add-call-and-apply-methods-to-RegExp.prototype-tp14429329p14457280.html
Sent from the Mozilla - ECMAScript 4 discussion mailing list archive at Nabble.com.",
    "header": Object {
      "date": 2007-12-21T15:33:38.000Z,
      "from": Object {
        "email": "steves_list@hotmail.com",
        "name": "StevenLevithan",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Add%20call%20and%20apply%20methods%20to%20RegExp.prototype&In-Reply-To=476B7632.1090208%40gmail.com",
      "subject": "Add call and apply methods to RegExp.prototype",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005181.html",
  },
  Object {
    "body": "On Dec 21, 2007, at 4:53 AM, P T Withington wrote:

> Can it refer to previous parameters?  Assign to them?  Is this legal?
>
>    function foo (a:t = x, b:u = (a = y, z))

AFAIK the formal parameters (bound in the variable object of the  
activation of foo) are not in scope when default parameters are  
computed.

/be",
    "header": Object {
      "date": 2007-12-21T20:40:35.000Z,
      "from": Object {
        "email": "brendan@mozilla.com",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=How%20complex%20can%20a%20parameter%20default%20expression%20be%3F&In-Reply-To=283EF080-6B21-4DEE-9E79-41E285182999%40pobox.com",
      "subject": "How complex can a parameter default expression be?",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005182.html",
  },
  Object {
    "body": "On Dec 21, 2007, at 7:33 AM, StevenLevithan wrote:

> Yes, its easy to pull off oneself, so I don't care much other way.  
> Still, it
> seems pretty weird to me to be able to do \`\`regex(str)\`\` but not
> \`\`regex.call(context, str)\`\`. This is accentuated when typeof returns
> \\"function\\" for regexes (though it seems ES4 will change this to  
> \\"object\\").

Hey Steve, Yuh-Ruey (I owe both of you replies to the list, for Steve  
agreeing about ES3 capturing paren broken design, Yuh-Ruey on fine  
points about instanceof, etc. -- I wanted to drop a note here,  
quickly, and catch up next week while I'm off).

The callability of RegExp has been a sore point to some (Garrett  
Smith at least sees no benefit), and it led SpiderMonkey, which has  
made RegExp instances callable since the last millennium, to follow  
the exact letter of ES3 and therefore have typeof /hi/ == \\"function\\".  
This deviates from other browsers, creating interop problems, and  
Firefox 3 (JS1.8) no longer follows ES3 here. For the same reason,  
ES4 is changing ES3 to say that typeof x == \\"function\\" iff x  
instanceof Function for some global object's Function constructor.

Given this back-off on the typeof front, and the more significant  
fact that !(/re/ instanceof Function), which we cannot change, I have  
to ask: is RegExp callability worth it?

Calling a regexp instead of invoking its .exec method is convenient  
enough once you get used to it, but .exec is only five more  
characters, and some people (sorry for forgetting exactly who they  
are) point out that calling a RegExp might rather be defined as a  
call to .test (to avoid creating the returned array -- here again an  
implementation can optimize based on the continuation of the call to  
the regexp object -- SpiderMonkey does this).

If we keep regexp callability in ES4 as a new convenience, then I  
agree we should think about call and apply. People can use  
Function.prototype.call, or in ES4 Function.call the static helper,  
but you end up passing the regexp twice (as the callee and the |this|  
parameter): Function.call(regexp, regexp, input) instead of simply  
regexp(input).

This raises the question: since there is only one argument to exec or  
test, so why do you ever need to delegate invocation using apply or  
call? The only case that comes to mind is a generic programming use- 
case where you might have either a function object or a regexp and  
you want to .apply it with an argument array. But again, you could  
just invoke foo(arg) given foo denoted either a function or a regexp.  
True, the most generic program would not want to hardwire argument  
count, so would want .apply. But still, the motivation for call and  
apply in RegExp.prototype seems weak.

Note that in Steve's example, regex.call(context, str), context  
*must* be a RegExp instance. There's no benefit to using .call  
or .apply over just regex(str) if you know you're passing exactly one  
(input string) argument.

Summarizing my questions:
1. Is regexp callability worth adding in ES4?
2. If yes to 1, do we really need .call and .apply?

I'm leaning toward no/no, could be content with yes/no, do not  
believe yes/yes based on the above reasoning.

/be

> Yuh-Ruey Chen wrote:
>>
>> Sounds like a good idea to me. On the other hand, this can already
>> easily be done in ES3.
>>
>> Steven L. wrote:
>>> ES4 proposals include making regexes callable as a function on a
>>> single string argument, which serves as a shorthand for calling the
>>> regex's exec method. To further extend this idea, what about also
>>> including call and apply methods on RegExp.prototype ...
>>
>>
>
> -- 
> View this message in context: http://www.nabble.com/Add-call-and- 
> apply-methods-to-RegExp.prototype-tp14429329p14457280.html
> Sent from the Mozilla - ECMAScript 4 discussion mailing list  
> archive at Nabble.com.
>
> _______________________________________________
> Es4-discuss mailing list
> Es4-discuss at mozilla.org
> https://mail.mozilla.org/listinfo/es4-discuss",
    "header": Object {
      "date": 2007-12-22T00:06:56.000Z,
      "from": Object {
        "email": "brendan@mozilla.org",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Add%20call%20and%20apply%20methods%20to%20RegExp.prototype&In-Reply-To=14457280.post%40talk.nabble.com",
      "subject": "Add call and apply methods to RegExp.prototype",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005183.html",
  },
  Object {
    "body": "On 22/12/2007, Brendan Eich <brendan at mozilla.org> wrote:
> Summarizing my questions:
> 1. Is regexp callability worth adding in ES4?

I would say a tentative no to that. It neither adds anything new nor
significantly reduces code size. As you say, re() is only five
characters shorter than re.exec. The only real benefit from it that I
can see is that it allows generalised functions to call any
function-or-regex argument on a string, instead of having to fork the
code.

> 2. If yes to 1, do we really need .call and .apply?

I don't think it's needed, except for symmetry with real functions.




(Does this stance make me a hypocrite for being the one who filed the
RFE for this feature in Opera?)
-- 
David \\"liorean\\" Andersson",
    "header": Object {
      "date": 2007-12-22T01:34:02.000Z,
      "from": Object {
        "email": "liorean@gmail.com",
        "name": "liorean",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Add%20call%20and%20apply%20methods%20to%20RegExp.prototype&In-Reply-To=88A30765-98D3-4D54-AF55-F108AFE6B87E%40mozilla.org",
      "subject": "Add call and apply methods to RegExp.prototype",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005184.html",
  },
  Object {
    "body": "(I agree with liorean.)

> 1. Is regexp callability worth adding in ES4?

IMO, no it isn't. Although I do enjoy the convenience of things like 
array.filter(/regex/) (which works in Firefox today), outside of array 
iteration methods it typically just saves five characters and is not 
behavior most people would expect. If I want to be able to pass regexes 
around as functions and use call and apply on them in the cases where it is 
helpful, I can implement this functionality myself (my custom methods would 
likely ignore the context argument ... e.g. 
RegExp.prototype.call=function(context,str){return this.exec(str);}; ).

> 2. If yes to 1, do we really need .call and .apply?

I don't think it's needed, but the symmetry with real functions seems 
natural to me (but only if callability were to be preserved, which as noted 
above is not something I'd argue for).

As for whether test or exec should be the method used if callability is 
preserved, I think test is what would be desired in far more cases. However, 
I have grown used to the idea of exec being the default method (since the 
functionality of all regex and regex-using string methods can be reproduced 
using exec), and the null and array values returned by exec cast nicely to 
booleans anyway. So, I don't really care either way.",
    "header": Object {
      "date": 2007-12-22T03:58:26.000Z,
      "from": Object {
        "email": "steves_list@hotmail.com",
        "name": "Steve",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Add%20call%20and%20apply%20methods%20to%20RegExp.prototype&In-Reply-To=BAY124-W34BC42B6E975571B1BB8FC905D0%40phx.gbl%3E%3C476B7632.1090208%40gmail.com",
      "subject": "Add call and apply methods to RegExp.prototype",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005185.html",
  },
  Object {
    "body": "That seems like an unnecessary restriction, no? Since argument 
evaluation is already restricted to left-to-right, we could allow 
default-expressions to refer to earlier arguments without too much 
trouble, unless I'm missing something obvious.

Dave

Brendan Eich wrote:
> On Dec 21, 2007, at 4:53 AM, P T Withington wrote:
> 
>> Can it refer to previous parameters?  Assign to them?  Is this legal?
>>
>>    function foo (a:t = x, b:u = (a = y, z))
> 
> AFAIK the formal parameters (bound in the variable object of the  
> activation of foo) are not in scope when default parameters are  
> computed.
> 
> /be
> _______________________________________________
> Es4-discuss mailing list
> Es4-discuss at mozilla.org
> https://mail.mozilla.org/listinfo/es4-discuss",
    "header": Object {
      "date": 2007-12-22T13:30:32.000Z,
      "from": Object {
        "email": "dherman@ccs.neu.edu",
        "name": "Dave Herman",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=How%20complex%20can%20a%20parameter%20default%20expression%20be%3F&In-Reply-To=164243D1-EF4F-46D0-9BA9-F908CEE4479F%40mozilla.com",
      "subject": "How complex can a parameter default expression be?",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005186.html",
  },
  Object {
    "body": "On 21/12/2007, at 11:56 PM, P T Withington wrote:
> Cute!  So ... is the 'spread' operator that spreads an array of  
> arguments into a parameter list.

Sounds similar to the splat operator of Ruby:

     def foo(first, second, *rest)
       puts first, second, rest.inspect
     end

     foo(1,2)
     => 1 2 []

     foo(1,2,3,4,5)
     => 1 2 [3, 4, 5]

     rest = [3,4,5]
     foo(1,2, *rest)
     => 1 2 [3, 4, 5]

     rest = [3,4,5]
     foo(1,2, rest)
     => 1 2 [[3, 4, 5]]


Cheers,

--
Nathan de Vries",
    "header": Object {
      "date": 2007-12-23T00:54:12.000Z,
      "from": Object {
        "email": "nathan@atnan.com",
        "name": "Nathan de Vries",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=super.apply%28this%2C%20arguments%29&In-Reply-To=0C1F657C-083A-49E9-8022-8AA160A67775%40pobox.com",
      "subject": "super.apply(this, arguments)",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005187.html",
  },
  Object {
    "body": "C-style syntax is hard to parse in general, but regex literals can be 
particularly tricky. However, many kinds of tools (syntax highlighters, 
minifiers, etc.) need to parse them accurately, but unfortunately most such 
ECMAScript-based tools don't (I could start naming high-profile tools with 
edge-case regex-syntax parsing bugs, but it should be obvious that it is not 
entirely trivial). ES4 regex proposals make this even harder in several 
ways, but worst of all (from a regex syntax parser complexity perspective) 
is the java.util.regex-inspired infinitely-nesting character class 
subtraction and intersection syntax.

Now, I understand that the feature is powerful (and I assume also quite 
useful in the case of regexes which make heavy use of ES4's Unicode property 
tokens), but it effectively makes it impossible to parse ES4 regex syntax 
using ES4 regexes (which lack PCRE/.NET/Perl's recursion support). And 
considering that java.util.regex is the only (major) regex library to 
include full character class set operations (.NET only does class 
subtraction), I don't think people would miss the feature that greatly.

Of course, mixing recursion support into existing regex syntax parsers is 
probably not really all that difficult in most cases, but nevertheless, I'm 
interested in what others think about the character class subtraction and 
intersection features. Personally, I think only allowing one level of 
character class nesting might be a reasonable compromise, especially since 
people could emulate more levels of nesting using lookahead anyway.",
    "header": Object {
      "date": 2007-12-23T03:40:35.000Z,
      "from": Object {
        "email": "steves_list@hotmail.com",
        "name": "Steve",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Are%20regex%20character%20class%20set%20operations%20%28subtraction%2C%0A%09intersection%29%20worth%20the%20parsing%20complexity%3F&In-Reply-To=BAY124-W34BC42B6E975571B1BB8FC905D0%40phx.gbl%3E%3C476B7632.1090208%40gmail.com",
      "subject": "Are regex character class set operations (subtraction,	intersection) worth the parsing complexity?",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005188.html",
  },
  Object {
    "body": "Brendan Eich wrote:
> On Dec 21, 2007, at 7:33 AM, StevenLevithan wrote:
>
> > Yes, its easy to pull off oneself, so I don't care much other way.  
> > Still, it
> > seems pretty weird to me to be able to do \`\`regex(str)\`\` but not
> > \`\`regex.call(context, str)\`\`. This is accentuated when typeof returns
> > \\"function\\" for regexes (though it seems ES4 will change this to  
> > \\"object\\").
>
> Hey Steve, Yuh-Ruey (I owe both of you replies to the list, for Steve  
> agreeing about ES3 capturing paren broken design, Yuh-Ruey on fine  
> points about instanceof, etc. -- I wanted to drop a note here,  
> quickly, and catch up next week while I'm off).
>   

I'm glad you still remember it :)

> This raises the question: since there is only one argument to exec or  
> test, so why do you ever need to delegate invocation using apply or  
> call? The only case that comes to mind is a generic programming use- 
> case where you might have either a function object or a regexp and  
> you want to .apply it with an argument array. But again, you could  
> just invoke foo(arg) given foo denoted either a function or a regexp.  
> True, the most generic program would not want to hardwire argument  
> count, so would want .apply. But still, the motivation for call and  
> apply in RegExp.prototype seems weak.

With currying, I find that use case a moot point. For example, we could do:

foo(regex.exec.bind())

and foo would still be generic. So really, regex invocation is not
needed. Speaking of bind (or whatever it's called), I hope the function
is memoized, since it might be used a lot.",
    "header": Object {
      "date": 2007-12-23T08:51:58.000Z,
      "from": Object {
        "email": "maian330@gmail.com",
        "name": "Yuh-Ruey Chen",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Add%20call%20and%20apply%20methods%20to%20RegExp.prototype&In-Reply-To=88A30765-98D3-4D54-AF55-F108AFE6B87E%40mozilla.org",
      "subject": "Add call and apply methods to RegExp.prototype",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005189.html",
  },
  Object {
    "body": "(I emailed this to the list last night, but it doesn't seem to have gone
through. Sorry if this becomes a dupe.)
-----

As far as I understand from ECMA-262 3rd Edition, the regexp.lastIndex
property is meaningless if a regexp does not use the /g modifier. Quoting
from E262v3 §15.10.6.2 (RegExp.prototype.exec):

> 4. Let i be the value of ToInteger(lastIndex).
> 5. If the global property is false, let i = 0.

So, e.g., the following returns true, although it would return false if /g
were used:

var re = /x/;
re.lastIndex = 2;
re.test(\\"xyz\\"); // true

Given the above rule, my questions are:

1. Does ES4's /y (sticky) modifier have any meaning if the /g (global)
modifier is not also set?

2. What about with String.prototype.split and String.prototype.search, which
ignore the values of regexp.global and regexp.lastIndex?

The extend_regexps proposal on the wiki does not specifically mention these
points, and the sticky modifier does not appear to be implemented in the ES4
reference implementation (the sticky property gets set with /y, but it
doesn't appear to work).

I'm working on code which brings some of the ES4 regex features (including
/y) to current browsers, but I'm not sure which way to go on these points.

-- 
View this message in context: http://www.nabble.com/Does-the-RegExp--y-modifier-require--g--tp14488851p14488851.html
Sent from the Mozilla - ECMAScript 4 discussion mailing list archive at Nabble.com.",
    "header": Object {
      "date": 2007-12-24T16:44:57.000Z,
      "from": Object {
        "email": "steves_list@hotmail.com",
        "name": "StevenLevithan",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Does%20the%20RegExp%20/y%20modifier%20require%20/g%3F&In-Reply-To=",
      "subject": "Does the RegExp /y modifier require /g?",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005190.html",
  },
  Object {
    "body": "On Dec 24, 2007, at 8:44 AM, StevenLevithan wrote:

> (I emailed this to the list last night, but it doesn't seem to have  
> gone
> through. Sorry if this becomes a dupe.)

(I don't see a moderator request based on your sending from a  
different e-mail address -- I don't see a dup either.)

> Given the above rule, my questions are:
>
> 1. Does ES4's /y (sticky) modifier have any meaning if the /g (global)
> modifier is not also set?

Yes.

> 2. What about with String.prototype.split and  
> String.prototype.search, which
> ignore the values of regexp.global and regexp.lastIndex?

The /y flag makes unanchored regexps match or fail at the current  
position in the target string, period. Where the current position is  
may depend on /g and other things, but /y is independent (lower- 
level) than these considerations.

> I'm working on code which brings some of the ES4 regex features  
> (including
> /y) to current browsers, but I'm not sure which way to go on these  
> points.

Firefox 3 is in beta release now and has supported /y since an early  
alpha. See https://bugzilla.mozilla.org/show_bug.cgi?id=371932.

/be",
    "header": Object {
      "date": 2007-12-24T21:15:00.000Z,
      "from": Object {
        "email": "brendan@mozilla.org",
        "name": "Brendan Eich",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Does%20the%20RegExp%20/y%20modifier%20require%20/g%3F&In-Reply-To=14488851.post%40talk.nabble.com",
      "subject": "Does the RegExp /y modifier require /g?",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005191.html",
  },
  Object {
    "body": ">> 1. Does ES4's /y (sticky) modifier have any meaning if the /g (global)
>> modifier is not also set?
>
> Yes.

My question was very poorly worded. I was thinking along the lines of 
behavior being affected by lastIndex (set manually or via the use of /g).

> The /y flag makes unanchored regexps match or fail at the current 
> position in the target string, period. Where the current position is  may 
> depend on /g and other things, but /y is independent (lower- level) than 
> these considerations. [...]
> Firefox 3 is in beta release now and has supported /y since an early 
> alpha. See https://bugzilla.mozilla.org/show_bug.cgi?id=371932.

Thanks. Your response and the Firefox 3 beta answers all my questions on 
this point. The /y modifier is a great addition and every aspect of it seems 
to work like I would expect/hope.",
    "header": Object {
      "date": 2007-12-24T22:53:45.000Z,
      "from": Object {
        "email": "steves_list@hotmail.com",
        "name": "Steve",
      },
      "reply": "mailto:es-discuss%40mozilla.org?Subject=Does%20the%20RegExp%20/y%20modifier%20require%20/g%3F&In-Reply-To=14488851.post%40talk.nabble.com",
      "subject": "Does the RegExp /y modifier require /g?",
    },
    "url": "https://mail.mozilla.org/pipermail/es-discuss/2007-December/005192.html",
  },
]
`;
